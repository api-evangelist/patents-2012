---

title: Devices as services in a decentralized operating system
abstract: Various embodiments of the present invention transform devices into Web services or special-purpose servers that are capable of communicating with personal computers. Various embodiments of the present invention allow various low-level aspects of device drivers to reside in the devices, eliminating the need for the devices to be compatible with legacy specification. Various embodiments of the present invention allow various devices to be shipped from the factory with low-level software already built in so that users are liberated from having to deal with the experience of installing and upgrading device drivers. In various embodiments of the present invention, each device is preferably a network node identifiable by a Uniform Resource Identifier (URI).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572632&OS=08572632&RS=08572632
owner: Microsoft Corporation
number: 08572632
owner_city: Redmond
owner_country: US
publication_date: 20120203
---
This application is a continuation of U.S. Pat. No. 8 112 764 filed Nov. 20 2003 which is incorporated herein by reference in its entirety.

The present invention relates to devices as subsystems of computing systems and more particularly to a basic design structure in which devices are represented as services in a decentralized operating system.

What s bright blue that strikes terror into the heart of a personal computer user It is the dreaded blue screen which is caused almost always by programming errors. Device drivers are a common source of these errors. A device driver is a software component that permits a computer system to communicate with a device. If a correct driver is not installed in a system a device cannot be used because in most cases the driver is the only piece of software that understands how to manipulate the hardware used to communicate with the device. Given the proliferation of devices and device drivers programming errors have exploded exponentially. It is virtually impossible for a programmer to visualize all the interactions between devices and computers or to determine the results of interactions with every other device to which a computer may be interconnected. shows a system that illustrates these problems and other problems in greater detail.

One problem with such a tightly coupled design is that it is vulnerable. By exposing device drivers in the single address space these device drivers can act as Trojan horses for housing unreliable code that can deadlock the Linux operating system . In almost all cases the only way for applications to communicate with the input output devices is by means of device drivers in kernel mode. Kernel mode is the most privileged execution mode of the Linux operating system . Privileged means that there is no way for the Linux operating system to monitor the running code of the device drivers or to protect memory from being accessed. Thus errant kernel mode device drivers can do whatever they want with no oversight by the Linux operating system . One example is the issue of handling hardware interrupt generation. Due to the asynchronous nature of hardware interrupts just one programming error in the interrupt handler may deadlock the system or corrupt data in a pathologic rarely reproducible manner.

Devices of yesteryear seemed stable because their numbers were few and their interconnections to computers were simple. Devices nowadays have proliferated to the benefit of users but such proliferation is attended by a marked increase in the number of device drivers necessary to provide links between applications and input output devices . Without a solution to increase reliability of errant device drivers users may eventually no longer trust the system to provide a desired computing experience causing demand for the system to diminish from the marketplace. Thus there is a need for a method and a system for representing devices as services while avoiding or reducing the foregoing and other problems associated with existing systems.

In accordance with this invention a system method and computer readable medium for representing devices as services is provided. The system form of the invention includes in a networked system a device that is a computer subsystem. The device comprises one or more services executing in the device. Each service includes a port identifiable by an identifier that includes a uniform resource identifier and a contract for describing one or more behaviors of the service.

Another system form of the invention includes in a networked computer system a terminal service. The terminal service comprises a display service with a port identifiable by an identifier that includes a uniform resource identifier and a contract for describing one or more behaviors of the display service. The terminal service further comprises a keyboard service with a port identifiable by an identifier that includes a uniform resource identifier and a contract for describing one or more behaviors of the keyboard service. The terminal service further comprises a mouse service with a port identifiable by an identifier that includes a uniform resource identifier and a contract for describing one or more behaviors of the mouse service.

A method form of the invention includes a computer implemented method for processing input output events by devices as services. The method comprises requesting a service representing a device for an input output event. The service includes a port identifiable by an identifier that includes at a uniform resource identifier and a contract for describing one or more behaviors of the service. The method further comprises receiving a customizable tag based message that contains the input output event. The method yet further comprises requesting the service to remove the input output event.

A computer readable form of the invention includes a computer readable medium having computer executable instructions for implementing a computer implemented method for processing input output events by devices as services. The method comprises requesting a service representing a device for an input output event. The service includes a port identifiable by an identifier that includes a uniform resource identifier and a contract for describing one or more behaviors of the service. The method further comprises receiving a customizable tag based message that contains the input output event. The method yet further comprises requesting the service to remove the input output event.

Another system form of the invention includes in a networked system a device that is a computer subsystem. The device comprises one or more services executing in the device. Each service includes a port identifiable by an identifier that includes a uniform resource identifier. The device is capable of coupling to the networked system to exchange customizable tag based messages.

Various embodiments of the present invention transform devices into Web services or special purpose servers that are capable of communicating with other devices such as personal computers. Various embodiments of the present invention allow various low level aspects of device drivers to reside in the devices hence eliminating the need for the devices to be compatible with legacy specification. Various embodiments of the present invention allow various devices to be shipped from the factory with low level software already built in so that users are liberated from having to deal with the experience of installing and upgrading device drivers. In various embodiments of the present invention each device is preferably a network node identifiable by a Uniform Resource Identifier URI . The term service as used hereinbelow and hereinbefore means the inclusion of loosely coupled services.

Sharing resources is possible through interaction in a way compatible with the behaviors of the resources. Behaviors of resources represented by services are expressed in unilateral contracts. A service can be regulated by a unilateral contract. Thus one can attach behavioral conditions to files via unilateral contracts to govern access control. A portion of the unilateral contract A is illustrated in . Line A contains the key word UNILATERALCONTRACT followed by the designator PDA and a pair of open and closed curly brackets for delimiting the definition of the unilateral contract A . Line A declares the signature of the OPEN operation that takes a file name FILENAME as a parameter. To use the operating system service A external services specify a name of a file to be opened via the OPEN operation. Thus the OPEN operation should be the first operation that is invoked by other services for each session. The PLAY operation is declared in line A . The PLAY operation takes another service s port as a parameter. When the PLAY operation is invoked by other services the operating system service A reads a stream of data from an open file and transmits the read data toward the given service s port. Other services such as the operating system service B can also record information to opened files via the RECORD operation which is declared on line A . The RECORD operation takes data as a parameter. This data is written by the RECORD operation to the opened file. When all desired operations have been carried out on the opened file the opened file can be closed via the CLOSE operation which is declared on line A . The CLOSE operation takes a file name FILENAME as an argument so that the CLOSE operation knows which file to close.

Lines A A contain the behaviors of the operating system service A. Line A contains a behavior sentence B OPEN.BPR where B is a behavior rule OPEN denotes that the OPEN operation is the first operation to be invoked in using the operating system service A the period . denotes that additional behaviors are to follow the invocation of the OPEN operation and BPR refers to a second behavior sentence defined further on line A . Line A contains the following behavioral sentence BPR PLAY.BPR RECORD.BPR CLOSE where BPR denotes the second behavior PLAY.BPR denotes the invocation of the PLAY operation which is then followed by the second behavior again a recursion RECORD.BPR denotes the invocation of the RECORD operation which is then followed recursively by the second behavior CLOSE denotes the invocation of the CLOSE operation and the plus signs denote choices that other services such as the operating system service B can make to invoke among the PLAY operation the RECORD operation or the CLOSE operation.

A portion of the unilateral contract B is illustrated in . Line B contains the keyword UNILATERALCONTRACT followed by the designator SPEAKER and a pair of open and closed curly brackets for delimiting the definition of the portion of the unilateral contract B . Line B declares the signature of the OPEN operation that takes a file name FILENAME as a parameter. The REPRODUCE operation is declared on line B . The REPRODUCE operation takes another service s port as a parameter. The CLOSE operation is declared on line B and it takes a filename FILENAME as an argument so that the CLOSE operation knows which file to close.

Lines B B contain the behaviors of the operating system service B. Line B contains a behavior sentence B OPEN.BP where B is a behavior rule OPEN denotes that the OPEN operation is the first operation to be invoked in a session with the operating system service B the period . denotes that the additional behaviors are to follow the invocation of the OPEN operation and BP refers to a second behavior sentence defined further on line B . Line B contains the following behavioral sentence BP REPORDUCE.BP CLOSE where BP denotes the second behavior REPRODUCE.BP denotes the invocation of the REPRODUCE operation which is then followed by the second behavior again a recursion CLOSE denotes the invocation of the CLOSE operation and the plus sign denotes choices that an external service such as the operating system service A can make to invoke among the REPRODUCE operation and the CLOSE operation.

The unilateral contract A when accepted by the service B and the unilateral contract B when accepted by the service A creates an instance of communication between the service A and the service B. Each unilateral contract A B can be accepted by the services A B by a mere promise to perform but preferably is accepted by the performance of unilateral contracts A B in accordance with the behaviors expressed in those unilateral contracts. Thus if the service B complies with and performs the behaviors as expressed by behavior sentences A A of the unilateral contract A the service B is bound to provide the promised services. For example if the operating system service B has performed by first invoking the OPEN operation as specified by the behavioral sentence A and then either invokes the PLAY operation or the RECORD operation or the CLOSE operation as specified by the behavioral sentence shown on line A then the operating system service A complies with the requested invocations to provide the desired services such as opening a file playing the content of the file recording content into a file or closing the file.

A number of devices as services each with a port identifiable by an identifier such as a URI B B and a unilateral contract A A are illustrated at . The display service represents a display which is the visual output device of a computer which is commonly a CRT based video display but increasingly is comprised of an LCD based or gas plasma based flat panel display. The mouse service represents a mechanical mouse which is a common pointing device. The basic features of a mechanical mouse are a flat bottom casing designed to be gripped by one hand one or more buttons on the top a multi directional detection device usually a ball and some shaft encoders on the bottom and a cable connecting the mouse to the computer. By moving the mouse on a surface such as a desktop the user typically controls an on screen cursor. A mouse is a relative pointing device because there are no defined limits to the mouse s movement and because its placement on a surface does not map directly to a specific screen location. To select items or choose commands on the screen the user presses one of the mouse s buttons producing a mouse click. The keyboard service represents a keyboard which is a hardware unit with a set of switches that resembles a typewriter keyboard and that conveys information from a user to a computer or data communication circuit. The PDA service represents a personal digital assistant which is a lightweight computer designed to provide specific functions like personal organization calendar note taking database calculator and so on as well as communications. One exemplary unilateral contract A for the PDA service includes the unilateral contract A . More advanced personal digital assistants also offer multimedia features such as music playing. Many personal digital assistants rely on a pen or other pointing device for input instead of a keyboard or a mouse although some offer a keyboard too small for touch typing to use in conjunction with a pen or pointing device. For data storage a personal data assistant relies on flash memory instead of power hungry disk drives. The loudspeakers service represents loudspeakers which are devices that accept customizable tagged based messages containing a digital encoding of sound which transform the contents of the messages into sounds loud enough to be heard by the user. One exemplary unilateral contract A for the loudspeakers service includes the unilateral contract B . 

Whereas conventionally each device represented by the display service the mouse service the keyboard service the PDA service and the loudspeaker service would require separate device drivers various embodiments of the present invention dispense with a specific device driver for each device represented by one of the services . Only one network device driver need be present for various services to communicate with the decentralized operating system and eventually with an application being represented by an application service identifiable by an identifier such as a URI B and a unilateral contract A.

A customizable tag based document reproducible by a data service not shown of the composed service is illustrated at . The customizable tag based document holds the keyboard events and mouse events that have been generated by the mouse service and the keyboard service but which have not yet been consumed by the application service . The application service normally subscribes to changes in the data service so that the application service is informed when a new event is generated and has appeared in the data service of the composed service . The customizable tag based document includes a data element defined between tag A and its companion ending tag AA . The tag A includes an attribute XMLNS C for defining a name space and can be found at an address HTTP SCHEMAS.COM COORDINATOR . Contained between tags A AA are zero or more data item elements for capturing either a keyboard event generated by the keyboard service or a mouse event generated by the mouse service . One exemplary keyboard event is defined between a tag B and its companion ending tag L. A time element is defined at line D by a tag . The time element specified a time when the data item element was generated using system global time. The time element allows ease of understanding the sequence by which events happened. Even if times between events are small e.g. mouse clicks or the events occurred on different devices e.g. control click lines E G capture the states of the modifier keys of the keyboard represented by the keyboard service . Line E CONTAINS the state of the control key via a tag . Line F contains the state of the ALT key which is defined by tag . Line G contains the state of the shift key via a tag .

An actuated key on the keyboard is captured by a keystroke element defined between a tag H and its companion ending tag K . Contained between tags H K is an element defined by tag on line which contains a TRUE value if the code represented by the below described element is an extended code such as a function key. Line J defines a tag for containing the character code generated from the actuation of a key on the keyboard.

The customizable tag based document includes zero or more mouse events. One exemplary mouse event is captured by a data item element defined between tag M and its companion ending tag Z . A time element is defined on line by a tag . The time element specifies the time when the data item element was generated. Lines P R include tags and for capturing the state of modifier keys on the keyboard represented by the keyboard service . The shift key state is captured on line R by tag . The mouse event is captured between a tag S and its companion ending tag Y . If a mouse button was actuated tag on line T captures the button code. Tag U and its companion ending tag X contain information pertaining to the position of the mouse. Line V describes tag signifying the horizontal position of the mouse. Line W includes tag signifying the vertical position of the mouse.

A customizable tag based document producible by the info service C upon request is illustrated at . The info service C holds a summary of the properties of the mouse that the mouse service represents. A tag A includes an attribute XMLNS M for defining a name space for the mouse service along with its companion ending tag D. The attribute XMLNS M is defined to include an address HTTP SCHEMAS.COM M I . Line B defines tag which is indicative of the number of buttons on the mouse represented by the mouse service . The application service may use the tag to configure its user interface. Line C defines tag which is indicative of the scale of mouse motion events preferably in shaft encoder units per some suitable linear dimension. One suitable linear dimension includes inches but others may be used.

A keyboard service as a composed service is formed from an info service C with a port identifiable by an identifier such as a URI C and a unilateral contract C and a data service D with a port identifiable at URI D and a unilateral contract D . See . The keyboard service provides an interface to a standard keyboard. When a key is actuated or a modifier key is pressed or released a keyboard event is self inserted into the data service D. The application service can directly request generated events from the data service D or the application service can ask the data service D to automatically inform the application service of any changes in its event store. Normal key actuations are preferably generated as Unicode characters. To allow keyboard events to be generated by things that are not actually keyboards e.g. a virtual keyboard on a display the release of normal key actuations is preferably not reported. A finite number of keyboard events can be inserted into the data service D. If the maximum number of events have already been contained the data service D preferably discards the new keyboard events.

A customizable tag based document which is produced by the info service C upon request is illustrated at . A tag A and its companion ending tag F define an info element. The info element includes an attribute for defining the namespace of the keyboard service . The attribute is XMLNS K containing an address HTTP SCHEMAS.COM K I . Contained between tags A F is a tag B which has the value TRUE if the keyboard has function keys such as keys labeled F through F. A tag C is set to TRUE if the keyboard has navigation keys such as the four arrow keys the INSERT key the DELETE key the HOME key the END key and the PAGE UP and PAGE DOWN keys. Tag D is set to TRUE if the keyboard has a numeric keypad. State changes of the NUMLOCK key are not reported to the application service . Instead the NUMLOCK key which modifies the codes sent by other keys in the numeric keypad is processed completely by the keyboard service . Tag E is set to TRUE if the keyboard has Windows keys.

The display service includes an info service C with a port identifiable with a URI C and a unilateral contract C . See . The info service C includes a customizable tag based document . See . A tag A and its companion ending tag E define an info element holding a summary of the properties of the display . Tag B contains the size of the width of the screen of the display in pixels. Tag C describes the size of the height of the screen of the display in pixels. Tag D describes the native pixel format of the screen of the display .

The display service includes a cursor shape service D with a port identifiable by an identifier such as a URI D and a unilateral contract D . See . The cursor shape service D describes the current shape of the on screen cursor C. The shape is described by a customizable tag based document . See . Tag A and its companion ending tag G define a shape element for the on screen cursor C. Tag B preferably contains a 128 byte block of image data encoded using base 64 notation which represents a 32 32 two level bitmap. The data is preferably in network byte order so that the most significant bit of byte 0 corresponds to location 0 0 of the bitmap and the least significant bit of byte 2127 corresponds to location 31 31 of the bitmap. Tag C also holds a 128 byte block of data encoded using base 64 notation which represents a 32 32 two level bitmap. Again the data of the mask element defined by tag C is preferably in network byte order so that the most significant bit of byte 0 corresponds to location 0 0 of the bitmap and the least significant bit of byte 127 corresponds to location 31 31 of the bitmap. The bitmap of the mask element specifies which pixels are actually part of the on screen cursor a 1 means the pixel is valid . The bitmap of the image element specifies the actual pixels 0 means black and 1 means white . The on screen cursor C can be hidden by specifying a bitmap for the mask element where all bits are 0. Tag D and its companion ending tag H specify the offset between the cursor hotspot which is the location actually coupled to the current location of the mouse and the location 0 0 of the cursor bitmaps. Preferably this will be a location within the cursor bitmaps but the offsets are signed and so the hotspot can be outside the bitmaps in any direction. Between tags D H is tag E for defining the horizontal offset. Tag F defines the vertical offset for the hotspot element.

The display service includes a cursor position service E with a port identifiable by an identifier such as a URI E and a unilateral contract E . See . A customizable tag based document describes the current preferably absolute position of the on screen cursor C. See . Tag A and its companion ending tag D define a position element. Between tags A D is tag B for defining the horizontal position of the on screen cursor C. The vertical position of the on screen cursor C is defined by tag C . The tag A includes an attribute XMLNS D which is defined to contain an address HTTP SCHEMAS.COM P P .

The display service includes one or more window services F with a port identifiable by an identifier such as a URI F and a unilateral contract F . See . Each instantiation of the window service F represents each corresponding window A B. The window service F includes a customizable tag based document for describing a window A B that it is representing. See . Tag A and its companion ending tag H define a window element. Tag A includes an attribute XMLNS D for defining the name space for the window element. The attribute XMLNS D is equated to an address HTTP SCHEMAS.COM D W . Between tags A H is tag B for containing the info service URI C of the display upon which the window A B being represented by the window service F is displayed. Tag C and tag D describe the coordinates of the top left corner of the window A B on the screen of the display . The top left corner of the window A B is preferably on the screen of the display . Tag E and tag F describe the size of the window A B. If either the tag E or the tag F contain the zero value then the window A B covers no pixels on the screen of the display and is invisible. Tag G describes the automatic drop time for the window A B. If the value of the drop time element defined by tag G is non zero the window A B is automatically deleted if the value of the drop time element is less than the current system global time.

The display service includes a window list service G with a port identifiable by an identifier such as a URI G and a unilateral contract G . See . The window list G is used to maintain a list of windows A B which are actually shown on the screen of the display in window stack order. The window list service G includes a customizable tag based document for describing the order of presentation of windows A B. See . Tag A and its companion ending tag D define the windows element. One or more tags B C contain the URI of a window service such as the window service URI F . Tags B C define two URI elements. The order of the URI elements defines the window stack order on the display . The first URI element in the list indicates that the window is at the front of the stack and the last URI element in the list indicates that the window is at the back of the stack.

The display service includes one or more window update services H with a port identifiable by an identifier such as a URI H and a unilateral contract H . See . The application service changes the pixels associated with the window A B by creating a window update service H with an appropriate unilateral contract H associating the window update service H with the window A B and sending an update request to the window update service H to refresh or repaint the window A B. Preferably each format of data from the application service has its own type of window update service H each with its own unilateral contract H . Preferably all of the parameters needed to change the pixels associated with the window A B are part of the state of the window update service H.

From terminal A the method proceeds to decision block where a test is made to determine whether a key on the keyboard has been actuated. If the answer is NO the method loops back to decision block and repeats the above described processing step. Otherwise if the answer to decision block is YES the method proceeds to block where a keyboard event is self inserted into the data service D. At block the application service is notified of the insertion of the keyboard event. The application service processes each keyboard event in order of time. See block . The method proceeds to block where the application service sends a message to the data service D to delete the keyboard event that was processed. At block the data service D of the keyboard service removes the keyboard event that was processed. The method then enters the exit terminal B.

From exit terminal B the method proceeds to a set of method steps defined between a continuation terminal terminal C and an exit terminal terminal D . The set of method steps describes the process by which a mouse service processes mouse events see .

From terminal C the method proceeds to decision block where a test is made to determine whether the mouse has been actuated. If the answer to the test at decision block is NO the method loops back to decision block where the above described processing step is repeated. Otherwise the answer to the test at decision block is YES and the method proceeds to block where the mouse event is self inserted into the data service D. At block the application service is notified of the insertion of the mouse event. The application service processes each mouse event in order of time. See block . The method proceeds to block where the application service sends a message to the data service D to delete the mouse event that was processed. At block the data service D of the mouse service removes the mouse event that was processed. The method continues to exit terminal D.

From exit terminal D the method proceeds to a set of method steps defined between a continuation terminal terminal E and an exit terminal terminal F . The set of method steps describes the process by which a display service processes display events see .

From terminal E the method proceeds to decision block where a test is made to determine whether to create a window. If the answer to the test at decision block is YES the method proceeds to block where the window service F is created with the URI F identifying the window service F. At block the created window service F is inserted into the window list service G by the application service and thereby controlling the stacking order of the windows A B on the screen of the display . If the answer to the test at decision block is NO the method proceeds to another decision block . From block the method also continues to decision block . At decision block a test is made to determine whether a window A B needs to be updated with new pixels. If the answer is YES the application service sends the desired update to the window update service H and the window update service H repaints the corresponding window A B with new pixels. See block . If the answer to the test at decision block is NO the method proceeds to another continuation terminal terminal E .

From terminal E the method proceeds to decision block where a test is made to determine whether there is a new cursor shape. If the answer is yes the cursor shape service D is updated with a new image at block . At block the cursor shape service D is updated with a new mask. From block the method proceeds to another decision block . If the answer is NO to decision block the method also continues to decision block . A test is made at decision block to determine whether there has been a mouse event. If the answer to the test at decision block is YES the position of the on screen cursor C is updated. See block . If the answer to the test at decision block is NO the method continues to another continuation terminal terminal E . From block the method also continues to the exit terminal F. From terminal F the method terminates execution.

While the preferred embodiment of the invention has been illustrated and described it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.

