---

title: Key-break and record-loop processing in parallel data transformation
abstract: Embodiments of the invention provide a method and apparatus for providing additional functionality to a data processing program. This is achieved by various means, including preprocessing records in a data volume, designating certain records with a key-break, and creating an aggregation structure that user programs may use to store previously-processed records from the data volume.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08793280&OS=08793280&RS=08793280
owner: International Business Machines Corporation
number: 08793280
owner_city: Armonk
owner_country: US
publication_date: 20120613
---
This application is a continuation of co pending U.S. patent application Ser. No. 12 789 256 filed May 27 2010. The aforementioned related patent application is herein incorporated by reference in its entirety.

Embodiments of the invention generally relate to data processing. And more specifically embodiments are related to techniques for key break and record loop processing in parallel data transformation in a parallel data processing system.

A common challenge for many modern computer environments is managing large volumes of data. Various systems and software applications exist today for managing and processing large amounts of data. These tools are very useful for data processing in a broad variety of fields including web portals medical applications financial applications and web applications to name but a few examples.

For example one such application has been created by International Business Machines IBM under the name InfoSphere DataStage . The DataStage software application is an extract transform and load ETL utility that is part of the IBM Information Server suite. The DataStage application features a high performance parallel framework and supports the collection integration and transformation of large volumes of data. Specifically DataStage software uses a pipeline model for processing one record of a data volume at a time in each stage of the pipeline. Data flow in such a pipeline may be acyclic allowing data to only flow in one direction. As each stage finishes processing a record it may pass the record to the next stage in the pipeline for further processing. For example one stage may be a transformer stage through which users may modify add or remove data in a record of a data volume one record at a time while another stage may be a data source stage which reads the records in from a source data volume. In this example the data source stage may read a record from the data volume and then pass the record to the transformer stage for processing.

Additionally the DataStage application may use data partitioned parallelism to increase performance in certain stages. That is input data may be partitioned or re partitioned as needed while flowing through the pipeline. If a stage is able to process records in parallel input records to that stage are first partitioned and then the data on each partition is processed by an instance of that stage. For example data entering the transformer stage may be partitioned into four partitions and then four instances of the transformer may process the partitioned data with each stage processing a separate partition of input data. By taking advantage of data partitioned parallelism the DataStage application is able to process records more efficiently and effectively.

Although the parallel nature of pipeline processing gives applications such as DataStage increased performance it also leads to additional challenges as due to their pipelined nature these applications process the data volume one record at a time. For example certain transformer operations may require information about subsequent records in the data volume. However this information may be unavailable until those subsequent records are processed by the transformer. For instance in a data volume containing multiple groups of records it can be inefficient to calculate each record s percentage contribution to the record s group because a user cannot determine if a particular record is the last record in a group without reading the subsequent record. As such users must currently use multiple operations in user programs in order to attempt to work around this deficiency.

Likewise some transformer operations may require information about previously processed records. For instance in an aggregation function a user may wish to calculate the sum of all the records in a particular group. However because data in such a pipeline is processed one record at a time users may be unable to look backwards to previously processed records. For example if a user wished to calculate the sum of all the records in a particular group users currently must use multiple operators in a user program in order to solve a simple aggregation problem. The result is additional complexity and ineffiencies both in the user program and in the transformation stage.

The present disclosure generally provides techniques for processing data in a pipelined processing system.

One embodiment of the invention provides a computer implemented method of processing data in a pipelined processing system. The method includes preprocessing a plurality of records including for each record of the plurality of records determining whether the record is a last record in a group and upon determining the record is the last record in the group setting a key break flag for the record wherein the key break flag designates the record as the last record in the group reading in a first stage of the pipelined processing system a first record from the plurality of records determining in a second stage of the pipelined processing system whether the key break flag has been set for the first record indicating that the first record is the last record in the group and upon determining that the key break flag is set performing in the second stage of the pipelined processing system a transformation operation on the first record to create a transformed record.

Another embodiment of the invention provides a computer readable storage medium containing a program which when executed performs an operation. The operation includes preprocessing a plurality of records including for each record of the plurality of records determining whether the record is a last record in a group and upon determining the record is the last record in the group setting a key break flag for the record wherein the key break flag designates the record as the last record in the group. The operation further includes reading in a first stage of the pipelined processing system a first record from the plurality of records. Additionally the operation includes determining in a second stage of the pipelined processing system whether the key break flag has been set for the first record indicating that the first record is the last record in the group and upon determining that the key break flag is set performing in the second stage of the pipelined processing system a transformation operation on the first record to create a transformed record.

Yet another embodiment of the invention provides a system including a computer processor and a memory containing a program that when executed on the computer processor is configured to perform an operation for processing data in a pipelined processing system. The operation includes preprocessing a plurality of records comprising for each record of the plurality of records determining whether the record is a last record in a group and upon determining the record is the last record in the group setting a key break flag for the record wherein the key break flag designates the record as the last record in the group. The operation further includes reading in a first stage of the pipelined processing system a first record from the plurality of records. Additionally the operation includes determining in a second stage of the pipelined processing system whether the key break flag has been set for the first record indicating that the first record is the last record in the group and upon determining that the key break flag is set performing in the second stage of the pipelined processing system a transformation operation on the first record to create a transformed record.

As data volumes increase in size it becomes an increasingly difficult and time intensive task to manage and process the data. Furthermore although pipelined data processing systems such as the DataStage software application allow for data to be processed in parallel there are inefficiencies that result from this pipelined approach. These inefficiencies are particularly apparent when performing operations involving groups of data in a data volume. For instance a user cannot currently determine whether a record is the last record in its group without reading the next record in the data volume. That is if the subsequent record is in a different group the user may determine the current record is the last record in its group. In such a scenario it would be beneficial if users could look ahead at subsequent records to determine if the current record is the last record in its group. Furthermore without the ability to look backwards at previously processed records users must use multiple operations in order to perform aggregation operations such as calculating the sum of all the records in a group. Thus the result is both user programs and the transformer stage in general are inefficient. Embodiments of the invention allow users to effectively look both ahead at subsequent records and behind at previously processed records. This requires fewer operations to perform certain tasks such as aggregation operations and results in simpler and more efficient user programs and calculations.

In one embodiment a preprocessing component reads a first record and a second record from the data volume. Once the records have been read the preprocessing component may determine whether the first record and second record belong to the same group. If the first record and second record are not in the same group the preprocessing component may set a key break flag for the first record indicating that the first record is the last record in its group. A processing component may then process the first record and allow users to query the key break flag thus providing the user a mechanism to determine whether the first record is the last record in its group. Furthermore the processing agent may allow users to store the first record in an aggregation structure such that the first record may be retrieved from the aggregation structure when processing subsequent records.

In the following reference is made to embodiments of the invention. However it should be understood that the invention is not limited to specific described embodiments. Instead any combination of the following features and elements whether related to different embodiments or not is contemplated to implement and practice the invention. Furthermore although embodiments of the invention may achieve advantages over other possible solutions and or over the prior art whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus the following aspects features embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim s . Likewise reference to the invention shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim s .

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring now to this figure is a block diagram of components of a computer system configured to run a data processing program according to one embodiment of the present invention. As shown computer system includes computer processor s storage media one or more I O devices and system memory . Computer processor may be any processor capable of performing the functions described herein. I O devices may represent a variety of input and output devices including keyboards mice visual displays printers and so on. Furthermore as will be understood by one of ordinary skill in the art any computer system capable of performing the functions described herein may be used.

In the pictured embodiment memory contains an operating system and data volumes . The memory may include one or more memory devices having blocks of memory associated with physical addresses such as random access memory RAM read only memory ROM flash memory or other types of volatile and or non volatile memory. The operating system may be any operating system capable of performing the functions described herein. As shown memory also contains a plurality of data volumes . Data volumes may be any file file server database web application or data stream that contains or produces data. An individual data volume may include a plurality of records with each record containing one or more data values. Furthermore the records of a data volume may be organized into one or more groups. Data volumes are discussed in more detail in .

Memory also contains a parallel data processing program . In one embodiment of the invention parallel data processing program is an instance of the DataStage software application. Of course the data processing program may represent any computer program capable of performing the data processing functions described herein. The parallel data processing program may read and process the data volumes in a pipelined manner. In other words the data processing program uses a plurality of different stages working in parallel with each stage processing one record at a time and then passing the record to the next stage in the pipeline. In addition at least one of these stages may perform operations on the records according to a user program. For example a user program may contain operations to double every value in a data volume. When executing such a user program the data processing program may read in each record in the data volume in a first stage double the value contained in the record in a second stage and output the doubled values to a target data volume in a third stage .

Although using multiple stages to process records in parallel may improve the performance of data processing program there are several drawbacks to this method. Due to the pipelined nature of this method records are processed one at a time. One obstacle when processing a data volume one record at a time is that when processing a current record some operations may require information about subsequent records to determine how to process the current record. For example some operations may involve calculations on groups of data but the pipelined approach does not determine whether a particular record is the last record in its group without looking at subsequent records. As such users are forced to use multiple operations to account for this deficiency resulting in inefficient user programs. In one embodiment data processing program may preprocess a particular data volume prior to processing the data volume . For example in a data volume containing records organized into groups a preprocessing component of the data processing program may set a key break flag for each record that is the last record in its group. The data processing program may provide an Application Programming Interface API that allows user programs to query the key break flag. As such user programs may simply query the key break flag to determine if a particular record is the last record in its group thus resulting in more efficient user programs.

Furthermore when processing a current record in a data volume some operations may require information regarding previously processed records. For example a user may wish to calculate the sum of all records in a data volume that contain a data quality value greater than a quality threshold value. However when processing a particular record in data volume a user cannot look back at and calculate the sum of previously processed records whose data quality value exceeded the quality threshold value. As such user programs require multiple operations to look back at previously processed records. In one embodiment data processing program may contain an aggregation structure for storing records. For instance continuing with the above example a user may add each record whose data quality value exceeds the quality threshold value to the aggregation structure. When the user program finishes processing all the records in the data volume the user program may calculate the sum of the records contained in the aggregation structure thus resulting in a more efficient user program.

The transformer may perform various operations on the data read from the data source with these operations including but not limited to data type conversion string manipulation and arithmetic operation. The operations performed by the transformer may be specified by a user program. The user program may contain code representing transformation logic and the transformer may execute this user program against the input data read from the data source to produce output data. The output data may subsequently be written to the data target . In one embodiment the transformer includes a preprocessing component and a processing component . The preprocessing component may process records from the data source before the processing component processes the records. In one embodiment the preprocessing component processes every record in the data source before the processing component begins processing the first record in the data source . In an alternate embodiment the preprocessing component always stays a fixed number of records ahead of the processing component . For example the preprocessing component may work a single record ahead of the processing component and set a flag for records that are the last record in their respective groups. The processing component may then query the flag when processing each record and determine whether the record is the last record in its group based on the status of the flag.

As discussed above one limitation to processing a single record at a time is that a user cannot determine if a given record is the last record in its group without looking ahead at the next record in the data volume . For example if the transformer is currently processing record the transformer may determine that the record is in group . However the transformer cannot determine whether record is the last record in its group until the transformer processes the next record and determines that record is in group . Because the transformer processes only a single record at a time the transformer may not process the next record until after it has finished processing the current record. Therefore it would be advantageous if the transformer had a mechanism through which it could look ahead at subsequent record.

The above example follows a single record through each stage of . However when processing multiple records each stage of the pipeline will be processing a different record in parallel. For example in processing the data volume shown in record would first be read from the source data volume at stage . In the second iteration record is passed to the transformer stage and while transformation operations are being performed on the record record is read from the source data volume at stage . In the third iteration once record has been transformed the transformed record is passed to the data target stage to be written to a target data volume. While the transformed record is written transformation operations are being performed on record by the transformer stage and record are being read from the data source by the data source stage . Thus all stages of the data processing program are operating in parallel with each stage operating on a different record from the source data volume .

If the preprocessing component determines the current record and next record belong to the same group step or after the key break flag has been set step the preprocessing component then determines whether there are more records in the data volume to process step . If the preprocessing component determines there are more records to process the method begins again at step with the preprocessing component reading the following record in the data volume. Note that the current record step on the second iteration through the method will be the same record as the next record step from the first iteration through the method. For example using the data volume shown in for the first iteration through the method the current record may be record and the next record may be record . On the second iteration through the method the current record may be and the next record may be record and so on. If there are no more records to process at step the method ends.

If the processing component determines the key break flag is set for the record step the processing component calculates the sum of all records stored in the aggregation structure step . In other words the processing component determines that the record is the last record in its group because its key break flag is set. Furthermore since the aggregation structure now contains all the records from the group the processing component may begin calculating the percentage contribution to the group for each record with the first step of this calculation being calculating the sum of all the records in the group. Once the sum of all the records has been calculated the processing component then begins a loop step and for each record in the aggregation structure calculates the percentages contribution to the group for the record step . For example for a given record whose value is 10 and assuming the sum of all records in the group was determined to be 100 step the processing component would then calculate 10 100 and determine the percentage contribution for the record to be 0.1 or 10 . The calculated percentage value may then be written to a target data volume by the data target component and or may be displayed to the user using I O devices .

Once the percentage contribution for each record in the group has been calculated step the data source component then determines whether there are more groups of records in the data volume to process step . If there are more groups of records to process the method begins again at step where the data source component reads in the next record. If the data source component determines there are no more records in the data volume to process step the method ends.

Once the record has been stored in the aggregation structure the processing component determines whether a key break flag is set for the record at step . Alternatively if the processing component determines the record is not a member of either group A or group B step or if it determines the quality value for the record is less than or equal to the quality threshold value step then the processing component determines whether the key break flag is set for the record step . If the processing component determines the key break flag is not set for the record step the method begins again with the data source component reading in the next record step . That is if the key break flag is not set the processing component may determine the record is not the last record in its group and thus there are other records in the group that have not been read yet.

However if the processing component determines the key break flag is set step this indicates that the record is the last record in its group. As such the processing component then determines whether all records from both group A and group B have been read step . For example if the key break flag is set for the current record and if the current record is a member of group B then processing component may determine that all records from group B have been read. Similarly if the processing component has previously processed a record from group A where the key break flag was set for that record then the processing component may determine that all records from both group A and group B have been processed step . If the processing component determines there are more records from group A and group B to read step the method begins again with the data source component reading the next record at step .

If the processing component determines all records from both group A and group B have been read the processing component calculates the sum of all records stored in the aggregation structure step . The processing component then iterates through each record stored in the aggregation structure step and for each record calculates the percentage contribution to the set of all records stored in the aggregation structure for that record step . In other words the processing component calculates the percentage contribution for each record in the set of records from either group A or group B whose quality values exceed the threshold value. Once the percentage contribution has been calculated for each record step the method ends.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

