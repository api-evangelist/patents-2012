---

title: Automatic documentation generator
abstract: The subject matter disclosed herein provides methods and apparatus, including computer program products, for generating a list of object descriptions based on an object's relevance for documentation. In one aspect there is provided a method that may include accepting a setting for a filter and a setting for a flag of an object. The filter setting may represent a type of information to be included in a list of object descriptions. The flag setting may represent a category of documentation relevance for the object that may be stored in a repository. The method may include comparing the filter setting with the flag setting of the object, extracting the description of the object from the repository based on the comparing of the flag setting with the filter setting, and generating the list of object descriptions that includes a description of the object. Related systems, apparatus, methods, and/or articles are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09069646&OS=09069646&RS=09069646
owner: SAP SE
number: 09069646
owner_city: Walldorf
owner_country: DE
publication_date: 20121217
---
This disclosure relates generally to data processing and more particularly to the automatic generation of software documentation.

Software documentation facilitates the use and operation of a software product and is an integral component to software development. Software documentation provides various types of information including for example descriptions of the capabilities of a system technical documentation for blocks of code algorithms and application programming interfaces APIs and manuals for end users system administrators and support staff. Because software documentation provides information for the operation of a software product documentation should be updated throughout the development life cycle.

Despite the need to keep software documentation current and comprehensive documentation is generally provided at a very late stage of development. In many instances documentation is manually generated by knowledge managers with the help of people involved in the development process. Waiting until the end of the development cycle to provide software documentation presents grave risks including for example the high likelihood that implementation details for the software product may be forgotten over time. These gaps in knowledge can adversely impact many people including an end user s ability to properly use a software product a technical partner s ability to customize and or enhance a software product as well as a software company s ability to troubleshoot products and answer requests for information RFIs for their products.

In some implementations methods and apparatus including computer program products are provided for generating a list of object description based on an object s relevance for documentation.

In some implementations there is provided a non transitory computer readable medium. The non transitory computer readable medium may contain instructions to configure a processor to perform operations. These operations may include accepting a setting for a filter. The filter setting may represent a type of information to be included in a list of object descriptions. These operations may also include accepting a setting for a flag of an object. The flag setting may represent a category of documentation relevance for the object. In some implementations the object may be stored in a repository. These operations may also include comparing the filter setting with the flag setting of the object extracting a description of the object from the repository based on the comparing of the flag setting with the filter setting and generating the list of object descriptions. In some implementations the list may include a description of the object.

The above methods apparatus and computer program products may in some implementations further include one or more of the following features.

In some implementations software documentation may be generated from the list of object descriptions. In some implementations the type of information to be included in the list of object descriptions and the category of documentation relevance for the object may be selected from the group consisting of an end user documentation and a technical partner documentation.

In some implementations the operations may further comprise updating the list of object descriptions when a change event a create event or a delete event is detected. In some implementations the change event may be triggered when the object is changed. In some implementations the create event may be triggered when a new object is added to the repository. In some implementations the delete event may be triggered when the object is deleted from the repository.

In still other implementations the operations may further comprise generating a report of the objects in the repository using the list of object descriptions. The report may include statistics associated with the objects.

With regard to the accepting of the setting for the filter in some implementations the accepting may include receiving a user entered selection for the filter setting. With regard to the accepting of the setting for the flag in some implementations the accepting may include receiving a user entered selection for the flag setting from a plurality of flags.

With regard to the comparing of the filter setting with the flag setting of the object in some implementations the comparing may include determining whether the flag setting of the object is the same as the filter setting.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive. Further features and or variations may be provided in addition to those set forth herein. For example the implementations described herein may be directed to various combinations and subcombinations of the disclosed features and or combinations and subcombinations of several further features disclosed below in the detailed description.

Software documentation is essential to understanding how a software product works. In many development settings software documentation is provided at a very late stage of development. Postponing the documentation process risks the loss of implementation details of a software product. The automatic documentation generator disclosed herein resolves this problem by automatically generating and continuously updating a functions and features list of the various modules and entities in a software product in parallel with the software development process. Knowledge managers may polish the raw documentation provided by the functions and features list to generate software documentation for an end user or technical software implementation partner.

Introducing software documentation towards the end of the development lifecycle at may present many risks. Implementation details including for example what a particular function does or why a particular object class was created or modified may be forgotten at this late stage. Generating software documentation earlier in design process can prevent or reduce the risk that this knowledge is lost. The automatic documentation generator disclosed herein may facilitate this process by generating documentation in parallel with coding process .

Generating source code involves the translation of user requirements into a set of computer instructions that are written using a computer programming language. During coding a programmer may subdivide a software product into various modules. These modules can include different applications development packages classes and methods. Each module can in turn be subdivided into different entities that are used by the encapsulating module. The hierarchy of these data structures can be defined using structural metadata that can be stored in a repository.

For example a supplier relationship management SRM system may include various modules that execute different tasks. One of these modules may correspond to a supplier invoice application. The supplier invoice application may in turn be associated with various entities such as reports forms and business objects used by the application. Structural metadata may define the various fields in the supplier invoice application and its encapsulated entities. Programmers can use this metadata to generate empty containers of these objects. These containers can later be filled with code to define the properties and functions associated with the object.

For sophisticated business software products hundreds if not thousands of software modules and entities may be created from structural metadata. In order to keep track of these objects programmers may include documentation with their code to describe the object s functions and features. This documentation may be stored in a metadata repository and later extracted to form a functions and features list.

Although displays a description for ORDER action descriptions for other objects may be inserted as well. These descriptions may form a collection of implementation details that describe for example what a particular action does or the type of information that may be stored in the fields of an object. These descriptions may form the basis of a functions and features list.

A functions and features list may be generated by extracting the descriptions of the modules and entities stored in the window illustrated in or directly from the source code. However not all objects are relevant for documentation for all users. For example an end user may not be interested in understanding how a particular action is implemented in code so long as the action performs correctly. In this case the end user may want a high level description of the action but may be uninterested in understanding any of the underlying technical minutiae. A technical partner on the other hand may need to understand these details in order to customize the action for use in a separate application. In this case the technical partner may need detailed information about how the action is implemented and the data structure of any objects associated with the action. In order to customize the amount of detail that is shown in the functions and features list modules and entities may be flagged either for end user documentation or technical documentation. Other types of flags may be used including for example a flag that indicates that a particular object is always relevant for documentation regardless of the user a conditional flag that indicates that a particular object is relevant for documentation only when another object is also flagged a flag that indicates that technical documentation for an object may be used as an initial draft for end user documentation if end user documentation is not available a flag that indicates that end user documentation for an object may be used as an initial draft for technical documentation if technical documentation is not available and the like.

Any individual involved in the development process including for example a programmer a product manager or an input developer may set the flags for documentation relevance for an entity or module. This may be done by adjusting the properties associated with the object. Object properties may include for example the name of the object who created the object and when the object was last changed. One or more flags for documentation relevance may also be included in an object s property settings. An object s properties may be viewed and or modified by clicking any of the objects displayed in .

For example if a user clicks on ORDER action in pop up window illustrated in may prompt the developer to manually set one or more document relevance flags for the action by selecting one or more of flags and . Although pop up window only displays three flags any number of flags may be used. A developer may select one or more of these flags for the object by clicking on a box adjacent to the object. Doing so may fill the box with a checkmark to indicate that the flag has been selected. If the object is not relevant for documentation purposes then none of the boxes may have checkmarks. In this latter scenario the object may not be relevant for documentation purposes and its description may not be included in the functions and features list.

While pop up window provides a manual means for selecting an object s flag an object may also automatically inherit flag settings from a parent object. For example in if a developer selects a flag for POITEM then child objects e.g. node elements associations and typing data type may inherit the same flag. A developer may override the inherited flag setting by manually selecting a different flag for the child object using pop up window .

This method may begin at by determining whether a repository filter has been selected. The repository filter may represent the type of information to be included in the functions and features list and may correspond to the information in any of the flags described above. For example if a user wants to generate end user documentation from the functions and features list then the user may select an end user documentation setting for the repository filter. If no filter is selected then the method may end at .

If however a repository filter is selected then processing may proceed to . At the automatic documentation generator may compare the object s flag to the repository filter. If the repository filter matches the object s flag then the automatic documentation generator may display the object and extract the object s description at . The automatic documentation generator may write both the object name and the corresponding description to the functions and features list. Depending on its location the description may be extracted either from the repository illustrated in directly from the source code or from both the repository and the source code. In order to facilitate the extraction process descriptions that are stored in the repository may be identified as documentation entities using a designated suffix. Similarly comments stored in the source code may be identified as documentation entities using a designated escape sequence. The escape sequence used may change depending on the programming language. Upon finding either the suffix or escape sequence the automatic documentation generator may extract the associated description and or comment.

At the automatic documentation generator may determine whether there are any objects that have not been processed in accordance with method . This determination may be made by comparing a timestamp associated with the documentation entity with a timestamp associated with the corresponding object. The documentation entity s timestamp may indicate when the entity s description and or comment was last extracted. The object s timestamp may indicate when the object was last updated. If these timestamps do not match then the object may not have been processed. The automatic documentation generator may select the next unprocessed object at and processing may return to . If however all objects have been processed then the method may end at .

Using method the automatic documentation generator may generate a functions and features list for all objects that have been flagged for documentation. illustrates a resulting functions and features list . This list has multiple columns each column representing a different level of an application. It is noted that the number of columns in list and the column headings may change depending on the object hierarchy. For example if the object hierarchy is divided into applications application areas packages and entities then list may have four object headings and one description heading. Although functions and features list is illustrated as a table other presentation formats may be used including for example a text document.

With regard to list the left most column may be reserved for subareas . Although list displays only one subarea procurement strategy other subareas may be included. Each subarea may be associated with one or more business topics global spend analysis make or buy decision support etc. . Each business topic may be associated with one or more sub processes or functions . Column may provide a description of the items in the preceding columns. This description may be extracted from the repository illustrated in or directly from the source code. In list for example the description for make or buy decision support describes whether services should be provided in house or externally bought.

Descriptions are generally written by programmers during the coding process. However these descriptions may be entered by any person and at any point during the software design process including for example the early stages of software design when user requirements are defined or during post deployment maintenance of the software product. These descriptions may be entered so long as the software entity being described is already available in the development system. Oftentimes these descriptions may be written in pseudo code and may not be easy to understand. A knowledge manager may polish the descriptions from the functions and features list into documentation that may be released to end users and or technical partners.

In order to ensure that the functions and features list is current the automatic documentation generator may be configured to automatically detect whether any new software modules or entities have been added to the repository or whether any of the modules or entities stored in the repository have been changed or deleted. As described earlier each object may be associated with a flag that indicates whether the object is relevant for documentation. This flag may be coupled to an event that indicates whether an object is being added deleted or modified. For example when a programmer creates a new software entity and sets its flag a CREATE event may be triggered that indicates that a new object has been added to the repository. Similarly a DELETE event may be triggered when an object has been deleted and a CHANGE event may be triggered when an object has been modified. The automatic documentation generator may be configured to periodically check for the presence of events as part of a background job or at pre designated time intervals. Upon detecting an event the automatic documentation generator may generate an updated version of the functions and features list using method .

The automatic documentation generator may generate a variety of reports using the information in previously generated functions and features lists. These reports may track for example the number of software modules in a program or the number of software entities per software module by counting the number of modules and entities in a functions and features list. illustrates a sample report that shows the number of entities in different modules. These numbers may be compared across several functions and features lists to show how these values shift during different stages of development or between releases and to ensure homogeneous documentation for all entities in the software product. The information provided by these reports may be used to enforce proper documentation standards in all areas and by all contributors.

At a setting for a filter may be accepted. The filter setting may represent a type of information to be included in a list of object descriptions. For example if a user wants to generate end user documentation using the list then the user may select an end user documentation setting for the filter setting. The user s selection may be received by the automatic documentation generator.

At a setting for a flag of an object may be accepted. The flag setting may represent a category of documentation relevance for an object stored in a repository. In some implementations accepting the flag setting may include receiving a user entered selection for a flag. This flag may be selected for example from the set of document relevance flags illustrated in . Alternatively the user may decide not to select a flag.

At the filter setting may be compared with the flag setting of the object. As described in at this comparison may include determining whether the filter setting is the same as the flag setting of the object.

At a description of the object may be extracted from the repository based on the comparing of the flag setting with the filter setting. In some implementations the description may be extracted from the repository illustrated in . In still other implementations this description may be extracted from the source code.

At a list of object descriptions may be generated. The generated list may include a description of the object and may be presented in any format including for example as list illustrated in .

One or more aspects or features of the subject matter described herein can be realized in digital electronic circuitry integrated circuitry specially designed application specific integrated circuits ASICs field programmable gate arrays FPGAs computer hardware firmware software and or combinations thereof. These various aspects or features can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which can be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device. The programmable system or computing system may include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

These computer programs which can also be referred to as programs software software applications applications components or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the term machine readable medium refers to any computer program product apparatus and or device such as for example magnetic discs optical disks memory and Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The machine readable medium can store such machine instructions non transitorily such as for example as would a non transient solid state memory or a magnetic hard drive or any equivalent storage medium. The machine readable medium can alternatively or additionally store such machine instructions in a transient manner such as for example as would a processor cache or other random access memory associated with one or more physical processor cores.

To provide for interaction with a user one or more aspects or features of the subject matter described herein can be implemented on a computer having a display device such as for example a cathode ray tube CRT or a liquid crystal display LCD or a light emitting diode LED monitor for displaying information to the user and a keyboard and a pointing device such as for example a mouse or a trackball by which the user may provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well. For example feedback provided to the user can be any form of sensory feedback such as for example visual feedback auditory feedback or tactile feedback and input from the user may be received in any form including but not limited to acoustic speech or tactile input. Other possible input devices include but are not limited to touch screens or other touch sensitive devices such as single or multi point resistive or capacitive trackpads voice recognition hardware and software optical scanners optical pointers digital image capture devices and associated interpretation software and the like.

The subject matter described herein can be embodied in systems apparatus methods and or articles depending on the desired configuration. The implementations set forth in the foregoing description do not represent all implementations consistent with the subject matter described herein. Instead they are merely some examples consistent with aspects related to the described subject matter. Although a few variations have been described in detail above other modifications or additions are possible. In particular further features and or variations can be provided in addition to those set forth herein. For example the implementations described above can be directed to various combinations and subcombinations of the disclosed features and or combinations and subcombinations of several further features disclosed above. In addition the logic flows depicted in the accompanying figures and or described herein do not necessarily require the particular order shown or sequential order to achieve desirable results.

