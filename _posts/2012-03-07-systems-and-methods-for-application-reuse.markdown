---

title: Systems and methods for application reuse
abstract: System and methods are provided. In one embodiment, a system includes a master data archiver configured to store a data related to a turbomachine system and a first data collector service system configured to collect the data from the master data archiver. The system also includes a second data collector service system communicatively coupled to the first data collector service system and configured to pull or to push the data from the first data collector service system and a first data archiver configured to receive at least some of the data from the second data collector service system. The system further includes an asset model database storing a plurality of turbomachine tags, wherein the turbomachine tags are configured to categorize the data and a data access system (DAS) configured to provide data access to the first data archiver, the asset model database, or a combination thereof.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047292&OS=09047292&RS=09047292
owner: General Electric Company
number: 09047292
owner_city: Schenectady
owner_country: US
publication_date: 20120307
---
The subject matter disclosed herein relates to reuse of systems and more specifically the reuse of software systems.

Certain systems such as an industrial control system may provide for capabilities that enable the control and analysis of the industrial control system. For example the industrial control system may include controllers field devices and sensors storing data for subsequent analysis. Software systems may be used to store and analyze the data. It would be beneficial to improve reuse of the software systems.

Certain embodiments commensurate in scope with the originally claimed invention are summarized below. These embodiments are not intended to limit the scope of the claimed invention but rather these embodiments are intended only to provide a brief summary of possible forms of the invention. Indeed the invention may encompass a variety of forms that may be similar to or different from the embodiments set forth below.

In a first embodiment a system includes a master data archiver configured to store a data related to a turbomachine system and a first data collector service system configured to collect the data from the master data archiver. The system also includes a second data collector service system communicatively coupled to the first data collector service system and configured to pull or to push the data from the first data collector service system and a first data archiver configured to receive at least some of the data from the second data collector service system. The system further includes an asset model database storing a plurality of turbomachine tags wherein the turbomachine tags are configured to categorize the data and a data access system DAS configured to provide data access to the first data archiver the asset model database or a combination thereof. The system additionally includes an application programming interface API comprising a write once compile anywhere WOCA object oriented language and configured to provide a communicative interface to at least one of the DAS the first data archiver or the asset model database and an API wrapper configured to use the API to communicate with a write once run anywhere WORA client application and at least one of the DAS the first data archiver or the asset model database.

In a second embodiment a method includes storing a data related to a turbomachine system in a master data archiver and collecting the data from the master data archiver using a first data collector service system. The method also includes pushing or pulling the data from the first data collector service system to a second data collector service system and storing at least some of the data from the second data collector service system in a first data archiver. The method further includes storing a plurality of turbomachine tags in an asset model database wherein the turbomachine tags are configured to categorize the data and providing data access to the first data archiver the asset model database or a combination thereof by using a data access system DAS . The method additionally includes communicating with the DAS the first data archiver the asset model database or a combination thereof by using an application programming interface API comprising a write once compile anywhere WOCA object oriented language and providing an API wrapper configured to use the API to communicate with a write once run anywhere WORA client application and at least one of the DAS the first data archiver or the asset model database.

In a third embodiment a non transitory tangible computer readable medium includes executable code. The code includes instructions for storing a data related to a turbomachine system in a master data archiver and collecting the data from the master data archiver using a first data collector service system. The code also includes instructions for pushing or pulling the data from the first data collector service system to a second data collector service system and storing at least some of the data from the second data collector service system in a first data archiver. The code further includes instructions for storing a plurality of turbomachine tags in an asset model database wherein the turbomachine tags are configured to categorize the data and providing data access to the first data archiver the asset model database or a combination thereof by using a data access system DAS . The code additionally includes instructions for communicating with the DAS the first data archiver the asset model database or a combination thereof by using an application programming interface API comprising a write once compile anywhere WOCA object oriented language and providing an API wrapper configured to use the API to communicate with a write once run anywhere WORA client application and at least one of the DAS the first data archiver or the asset model database.

One or more specific embodiments of the present invention will be described below. In an effort to provide a concise description of these embodiments all features of an actual implementation may not be described in the specification. It should be appreciated that in the development of any such actual implementation as in any engineering or design project numerous implementation specific decisions must be made to achieve the developers specific goals such as compliance with system related and business related constraints which may vary from one implementation to another. Moreover it should be appreciated that such a development effort might be complex and time consuming but would nevertheless be a routine undertaking of design fabrication and manufacture for those of ordinary skill having the benefit of this disclosure.

When introducing elements of various embodiments of the present invention the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

Industrial automation systems may include controller systems suitable for interfacing with a variety of field devices such as sensors pumps valves and the like. For example sensors may provide inputs to the controller system and the controller system may then derive certain actions in response to the inputs such as actuating the valves driving the pumps and so on. In certain controller systems such as the Mark VIe controller system available from General Electric Co. of Schenectady N.Y. data from components of the industrial automation system may be stored in a database system for subsequent analysis and processing. For example temperature pressure flow rate clearance e.g. distance between two components and vibration data of turbomachinery e.g. gas turbine steam turbine compressor pump may be used to derive trends activate alarms and more generally to provide for indications of performance of the turbomachine.

In certain embodiments the industrial control system may include an application programming interface API including instructions written in a write once compile anywhere WOCA object oriented language such as C . The API may be used to communicatively interface with the database system. For example the API may include multiple C objects and functions suitable for connecting to the database system disconnecting from the database system as well as inserting updating and retrieving data from the database system. By using the API a client software written in C may more efficiently communicate with the database system. However because the API is coded in a WOCA object oriented language reuse in other object oriented languages such as a write once run anywhere WORA objected oriented language e.g. Java may be difficult. Accordingly the systems and methods disclosed herein improve reuse of previously written API code by providing for an API wrapper suitable for use in the WORA language. In one embodiment the API wrapper may include some or all of the functionality provided by the API and expose the functionality for reuse by client software written in the WORA language. Additional functionality may also be provided by the API wrapper for example to improve data access to the database system when using the WORA language. By using the API and the API wrapper client software written in multiple languages may more easily and efficiently communicate with the database system. Indeed multiple client software each written in a different language e.g. WORA language may reuse the API.

With the foregoing in mind it may be useful to describe an embodiment of an industrial control system incorporating techniques disclosed herein such as a gas turbine system illustrated in . As depicted the turbine system may include a combustor . The combustor may receive fuel that has been mixed with air for combustion in a chamber within combustor . This combustion creates hot pressurized exhaust gases. The combustor directs the exhaust gases through a turbine toward an exhaust outlet . The turbine may be part of a rotor. As the exhaust gases pass through the turbine the gases force turbine blades to rotate a drive shaft along an axis of the turbine system . As illustrated the drive shaft is connected to various components of the turbine system including a compressor .

The drive shaft may include one or more shafts that may be for example concentrically aligned. The drive shaft may include a shaft connecting the turbine to the compressor to form a rotor. The compressor may include blades coupled to the drive shaft . Thus rotation of turbine blades in the turbine causes the shaft connecting the turbine to the compressor to rotate blades within the compressor . This compresses air in the compressor . The rotation of blades in the compressor compresses air that is received via an air intake . The compressed air is fed to the combustor and mixed with fuel to allow for higher efficiency combustion. The shaft may also be connected to a load which may be a vehicle or a stationary load such as an electrical generator in a power plant or a propeller on an aircraft. When the load is an electrical generator the electrical generator may be coupled to a power grid for distribution of electric power to for example residential and commercial electricity users.

The turbine system may also include a plurality of sensors and field devices configured to monitor a plurality of engine parameters related to the operation and performance of the turbine system . The sensors and field devices may include for example inlet sensors and field devices and outlet sensors and field devices positioned adjacent to for example the inlet and outlet portions of the turbine and the compressor respectively. The inlet sensors and field devices and outlet sensors and field devices may measure for example environmental conditions such as ambient temperature and ambient pressure as well as a plurality of engine parameters related to the operation and performance of the turbine system such as exhaust gas temperature rotor speed engine temperature engine pressure gas temperature engine fuel flow exhaust flow vibration clearance between rotating and stationary components compressor discharge pressure pollution e.g. nitrogen oxides sulfur oxides carbon oxides and or particulate count and turbine exhaust pressure. Further the sensors and field devices and may also measure actuator information such as valve position and a geometry position of variable geometry components e.g. air inlet .

The plurality of sensors and field devices and may also be configured to monitor engine parameters related to various operational phases of the turbine system . Measurements taken by the plurality of sensors and field devices and may be transmitted via module lines and which may be communicatively coupled to a controller . The controller may use the measurements to actively control the turbine system . Further the controller and or the sensors and field devices and may store the measurements in a database system as described in more detail below with respect to . For example module line may be utilized to transmit measurements from the compressor while module line may be utilized to transmit measurements from the turbine . It is to be understood that other sensors may be used including combustor sensors exhaust sensors intake sensors and load sensors. Likewise any type of field devices may be used including smart field devices such as Fieldbus Foundation Profibus and or Hart field devices. It is also to be understood that the gas turbine system is only an example embodiment of turbomachinery and that other gas turbine systems may include for example multiple turbines multiple shafts and other arrangement of system components. Alternatively the turbomachine may not be a gas turbine system but may be a steam turbine a hydroturbine or a wind turbine.

As mentioned above the industrial control system may use a database system such as an embodiment of a database system having a data collection system and a data analysis system suitable for storing and analyzing turbomachine data as depicted in . In the depicted embodiment the data collection system receives data from the turbine system such as temperature pressure flow rate vibration and clearance data and provides the data to the data analysis system for further analysis. In one embodiment the data is collected through sensors and field devices and as mentioned above with respect to by using the controller . An open process control OPC system may then be used to communicatively couple with the controller and transmit data from the controller into a master data archiver . The master data archiver may include a database storage system. For example the master data archiver may include a relational database e.g. Oracle Microsoft SQL Server MySQL PostgreSQL a network database e.g. CODASYL TurboIMAGE a file a noSQL database e.g. BaseX Apache CouchDB SimpleDB or any other type of data storage.

The data gathered by the OPC system may include data captured at a variety of time frames or resolutions. For example the data may be captured at every millisecond every 500 milliseconds every second every 10 seconds every hour and or every day. Further the master data archiver may store data from any number of turbine systems . Indeed the master data archiver may be communicatively coupled to a plurality of turbine systems and be used as the data repository for the plurality of turbine systems . By aggregating data from one or more turbine systems the master data archiver may be used to analyze individual turbine systems as well as a fleet of turbine systems .

A first data collector service included in the data collection system may be communicatively coupled to a second data collector service included in the data analysis system to distribute data from the data collection system into the data analysis system . In one embodiment the data collector service may use a data push technique to move data from the data collection system into the data analysis system . For example the push technique may schedule a data transmission of the master data archiver data into the data analysis system at a scheduled time such as every millisecond every second every hour and or every day. In certain embodiments the data push technique may send the most recently updated data rather than the entire data set found in the master data archiver to more efficiently transmit the recently updated data. In other embodiments the data collector service may use a data pull technique to retrieve data from the master data archiver into the data analysis system . For example the data pull technique may schedule the creation of a computer executable process at certain times every millisecond every second every hour and or every day to retrieve data from the master data archiver into the data analysis system .

Regardless of the technique used e.g. push and or pull the data collector service may then allocate or otherwise partition the data and store the data in a data archiver referred to by element number a data archiver referred to by element number and or a data archiver N referred to by element number . The use of multiple data archivers enables a more scalable and robust data analysis system . Additional data archivers may be provided as data loads increase and various load balancing database algorithms may be used to more efficiently distribute queries and or data updates among the data archivers and .

In one embodiment each of the data archivers and may include a proper subset of data stored by the master data archiver . That is the entire master data archiver information may be reconstructed by combining the data stored in the data archiver and . In another embodiment each of the data archivers and may include a full set of the data stored by the master data archiver . An asset model database may also be included and used to categorize the data found in the data archiver and . In one example the categorization of the data provided by the asset model database may include the use of a tag data structure. The tag data structure may encapsulate raw measurement data captured by the sensors and field devices and and provide for metadata e.g. data about data and data content suitable for more efficiently retrieving inserting updating and analyzing the measurement data as described in more detail below with respect to . A data access system DAS may also be included in the data analysis system . The DAS may provide for efficient data access to the data archivers the asset model database or a combination thereof. For example the DAS may enable an insert an update or a delete of any of the data found in the data archivers and or the asset model database . The DAS may further include a central calculation engine CCE and a central calculation analytical process CCAP . By using the CCE and or CCAP the DAS may provide for a number of analytics from the data received from the master data archiver . For example the DAS may provide for trends in the operational performance of the turbine system .

In one example temperatures trends pressures trends flow rate trends vibration trends and or clearance trends may be provided by the DAS e.g. CCE CCAP . A rule trigger workflow may be communicatively coupled to the DAS to enable certain downstream processing. For example conditions or trends provided by the DAS may trigger certain alarms through the rule trigger workflow . A service oriented architecture SOA be communicatively coupled to the rule trigger workflow and provide for a loosely coupled or tightly coupled set of software services that enable a set of data access functionality. For example the SOA may include web based services suitable for informing the user of certain conditions or limits that may have been exceeded in the turbine system as well as providing web access to the analytics provided by the rule trigger workflow .

In the depicted embodiment an API is also provided. The API may be coded or written in a WOCA object oriented language such as C Objective C object oriented COBOL and the like. The API provides for objects and functions suitable for interfacing an object oriented client application with the DAS the data archivers and the asset data model . Indeed the API may expose all of the functionality provided by the DAS to reuse the code and functionality included in the DAS . That is the API may enable the object oriented WOCA client application to reuse the objects and functions included in the DAS . Indeed the API may be used as a programmatic interface to the DAS to provide some or all of the functionality provided by the DAS including the analytics provided by the CCE and or the CCAP . By reusing the API a control engineer or programmer may more efficiently and rapidly create the object oriented client application .

However other languages such as WORA languages e.g. Java and procedural languages such as PERL Ruby Python and Fortran may not be able to reuse the API because the API may not expose the appropriate programmatic structures suitable for use by languages other than the language used to write the API . For example the API may be included in a dynamic link library All and or a static library file .lib stored using a file format incompatible with the file format s used by an WORA language client . Additionally data structures designed in a first language e.g. WOCA language may be incompatible with data structures used in a second language e.g. WORA language . Further data types may also be incompatible. For example an integer data type may include a big Endian byte ordering i.e. the most significant byte is the first byte in the first language and a little Endian byte ordering in a second language i.e. the most significant byte is the last byte or vice versa.

The systems and methods described herein provide for a WORA language wrapper suitable for interfacing with the API with the WORA client application . For example the API wrapper may be included in a Java Native Interface JNI .dll and or .lib file having a file format compatible with usage by the WORA client application . Indeed by providing for the wrapper the systems and methods disclosed herein enable more efficient reuse of certain components of the database system including the data archivers the asset model the DAS the rule trigger workflow and the SOA .

In one embodiment a process may be used as further illustrated in to interface the client application with the API . The process may include code or computer instructions stored in a non transitory computer readable medium and executable in a computing device such as a workstation laptop server tablet or cell phone. In the depicted embodiment the WORA client application may issue a programmatic request block . For example the WORA client application may desire to connect to the database system shown in and subsequently request information insert information update information and or delete information stored in the database system . Programmatic requests from the WORA client application that involve the API may be processed by the API wrapper . That is because the API may not be suitable for direct communication with the WORA client application the WORA client application may communicate with the API wrapper and the API wrapper may then communicate with the API . Accordingly the API wrapper may process the request issued by the WORA client application and communicate the request to the API block . By providing for an interface to the API the API wrapper may enable the reuse of a subset or all of the API . The API may then process the request block . For example the API may read or write data stored by the database system including data stored in the data archivers the asset model database and data manipulated by the DAS rule trigger workflow and SOA .

Some client requests may result in data output. For example a read request may produce one or more operational measurements produced by the turbine system . The results of the request including any errors that may have occurred during processing may then be communicated block to the API wrapper by the API . The API wrapper may then process any results and communicate the results to the WORA client application block . For example data types may be converted from the WOCA data types e.g. C data types into the WORA language data type e.g. Java data types . In one embodiment type casting may be used to convert the data types. In this embodiment an explicit type cast computer instruction such as int result int API result may be used. It is to be understood that various data types may be similarly type casted including but not limited to int byte short long float double boolean string and char. Objects in the WORA language may also be translated into other structures usable by the client application . In this manner the client application may receive the results of the request in a desired format and data type and perform further processing. For example the results may include one or more tags as described below with respect to that may be used by the client application .

The API wrapper may then programmatically call an equivalent programmatic function and included in the API . In one embodiment the functions and may include computer code or instructions written in an objected oriented language e.g. C Eiffel Objective C Smalltalk . The API may then process the function call and or and interact with the data analysis system e.g. data archivers the asset model database and data manipulated by the DAS rule trigger workflow and SOA to service the requests and . For example the request may result in the API establishing a database connection block . The request may result in the API retrieving a current value block . The request may result in the API retrieving multiple tag raw data block . The request may result in the API retrieving interpolated data block . The request may result in the API writing data block . The request may result in the API ending the dataset connection block . The API wrapper may then process any results obtained through the API functions and and return any results to the client application . In this manner the client application may reuse the API . In one embodiment the programmatic functions and may be described using C style or JNI style terminology similar to Unix manual pages e.g. man pages presented below in the following six paragraphs.

Historian getIHUConnection function establishes a client connection to the data analysis system . More specifically the function attempts to connect to the data analysis system based on input parameters and returns a status and a server handle for the resulting connection. PARAMETERS input jstring jsusername The user name used to connect. jstring jspassword The password used to connect. jstring jsservername The machine or server name of the data analysis system to connect to. jlong jlmaxRetry The number of attempts to connect to the data analysis system . jlong jlminSleep The minimum sleep time in seconds used to calculate a wait time for retry attempts. This setting may be initially used to pause sleep for the first retry attempt. For subsequent retry attempts sleep duration may be set to previous sleep time random 0 to minSleep 1000 . jlong jlmaxSleep A maximum sleep time used to set maximum wait time between retry attempts. The setting may be used to pause or sleep during subsequent retry attempts if the calculated sleep time exceeds this maximum value. jint jiapiTimeout An amount of time to attempt to connect. RETURN output jclass connectException A code exception that is thrown or passed on when a connection status code is not found to be successful. jlong serverhandle A unique ID to assign the connection.

Historian ihuDisconnect function Disconnects the client from the data analysis system . More specifically the function attempts to disconnect the client from the data analysis system and returns a status of the disconnection. PARAMETERS input jlong serverhandle The server handle denoting a specific data analysis system to disconnect. RETURN output jclass connectException The code exception that is thrown or passed on when a disconnection status code is not found to be successful.

Historian writeIHUMultiTagData function Writes data to the data analysis system . More specifically the function attempts to write and or overwrite data into the data analysis system based on an input array of tags . PARAMETERS input jlong serverhandle The unique connection ID provided by the Historian getIHUConnection . jint numberOfSamples The number of samples to write. jobjectArray valueArray An array of values used to write into the data analysis system . RETURN output jclass ihWriteException an exception object that is thrown or passed when the read status code is not successful.

Historian getIHUMultiTagCurrentValue function Retrieves a range of data for multiple tags . More specifically the function attempts to read the value of multiple tags and returns arrays of sample size value timestamp and quality associated with the tags that may have been read. PARAMETERS input jlong jlserverhandle The unique connection ID provided by the Historian getIHUConnection function . jobjectArray tagNames An array of the plurality of tags to be read. jlong jlmaxRetry The maximum number of times to attempt to read the values. Double retValue a placeholder for the value of the tag to be read. Long utc a placeholder for a timestamp of the returned data set. Long retQuality A placeholder for the quality of the returned data set. RETURN output jobjectArray multiTagCurValArray a one dimensional array of DataSample e.g. Java class data structure containing a newest raw sample for each tag . jclass ihReadException an exception object that is thrown or passed when the read status code is not successful.

Historian getIHUMultiTagRawDataByTime function Retrieves a range of data for multiple tags . More specifically the function attempts to read the value of multiple tags over a range of time and returns arrays of sample size value timestamp and quality associated with the tags . PARAMETERS input jlong jlserverhandle The unique connection ID provided by the Historian getIHUConnection function . jlong tagNames An array of the plurality of tags to be read. jlong startTimeinSeconds The start time in seconds for retrieving values. jlong endTimeInSeconds The end time in seconds for retrieving values. Jlong maxRetry The maximum number of times to attempt to read the values. RETURN output jobjectArray multiTagRawResultArray a 2 dimensional array of DataSample e.g. java class data structure containing and array of raw data points for each tag. jclass ihReadException an exception object that is thrown or passed when the read status code is not successful.

Historian getIHUMultiTagInterpData function Retrieves a range of data for multiple tags on a specified interval. More specifically the function attempts to read the value of a plurality of tags over an interpolated range of time and then returns various arrays including arrays of sample size value timestamp and quality associated with the tags . PARAMETERS input jlong jlserverhandle The unique connection ID provided by the Historian getIHUConnection function . jobjectArray tagNames An array including the name of each of the plurality of tags to be read. jlong jstartTimeInSeconds The start time for retrieval of the values. Jlong jlendTimeInSeconds The end time for retrieval of the values. jlong jlinterval sec An interval e.g. seconds of the data to be read. jint percentGoodTH The percent good threshold used to determine qualitjint percentGoodTH The percent good threshold used to determine quality of the interpolated data point. jlong jImaxRetry The maximum number of times to attempt to read the values. RETURN output jobjectArray multiTagRawResultArray A 2 dimensional array of DataSample e.g. java class data structure containing the array of interpolated data points for each tag. jclass ihReadException an exception object that is thrown or passed when the read status code is not successful.

If the Try API call to the function encounters no processing exceptions then the process may check to determine if the function returned successfully and resulted in data e.g. samples greater than zero decision . If the function returned successfully and resulted in data e.g. samples greater than zero decision then data structure such as a sampleArray including a JNI type jobjectArray may be created block . Other JNI types may be used such as primitive types e.g. boolean byte char short in long float double void reference types e.g. jclass jstring jarray jthrowable field and method IDs e.g.  jfieldID  jmethodID and or value types e.g. jvalue as defined by the JNI specification version 1.0 and above. Advantageously the JNI type may be created by using one language e.g. C C and then mapped into a native data type used in a second language e.g. Java . For example an array of characters in C C may be created as a JNI jobjectArray and then mapped into a Java string. In the presently contemplated embodiment a custom dataSampleClass may be defined in Java. The sampleArray e.g. jobjectArray may then be mapped or translated into a dataSampleClass Java data structure through the use of a JNI function such as SetObjectArrayElement defined in the JNI specification version 1.0 and above.

Otherwise if the decision results in a no the process may increment the current retry value block and iterate to decision . The dataSampleClass may include a native Java data structures suitable for storing sample data from the turbine system . For example the dataSampleClass may include data structures used in storing values times and quality associated with one or more tags .

The process may then query the data type for each sample data returned by the function block . In certain embodiments the function may provide for a determination of the data types for the data being read e.g. int float double short long signed unsigned and or char . In one embodiment the process may data cast the values read by the process block . For example a C style static cast cast may be used to data cast values into integers. In this same manner float double short long signed unsigned and or char data types may be casted. Data casting may more efficiently and quickly convert the read values into an appropriate data type. In another embodiment the read value may be stored for example as a string e.g. an array of characters regardless of the originating data type. In this embodiment the string may then be converted to a desired data type for example by the WORA client application .

The values provided by the API and retrieved via the jobjectArray may then be converted or otherwise translated into native WORA data structures block for subsequent processing by the WORA client application . As mentioned above the JNI environment may provide one or more functions used to convert or otherwise translate the jobjectArray value such as the SetObjectArrayElement function and a NewObject function. The process may then perform the data cleanup block and subsequently exit the function circle . By providing an interface between the WORA client and the API the process may enable the reuse of functionality included in the API in a language e.g. WORA language different than originally intended.

The process may then compare a current retry value e.g. curRetry to a maximum retry value e.g. maxRetry decision . If the current retry value is greater than the maximum retry value then the process may perform a data cleanup block and exit the function circle . The data cleanup may for example initialize any error flags with values appropriate for informing of errors exceptions and the like. If the current retry value is less than or equal to the maximum retry value decision then the process may use a Try function call to call block an API function such as the API function ihuWriteData . In the depicted example the Try function call block has an equivalent Catch exception handler block . The Catch exception handler may take over processing if processing exceptions were to occur during execution of the Try function call block . For example the Catch exception handler block may clean up or release memory resources and then increment the current retry value block . The process may then iterate back to decision .

If the Try API call block to the API function encounters no exceptions then the process may check to determine if the write of the values was successful decision . If the write operation was successful decision then the process may perform the data cleanup block and exit the function circle . Otherwise the process may increment the current retry value block and iterate to decision . By providing for an interface suitable for writing data using the API the process may enable the WORA client application to write data into the data analysis system even though the API may be written using WOCA object oriented language features.

Technical effects of the invention include enabling the reuse of existing systems by providing for a wrapper suitable for interfacing between an application programming interface API written in a first WOCA object oriented language and a client application written in a second language such as a WORA object oriented language. The wrapper may provide for a mapping between data structures in the first language and data structures in the second language. The wrapper may also provide for data type conversion between data types in the first language and data types in the second language. A tag data structure may be used to enable a more efficient retrieval of turbomachinery measurement data. A data collection system and a data analysis system are also described which may reside in separate computing devices. The data collection system and the data analysis system may be communicatively coupled to each other enabling a load balancing of large data sets and a more efficient analysis of the turbomachinery data.

This written description uses examples to disclose the invention including the best mode and also to enable any person skilled in the art to practice the invention including making and using any devices or systems and performing any incorporated methods. The patentable scope of the invention is defined by the claims and may include other examples that occur to those skilled in the art. Such other examples are intended to be within the scope of the claims if they have structural elements that do not differ from the literal language of the claims or if they include equivalent structural elements with insubstantial differences from the literal language of the claims.

