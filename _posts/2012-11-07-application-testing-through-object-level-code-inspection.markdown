---

title: Application testing through object level code inspection
abstract: Testing of a service is enabled through extraction of object data from an application interacting with the service. An application is executed on a physical or emulated host device, and assembly code is generated for the executing application. The assembly code is analyzed to identify objects associated with the application, and to identify relationships between the objects. Data stored in member variables of the objects is retrieved by setting analysis points at which to extract member variable data during execution of the application. Based on the object data, relationship data, and retrieved member variable data, transaction data is identified for a transaction between the application and the service. The transaction data may be provided to enable a test device to replay the transaction during load testing or other testing of the service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09185039&OS=09185039&RS=09185039
owner: Google Inc.
number: 09185039
owner_city: Mountain View
owner_country: US
publication_date: 20121107
---
This application is a continuation of and claims priority to U.S. patent application Ser. No. 13 655 667 filed on Oct. 19 2012 entitled Application Auditing Through Object Level Code Inspection. The entirety of this previously filed application is hereby incorporated by reference.

With the growing popularity of mobile devices there is an increasing demand for applications or apps to run on such devices. Traditional testing of these apps has incompletely or inaccurately represented actual usage resulting in incomplete or erroneous testing of these apps.

Certain implementations and embodiments will now be described more fully below with reference to the accompanying figures in which various aspects are shown.

However various aspects may be implemented in many different forms and should not be construed as limited to the implementations set forth herein. Like numbers refer to like elements throughout.

This disclosure describes embodiments of systems methods and computer readable media to enable forensics validation testing and auditing of an application using object data for the application. An application may be installed on a host device and executed in conjunction with an assembly code generation module to generate assembly code data. Object data may then be extracted from the assembly code data the object data including a description of objects associated with the application and relationships between the objects. As used herein objects may describe static or dynamic program objects classes libraries data structures and objects instantiated or accessed during execution of an application. In some cases relationships between objects may be hierarchical evincing a parent child inheritance relationship.

The object data may be analyzed to identify potential security risks associated with executing the application on a device. Embodiments support auditing of any type of software application program module or process executing on or part of any type of operating system. For example applications may be audited which are configured for execution on mobile desktop laptop server or other devices and their corresponding operating systems.

As described herein auditing the application may include identifying one or more security risks associated with execution of the application. Identification of security risks may indicate that the application under audit includes features that may lead to data corruption data destruction data theft data leakage or data intrusion on the host device or on a networked device in communication with the host device.

For example auditing an application may include analyzing object data of the application to identify objects which perform communications with external devices or services while executing on the host device where such external devices or services are deemed untrustworthy based on their presence on a black list or their absence from a white list. Auditing may also include analyzing object data to identify objects which access data on the host device including data from the host device s phone book address book location information file system or other data on the host device. Auditing may also include analyzing object data to identify transfers of data from object s that accesses host device data to object s that communicate that data externally outside the host device. Security risks may be identified based on the external communications host device data access a combination of host device data access and external communication or other activities of the application being audited.

Object level analysis may be performed by identifying analysis points in member methods of objects associated with the application such that the assembly code generation module outputs contents of member variables of the objects while the application is executing. When the executing application reaches an analysis point set in a member method of an object the contents of one or more member variables of the object may then be extracted and analyzed to determine what data is being sent received or stored by the object or what data is being retrieved from the host device or communicated externally by the object. Based on the data being retrieved or communicated by the application embodiments may identify security risks associated with the application. In some embodiments data extraction and analysis and identification of security risks may be performed in real time during an execution of the application on the host device.

The audit server may remotely operate the host device to upload the application to the host device install the application on the host device and execute the application on the host device to identify security risks. The audit server may also remotely operate the host device to execute an assembly code generation module on the host device. In some embodiments the assembly code generation module generates assembly code data associated with the executing application. The assembly code data may include assembly code instructions assembly code descriptions of program objects associated with the application or both. In some embodiments the assembly code generation module is a debugger or includes functionality of a debugger to set breakpoints set analysis points extract or modify data stored in variables output assembly code for the application and so forth.

In some embodiments an audit module on the audit server builds an object level hierarchy for the application based on the assembly code generated by the assembly code generation module on the host device. In some cases the audit server may iteratively query the assembly code on the host device to determine parent child hierarchical relationships between various objects associated with the application. This hierarchical object data may then be employed to perform a security audit of the application.

In some embodiments a user may log in or otherwise be authenticated to an audit server. Through a user interface UI provided by the audit server the user may specify and upload an application for auditing and select a host device on which the application is to be audited. The selection of the host device may include selection of one or more of a particular device device type operating system or other attributes of the host device. The UI may further provide a report listing the security risks if any that have been identified through execution of the application on the host device. In addition to or instead of providing the report through the UI some embodiments may provide a report of the identified security risks in an email a transferred file or other through means. The report may be presented to the user on completion of the audit or stored for later access.

In some embodiments an instrumented version of the application may be created to enable further monitoring of the application for security risks. Additional assembly code may be injected into the application in those objects identified as performing actions that are security risks. Such additional assembly code may write log data to local storage on a device while the application is running. The log data may include the data which is accessed by the application on the host device or communicated by the application to another application or to an external device or service. The log data may periodically be transferred to the audit server or other device and analyzed to identify potential security risks. In some embodiments the original assembly code of the application may be modified to disable one or more application features associated with security risks. Following such modifications an instrumented version of the application may be compiled from the original assembly code the additional assembly code and the modified assembly code and provided to an end user in a binary executable format.

In some embodiments the extracted object data for an application may be employed to generate network traffic for load testing of services running on backend servers. For example the application under audit may be a client application communicating with a service running on a backend enterprise server such as a banking web site e commerce web site and so forth. The object data extracted during execution of the application may be analyzed to identify transactions sent to the backend server such as requests posts or other communications interacting with the service running on the backend server. Transactional data from such transactions may be captured and played back from one or more test servers to test the service running on the backend server. The load may be increased or decreased to test various load environments and the reply traffic may be analyzed and compared with a baseline of expected responses. In some cases the load generated from one or more test servers may be supplemented with traffic from the host device s .

In some embodiments the environment includes one or more client devices that are owned by operated by or otherwise associated with one or more users . The client devices may include any type of computing device that is able to communicate with other devices over a network including but not limited to desktop computers personal computers laptop computers tablet computers electronic book readers wearable computers implanted computers mobile phones thin clients terminals game consoles mobile gaming devices and the like. In some embodiments the client devices include one or more applications that provide a user interface to connect with a remotely hosted service. For example the client devices may run a web browser to enable the user s to view and interface with a web site.

Embodiments support the use of various web browsers including but not limited to Mozilla Firefox Microsoft Internet Explorer Google Chrome Apple Safari Rockmelt and other browsers. In some embodiments the user s may communicate with a remote service via some other type of application or through a dedicated client side application. The user s may include any individual person group of persons or automated process. For example the user s may include app developers software engineers other members of an application development organization and the like who may employ embodiments to validate an application during or after its development process.

In some embodiments the environment includes one or more server computing devices. Such servers may include any type of computing device including but not limited to network servers rack mounted servers workstations desktop computers laptop computers tablet computers mobile computing devices virtual servers cloud resources and the like. Further the servers shown may include one or more computing devices that operate in a cluster or other grouped configuration to share resources balance load increase performance provide fail over support or redundancy or for other purposes. The servers may also include one or more hardware modules and one or more software modules e.g. processes or applications to perform tasks as described herein.

As shown in the environment includes one or more audit servers . In embodiments the audit server s may receive e.g. from users one or more applications for audit . In some embodiments the audit server s run one or more software modules processes or applications that comprise an audit module . In some embodiments the audit module may provide a user interface that is accessible to the user s e.g. through a web browser executing on the client devices . The user interface may enable a user to send instructions and receive data associated with application validation and auditing operations. An example user interface for the application validation service is described with regard to .

The environment may also include one or more host devices available for performing application validation operations. Such host device s may include various types of computing devices operating systems software firmware and so forth. In some embodiments the host device s include mobile computing devices such as smartphones tablets electronic book eBook readers wearable computers automotive computers and the like. However embodiments are not so limited and embodiments may support any type of host device for application validation including but not limited to desktop computers laptop computers network computers server computers mainframe computers and so forth. In some embodiments the host device may be emulated in software. For example the host device may comprise a software emulator of the host device which is executed on the audit server or another server.

In embodiments the host device s may include one or more software modules such as an assembly code generation module . In some embodiments the audit module transmits or otherwise provides the application s for audit to the host device s to enable the application s to be validated and audited while executing on one or more of the host device s . In some embodiments the application s for audit may be provided to the host device s from a computing device other than the audit server s or from an online app store. The application s for audit may be executed on the host device s and the assembly code generation module may produce assembly code associated with the executing applications. In some embodiments the assembly code generation module may be a debugger such as the GNU debugger gdb or may include at least a portion of the functionality of a debugger. However embodiments are not so limited and any type of the assembly code generation module may be employed to generate the assembly code data for an application or verify that a compiled application is suitable for the hardware configuration of the host device on which it is to execute. In some embodiments the application s for audit include application s in binary or executable form and may not include source code for the application s . In some embodiments the application s for audit may be received in a compressed or archived format such as an IPA or ZIP file.

In some embodiments the assembly code generation module generates the assembly code data associated with the application s for audit while such applications are executing on the host device s . The assembly code data may be transferred to the audit module which may then use the assembly code data to generate object data associated with the application s for audit . In some embodiments the object data may indicate a hierarchical association between the plurality of objects based on one or more determined parent child relationships between the objects. Such object level hierarchy data may be generated as described in U.S. patent application Ser. No. 13 631 919 filed on Sep. 29 2012 titled Application Validation Through Object Level Hierarchy Analysis which is incorporated by reference into this disclosure.

In some embodiments the audit module may perform any number of requests for portions of the assembly code data . The audit module may then analyze address data for objects listed in the assembly code data to determine relationships calls or data transfers between the objects. As used herein address data describes addresses for locations in virtual memory on the device where the application for audit is executing. Address data may also describe addresses for locations in active memory or program memory on a device. The generated object data may be stored on the audit server s or on a data storage device or other computing device external to and in communication with the audit server s . For example the object data may be provided to the client device for further analysis.

In some embodiments the object data is employed to determine one or more analysis points to set within objects associated with the application s for audit the objects included in the object data . Analysis points may be associated with particular member variables of the objects to enable the assembly code generation module to extract the values of the member variables during execution of the application for audit . The extracted member variable data may be provided to the audit module which analyzes the member variable data to identify one or more security risks associated with the application for audit . Use of the member variable data to identify security risks is described further herein with reference to .

The audit module may also analyze the object data to validate and audit the application s for audit . Such validation and auditing may result in audit result data which may be provided to the user s through a user interface of the audit module or through a report or may be stored on the audit server s and made available in response to a request for the audit result data . In some embodiments the audit result data may include at least a portion of the object data or the object data may be provided to the client device separately from the audit result data . The audit result data or the provided object data may also include metadata describing data elements within the object data . In some embodiments audit result data may include one or more security risks identified for the application determined while performing auditing operations on the application as described further herein.

As described herein security risks may include identified actions of the application that are suspicious inappropriate outside an expected scope of operations for the application or that otherwise merit scrutiny. In some embodiments security risks may be identified by the audit module based on the application of one or more rules for identifying security risks which may be stored on the audit server s . Security risks of an application may include the application initiating a communications session or connection with a remote entity such another device another process on the same device a remote process or a remote user. A security risk may include the transfer of data to such a remote entity or the receipt of data from a remote entity. In some cases the external communication itself may be deemed a security risk. In some cases the communication may be deemed a security risk based on the remote entity being identified as untrustworthy. The remote entity may be identified based on an identifier associated with the remote entity e.g. a network address being on a black list of known untrustworthy sites or based on the identifier being absent from a white list of known trusted sites.

Security risks may also include the application accessing data from another application process or module on the host device such as a phone book address book location module camera module microphone module data storage or other module. A security risk may include the application providing the data retrieved from the host device to another application running on the host device. In some cases a security risk may include the application accessing data stored on a cloud based device that is accessible to the host device over a network. For example a security risk may be determined where the application is employing the host device s access to a network email server to retrieve messages or other data from the network server. In some cases the access itself to data on the host device or on a cloud server is a security risk. In some cases the nature of the data may determine whether the access is a security risk. For example the application s access of personal private sensitive health related financial secure encrypted location or other types of data may be identified as a security risk.

In some embodiments various operations of the assembly code generation module or other operations of the host device s may be remotely controlled from the audit server s . In some cases the remote control may be accomplished through systems and methods described in U.S. patent application Ser. No. 13 619 867 filed on Sep. 14 2012 titled Remote Control of a Mobile Device which is incorporated by reference into this disclosure. In some embodiments the audit server s may include functionality of the remote control server s described in Remote Control of a Mobile Device or may communicate with such remote control server s to send instructions to or receive data from the host device s .

In some embodiments the application validation operations described herein may be performed using an emulation of a host device instead of or in addition to using a physical host device . An emulation of a host device may execute on the audit server s or on another computing device and may run an operating system or applications that would otherwise execute on the physical host device . In such cases the application s for audit may be copied to installed on and executed on the emulation of the host device and the assembly code generation module may execute on the emulation to generate the assembly code data .

In some implementations the emulation may be configured to provide the assembly code data without an additional or separate assembly code generation module . For example the emulator may be configured to output the assembly code data for the applications executing in the emulator to the operating system within which the emulator is executing.

The audit server s may include one or more input output I O interface s to allow the audit server s to communicate with other devices. For example the I O interface s may be configured to provide a universal serial bus USB connection compliant with the standards promulgated by the USB Implementers Forum Inc. of Beaverton Oreg.

The I O interface s may couple to one or more I O devices . The I O device s may include user input devices such as one or more of a keyboard a mouse a pen a game controller a voice input device a touch input device a gestural input device the one or more host devices and so forth. The I O device s may include output devices such as one or more of a display a printer audio speakers haptic output device and so forth. In some embodiments the I O device s may be physically incorporated with the audit server s or be externally placed.

The audit server s may also include one or more network interfaces to enable communications between the audit server s and other networked devices such as those depicted in . Such network interface s may include one or more network interface controllers NICs or other types of transceiver devices configured to send and receive communications over the network s . The audit server s may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the audit server s .

As shown in the audit server s includes one or more memories . The memory comprises one or more computer readable storage media CRSM . The CRSM may be any one or more of an electronic storage medium a magnetic storage medium an optical storage medium a quantum storage medium a mechanical computer storage medium and so forth. The memory provides storage of computer readable instructions data structures program modules and other data for the operation of the audit server s .

The memory may include at least one operating system OS module . The OS module is configured to manage hardware resources such as the I O interface s and provide various services to applications or modules executing on the processor s .

In some embodiments the OS module may comprise a distribution or variant of the Linux operating system originally released by Linus Torvalds. In the example shown the memory includes an audit module to perform auditing validation application instrumentation load testing and other types of actions for embodiments described herein. In some embodiments the audit module includes an audit user interface module . The audit user interface module may be configured to provide an application programming interface graphical user interface GUI command line user interface CUI web interface or other facility to allow the client device to communicate with the audit module . The audit user interface module enables the user to provide input and receive output associated with the host device and the operations of the host device . The audit user interface module may accept application s for audit an identification of a host device for validation and so forth. The audit user interface module may also present object data data related to particular objects or attributes of objects or audit result data . The audit user interface module is described further with reference to the example interface shown in below. Operations of the audit module are described further below with reference to .

Other modules may also be included in the audit server s . These other modules may include but are not limited to user authentication modules access control modules billing modules and so forth.

In some embodiments the memory also includes a datastore to store information for operations of the audit server s . The datastore may comprise a database array structured list tree or other data structure. The datastore may store the object data the application s for audit received from the client device s the audit result data sent to the client device s and the assembly code data received from the host device s . Other data may also be stored in the datastore such as user account or authentication information test scripts or other test input data debugging results operational audit data and so forth.

As described with regard to the audit server s the host device may include one or more input output I O interfaces to allow the host device to communicate with other devices such as those shown in . In some embodiments the I O interface s may be configured to provide a universal serial bus USB connection.

The I O interface s may couple to one or more I O devices . The I O device s may include user input devices such as one or more of a keyboard a mouse a pen a game controller a voice input device a touch input device a gestural input device one or more accelerometers one or more gyroscopes the audit server s and so forth. The I O device s may include output devices such as one or more of a display a printer audio speakers haptic output device and so forth. In some embodiments the I O device s may be physically incorporated with the host device or be externally placed.

The host device may also include one or more network interfaces e.g. NICs configured to send and receive communications over the network s . The host device may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the host device .

As shown in the host device includes one or more memories . The memory comprises one or more CRSM as described above in . The memory may include at least one operating system OS module . The OS module is configured to manage hardware resources such as the I O interface s and provide various services to applications or modules executing on the processor s . The OS module may comprise one or more mobile operating systems configured for execution on mobile computing devices. The OS module may implement one or more of iOS from Apple Corp. of Cupertino Calif. Windows Mobile from Microsoft Corp. of Redmond Wash. Android from Google Corp. of Mountain View Calif. and its derivatives from various sources Palm OS from Palm Computing Inc. of Sunnyvale Calif. and its derivatives from various sources BlackBerry OS from Research In Motion Ltd. of Waterloo Ontario Canada or other operating systems such as VxWorks from Wind River Systems of Alameda Calif. In cases where the OS module implements a version of iOS any version of iOS may be supported including iOS 1.x 2.x 3.x 4.x 5.x 6.x or higher versions including any version of iOS for the iPhone iPad iPad Touch or any other compatible device. In cases where the OS module implements a version of Android any version of Android may be supported including but not limited to versions 2.3.x Gingerbread 4.0.x Ice Cream Sandwich 4.1.x Jelly Bean and so forth. The memory may include the assembly code generation module the application s for audit and other module s .

The memory also includes a datastore to store information for operations of host device . The datastore may comprise a database array structured list tree or other data structure. The datastore may store the assembly code data generated by the assembly code generation module . Other data may also be stored such as user account information network connectivity data and so forth.

The interface may include a summary section describing characteristics of the host device or other aspects of the security auditing environment. For example as shown in the summary section may include information for a device type brand model or processor architecture of the host device an OS and OS version for the OS running on the host device one or more particular applications apps or other processes currently executing on the host device e.g. apps undergoing a security audit and so forth.

In some embodiments the interface may include a graphical or textual report indicating one or more security risks identified based on the security audit of the application. In the example shown the report includes security risks indicating objects that access data on the host device and the types of data accessed such as address book data phone book data financial records data or other types of sensitive personal or private data. The types of data accessed may include location data e.g. from a module that employs the Global Positioning System GPS to determine location information for the host device .

The report may also include security risks indicating objects that communicate with devices sites services or individuals that are external to the host device . In the example shown a security risk indicates that ObjectZ of the application sends data to a web site www.xyz.com. The report may also include security risks indicating a data transfer or other interaction between objects that access data on the host device and objects that communicate with external entities. In some cases the security risks may also indicate that the data being externally communicates includes the data retrieved from the host device .

Report may also include other potential security risks . For example as shown in the other potential security risks include an identification of two objects ObjectQ and ObjectP which originate from a particular software development kit SDK or third party software library that has previously been correlated with security risks. In some cases a security risk may be identified based on an object or class originating from outside a collection of known safe software libraries. For example objects or classes that are not standard iOS objects or classes may be identified as security risks.

The interface may also include one or more controls e.g. buttons drop down lists etc. that enable a user to select a host device and host device operating system on which to generate assembly code data to be used for auditing. Control s may display a list of host devices and host device operating systems available for auditing operations. In some embodiments the interface may include one or more controls to enable a user to select and upload an application to be audited from the client device to the audit server s .

Although shows an example interface with various user interface elements in particular positions the particular example arrangement shown is not in any way limiting of embodiments. Accordingly various embodiments may employ a user interface that includes more or fewer user interface elements or controls in any combination and in any arrangement to enable functionality of the embodiments. Further embodiments may support multiple user interfaces e.g. multi page web sites with functionality spread across various pages. Embodiments may also support dynamically generated interfaces where the particular user interface elements displayed and the location or duration of their display is based on a particular state of the system particular characteristics of the user or the local client device or other factors.

In the example shown the application for audit may include one or more OS library objects . These objects may include objects for accessing commonly used features of the OS or the host device such as accessing the file system address book phone book GPS system camera microphone image store or other data storage on the host device . For example in cases where the application for audit is to run on an iOS platform the OS library objects may include iOS library objects or classes.

The application for audit may also include one or more application objects created specifically to run within this application for audit . In some cases application objects may be modified somewhat from publicly available shareware or freeware software or modified from other objects written to perform similar functions in other applications.

The application for audit may also include one or more third party library objects . Such objects may be incorporated into the application for audit by the developer to perform actions. Third party library objects may be incorporated into the application for audit from a software development kit SDK used by the developer to expedite development of the application. Third party library objects may perform various functions including but not limited to functionality for touch event processing accelerometer support localization UI view processing camera support audio data processing video or image data processing networking multi process threading power management file system access security and so forth. For example the third party library objects may be incorporated from the iOS SDK developed by Apple Corp. of Cupertino Calif.

The application for audit may also include one or more interclass communication objects which mediate the transfer of data between any classes or objects of the OS library objects the application objects and the third party library objects . In cases where the application for audit is written in the Objective C programming language the interclass communication objects may implement the Objective C interclass protocol.

In the example shown in at the audit server s may receive one or more applications for audit . For example the user may upload the application for audit through the user interface presented on a client device . This user interface may be provided by the audit user interface module . At the application s for audit may be uploaded to a host device specified by the user for application security auditing. At the application s for audit are received by the host device . In some embodiments uploading of the application s for audit may also include operations to install the application s on the host device including file or folder creation creating or modifying registry or configuration settings creating GUI elements e.g. icons and so forth.

At the audit server s may instruct the host device to execute the application s for audit and to execute an assembly code generation module to generate the assembly code data associated with the application. At the application s and the assembly code generation module are executed on the host device . In some embodiments one or more preliminary operations may be performed prior to execution of the application for audit . Such preliminary operations are described with reference to . The assembly code generation module may operate to generate the assembly code data associated with the executing application s for audit . In some embodiments the assembly code data may be stored locally on the host device and retrieved by the audit server s . In some embodiments the assembly code data may be generated through a remote operation of the assembly code generation module by the audit server and the assembly code data may be received at the audit server in real time as the assembly code data is generated. At at least a portion of the assembly code data is provided to the audit server s .

At the audit server s receive the assembly code data from the host device and analyze the assembly code data to identify object s associated with the application. The analysis may also determine relationships between the objects described in the assembly code data . In some embodiments this operation may include a series of iterated operations to retrieve object related data from the host device . In some embodiments the relationships determined are parent child or other forms of inter entity relationships such as has a or is a relationship between objects.

At the object s are analyzed to identify security risks associated with operation of the application on the host device . Identification of security risks is described further herein with regard to . At audit result data may be generated for the application based on the one or more identified security risks. The audit result data may be reported to the user through the user interface provided by the audit user interface module or through other modes of communication such as email text messaging file transfer over a network and so forth. In some embodiments the audit result data may be stored on the audit server s or elsewhere and made available to a requesting user or process.

At the assembly code data may be analyzed to identify member variable s of object s for which to set analysis point s . Member variables include variables defined within the source code of an object or class or variables otherwise associated with an object or class such that methods of the object or class may access the variable s contents. Member variables may include static variables and instance variables. As used herein an analysis point may refer to a location within a member method or function of a class or object of the application for audit the location being at after or before a particular instruction in the method or function. An analysis point may be set to enable data to be retrieved from one or more member variables of the object or class at the location within a member method or function to determine the value of the member variable s when the application for audit is in a particular program state. In some embodiments the data is retrieved by the assembly code generation module .

In some embodiments analysis points are set at various locations in member methods of objects that perform actions for retrieving data from modules of the host device or that perform actions for communicating the data from the host device to another device or process. The analysis points may be associated with member variables of the objects to enable the data stored in the member variables to be extracted. The extracted data may then be analyzed to determine whether the actions performed by the objects constitute a security risk of the application for audit .

At the assembly code generation module may be instructed to set the one or more analysis points for identified member variable s as determined at . In some embodiments analysis points are set by sending instructions to the assembly code generation module that the identified member variable s are to be monitored. For example in embodiments where the assembly code generation module is gdb one or more watchpoints may be set to monitor the value of one or more member variables using the watch awatch or rwatch commands in gdb.

At member variable data associated with the analysis point s may be extracted by the assembly code generation module and received for analysis. Such object member data may include data stored in member variable s of object s of the application for audit . Embodiments provide for the analysis of any type of member variable data including numeric data e.g. integer floating point double floating point binary hexadecimal and so forth character data Boolean data and other types.

At the object member data is analyzed to identify security risks present in the application for audit . In some embodiments such analysis is based on applying one or more filters and one or more rules to the object member data. This analysis is described further with reference to .

In some cases the application for audit may be an application that is executed within a web browser or a layout engine running on the host device . For example the application for audit may be written in one or more of the following HTML HTML5 cascading style sheets CSS javascript or other markup or programming languages that are interpreted or executed by a browser application or a layout engine. depicts a flow diagram of a process for analyzing a browser executed or layout engine executed application to identify security risks by inspecting the application using a browser or layout engine executing in debug mode. This process may be implemented by the audit server s the host device s the client device s or any combination thereof.

In cases where the application for audit is an application executed within a web browser or layout engine running on the host device the assembly code data may include assembly code generated by executing a web browser or a layout engine on the host device and employing the assembly code generation module to generate assembly code for the web browser or layout engine as described above. At the assembly code data of the browser or the layout engine is analyzed to determine how to execute the web browser or the layout engine in a debug mode.

Embodiments support the use of any web browser including Mozilla Firefox Microsoft Internet Explorer Google Chrome Apple Safari Rockmelt and other browsers. A layout engine is a software module that enables a web browser to render a web page and as such may operate in conjunction with a web browser to display web pages for a browser executed application. Embodiments support the use of any layout engine including WebKit maintained through the WebKit Open Source Project or other layout engines.

At based on the analysis of the web browser and layout engine the web browser and the layout engine are executed in a debug mode on the host device . Running a browser in debug mode may enable a user or script to view CSS elements debug javascript code or other scripts and programs monitor web connections and sessions monitor GET POST PUT or other requests and perform other actions to inspect the browser executed application. Some embodiments provide a runtime debug console to enable debug information to be displayed during execution of an application in the web browser. Such debug information may include runtime errors associated with HTML HTML5 CSS javascript or other code associated with the application.

At the application for audit is inspected using the web browser and the layout engine executing in debug mode. Such inspection may include inspection of HTML javascript or CSS of the application viewing page source for the application viewing the document object model DOM of the application viewing the UI WebView hierarchy of the application debugging scripts profiling the performance of the application and other actions.

At one or more rules may be applied to the inspected application to identify any security risks present in the application. For example inspection of the HTML javascript CSS or other code of the application may show that the application has gained access to a secret key or other cryptographic information for a website and used that secret key to access otherwise secure features of the website. Such features may include features provided by a website through an API that is secured using the secret key. The application may then use that access to violate security of the website and access to secure information cheat in a game alter user privileges or perform other actions. Embodiments may apply one or more rules to identify such actions as security risks. Rules that may be applied are described further with reference to .

In some cases inspection of the application may also include using a static analysis tool to check if javascript source code or other source code complies with syntax or grammar rules for its corresponding programming or scripting language. For such analysis some embodiments may employ the JSLint tool created by Douglas Crockford.

At one or more filters are applied to the object member data. In some embodiments filters may be applied to reduce the amount of object member data prior to further analysis of the object member data. Filters may be applied to select a certain subset of the object member data for further analysis or to remove a certain subset of the object member data that is not relevant for determining security risks. For example in some cases object member data may be filtered to remove data related to UI view variables which may not be relevant for determining security risks.

After the object member data has been filtered one or more rules such as the rules for identifying security risks may be applied to the object member data to identify security risks. These rules designate behaviors which may be indicative of security risks. Example rules are described in further detail with reference to . At a rule is applied to the object member data. At a determination is made whether there is a security risk based on applying the rule to the object member data. If so at a security risk is indicated for the application. If no security risk is determined the process proceeds to . At a determination is made whether there are additional rules to apply. If so the process may return to and apply the next rule to the object member data. If not at any security risks which have been identified through application of the rules may be reported as described above.

In some embodiments analysis points may be placed within member methods of one or more interclass communication objects to generate object member data. In cases where the application for audit is written in the Objective C programming language and the Interclass communication objects include classes to implement the Objective C interclass protocol analysis points may be set in the objc msgSend function which provides a message passing interface between classes. The assembly code generation module may be employed to eavesdrop on the objc msgSend function as shown in Execution Sample 1 below generated as output from gdb monitoring calls to objc msgSend associated with debugging of the core timer function  NSCFTimer.

Execution Sample 2 provides another example in which gdb is employed to monitor calls to objc msgSend associated with debugging the NSURL function used to make HTTP connections.

As used herein objects may refer to program objects within an application. For example in cases where the application for audit is written in the Objective C programming language the Java programming language or another object oriented programming language the objects may correspond to classes defined in the application source code objects that are instantiations of classes at runtime or both. Embodiments support the generation and use of assembly code data to validation applications written entirely or in part in an object oriented programming language such as Java C C Python Smalltalk Objective C or other languages. Embodiments may also support validation of applications written in languages that include objects or similar constructs as features of the language but with a grammar or syntax that varies from those of other object oriented programming languages. For example embodiments may provide for the validation of applications written in multi paradigm programming languages that combine aspects of two or more of procedural functional and object oriented paradigms such as Lisp or Common Lisp. As used herein an object may refer to a construct within a computer program where the construct includes a combination of dynamic data elements static data elements methods procedures functions or other elements.

Although some of the examples provided herein describe using an object level hierarchy to audit an application written in a particular programming language embodiments may also operate to validate an application written in the Objective C Objective C or Objective C 2.0 the Java programming language or another programming language. For example embodiments may support auditing of Objective C applications written using the Cocoa application programming interface API from Apple Corp. of Cupertino Calif. In such cases embodiments may extract from the assembly code data information for one or more objects included in or accessed during execution of the Objective C application. In some embodiments data from one or more Nib files associated with the application may be employed to identify objects associated with the application and relationships between the objects. Such a Nib file may be loaded automatically when the application is launched on the host device and may include data identifying user interface objects and relationships between the objects.

In some embodiments the operations described herein may be performed via remote control operations. For example the audit server may remotely control the host device to install and execute the application for audit execute the assembly code generation module set analysis points retrieve member variable data for analysis and so forth. Such remote control operations may be performed using methods or systems described in U.S. patent application Ser. No. 13 619 867 filed on Sep. 14 2012 titled Remote Control of a Mobile Device which is incorporated by reference above.

In the example shown the rules are divided into sets of rule types. Rules for communications include various rules to identify a security risk based on the types of communications performed by object s of the application for audit the destinations of such communications or the contents of such communications. Such communications may be performed using a communications protocol including but not limited to transmission control protocol TCP internet protocol IP hypertext transfer protocol HTTP hypertext transfer protocol secure HTTPS or file transfer protocol FTP . In some embodiments rules for communication may be applied to object member data retrieved through setting analysis points in methods associated with network communications such as a method named httpMethod that is a member of a class of type NSHTTPURLResponse. Rules may be applied to member variable data that includes payload data for an outgoing or incoming communication or address information for a destination for the communications. Example rules for communications may include the following.

In some embodiments a security risk may be identified based on whether the object communicates with an external entity and whether that an identifier for the entity is part of an access control list. An access control list may include one or both of a white list and a black list and a security risk may be identified if the object communicates with an external entity that is on a black list or with an external entity that is not on a white list. The external entity may be a device process or individual that is external to the host device. The white list may be a list of entities that are known to be trusted and the black list may be a list of entities that are known to be not trusted. In some cases the white list may include devices on a corporate network such that any communications outside the corporate network indicate a security risk. The white list may list addresses or other identifiers of devices such as a uniform resource locator URL uniform resource identifier URI uniform resource name URN IP address or other identifier. Under such rules the communication itself may be identified as a security risk regardless of the particular data being communicated. A security risk may be determined based on a destination address port domain or region of IP address space for the communication.

A security risk may be identified if the object communicates particular data or types of data with an external entity. For example a rule may indicate a security risk if data from certain modules on the host device is communicated externally such as data from the phone book or address book. An analysis of the communicated data may be performed to determine whether it is of a sensitive nature such as private data personal data financial data healthcare related data or otherwise sensitive. The determination may be made based on one or more of request or response headers data sent in GET or POST requests to a web site e.g. for HTTP or HTTPS traffic the address or port for the destination the size of the content sent or the data itself being sent.

A security risk may be identified if the object communicates with another application or process executing on the host device . In such cases an object of the application for audit may communicate with another application that is determined to communicate with external entities such that data leakage may occur from the object through the other application to an external entity.

The rules may also include rules for data access to identify a security risk based on access by the application for audit to data stored on the host device or on another device accessible from the host device . In some embodiments rules for data access may be applied to object member data retrieved through setting analysis points in methods associated with accessing data on the host device such as methods in an instance of a class MMAddressBookMediator or other object indicating that the application is accessing the address book on the host device .

Example rules for data access may include the following A security risk may be identified if an object accesses data from particular module s on the host device such as an address book a phone book a location system storing GPS data portions of the file system used by system processes on the host device an image store or a camera module. In some cases the access to such module s may itself be deemed a security risk regardless of which data is being retrieved from the module s . For example any access to certain portions of the file system on the host device may be deemed a security risk.

A security risk may be identified based on the application making one or more calls to a GPS or location system to determine a location for the host device . For example an application running on iOS may call to CLLocationManager startUpdatingLocation to determine a current location for the host device and a security risk may be identified based on the call.

A security risk may be identified based on access to data on another device accessible to the host device . For example in some cases the host device may have access to a file server email server or other device accessible over a corporate network. In cases where the application for audit is intended for personal use on the host device and not for business related use a security risk may be identified if an object in the application for audit attempts to access data from another device accessible to the host device over the corporate network.

In some cases a security risk may be identified if an object accesses particular type s of data from module s on the host device or from module s on another device that is accessible to the host device . For example access to identification or address data for contacts on the host device may be deemed a security risk regardless of which module such data is being accessed from. In some cases the rule may indicate a security risk based on a set of expected operations of the application for audit . For example it may be inappropriate for a music player application to be accessing the address book or location information on the host device .

A security risk may be identified based on the type of object performing the data access operations. For example data access operations by third party objects e.g. objects from SDK libraries to certain module s on the host device or to other devices accessible to the host device may be identified as a security risk.

In some embodiments a security risk may be identified if the application for audit accesses any file on the host device or accesses any of a predetermined type of file or subset of files on the host device . In some embodiments a user may be informed of this access and queried to give permission whether the application for audit is to be permitted to access the file s . In some embodiments the user may be informed of the access and queried for permission through the audit user interface module .

The rules may also Include rules for data transfer to identify a security risk based on data transferred between objects of the application for audit . In some embodiments rules for data transfer may be applied to object member data retrieved through setting analysis points in methods of interclass communication objects .

Example rules for data transfer may include the following A security risk may be identified if an object accesses data from module s on the host device and transfers at least a portion of that data to object s that communicate the data to external entities. A security risk may be identified if an object accesses data from module s on the host device and transfers at least a portion of that data to another application or process executing on the host device . A security risk may be identified if an object transfers data from a particular module on the host device to a third party object included in the application for audit .

The rules employed by embodiments are not limited to the examples listed above. Any type of rule may be employed by embodiments. Further the example rules above or other rules may be used in any combination to identify security risks of the application for audit . In some embodiments the rules are static and may be maintained and updated manually by an operator of the audit server . However embodiments are not so limited and in some cases the rules may be dynamically adjusted or refined based on security risks detected through operations of the audit module described herein. In some embodiments the rules may be created or updated through a machine learning process. Such machine learning may be supervised or unsupervised and may employ as training data information gathered regarding applications and the security risks identified for the applications.

At an application is received in a binary or executable format. In some cases the application may be received from a client device associated with a user who is requesting that a security audit be performed on the application prior to releasing the application commercially or prior to use of the application on a corporate network. In some cases the application may be received as a binary file and may not include the original source code for the application.

At in cases where the received binary is a universal or fat binary that includes executables for more than one target processor architecture the executable may be extracted that is appropriate for the processor architecture of the host device on which the application is to be executed. For example a binary may be received that includes two executables one to run on an ARM v6 processor and another to run on an ARM v7 processor such as designed at least in part by ARM Holdings of Cambridge England.

This determination may be made through use of a tool that examines the universal binary such as the otool utility which analyzes Mach O format files. Example Sample 3 shows an example execution of otool against an application abc123 with output indicating two target architectures.

In cases where the binary is a universal binary which includes more than one executable a utility may be used to extract one executable. For example the lipo utility for Mach O formatted universal binaries may be used to perform the particular extraction. Execution Sample 4 shows an example execution of lipo to extract an ARM v7 executable from the example binary abc123 shown in Execution Sample 3 and the use of otool to view the header information for the extracted executable.

At application header information may be analyzed to determine an encryption state for the application. Some operating systems such as the iOS operating system from Apple may be configured to encrypt at least a portion of the application application data and so forth during loading or execution. For example the application may be encrypted by the iOS application loader may encrypt the application using the Advanced Encryption Standard AES 256 bit encryption algorithm or some other encryption algorithm when the application is loaded. In some cases the information indicating that encryption is to be used for an application is located at a particular location that is an offset from the load address for the application. In such cases once the load address for the application in virtual memory is determined the encryption information may be found at an address that is at the offset from the load address.

In some embodiments this analysis may be performed using a utility such as otool to examine header information and to identify a flag variable or other data item that indicates the encryption state for the application. Execution Sample 5 shows an example execution of otool for such a purpose with a grep command to perform a text search for the encryption data in the header. In the following example cryptid variable is set to 1 indicating an encrypted state for the application.

At a determination is made whether the application is encrypted. If so at a breakpoint is set at the start address for the encryption and the application is executed with the assembly code generation module .

At the breakpoint is reached and the application pauses. While the application is paused the encryption flag e.g. cryptid may be set to turn off encryption e.g. set to 0 . Turning off encryption enables unencrypted legible assembly code data to be generated for the application. Generation of legible assembly code may be accomplished by dumping the memory from the start address up to cryptsize as shown in Execution Sample 3. If encryption is not turned off the assembly code may show class names method names variables and parameters in an encrypted form.

At the execution of the application resumes. Returning to when the application is determined to be unencrypted the process proceeds to .

Embodiments provide for turning off encryption in an application to facilitate the security auditing operations described herein. Turning off the encryption enables such investigation and testing for security flaws or vulnerabilities in the applications being audited.

In some embodiments the audit module or another module of the audit server s may instrument or otherwise modify the applications prior to their use on or in conjunction with the corporate or organizational network. The instrumented application s may be made available to end users such as through the app store or through an internal app store . The internal app store may be accessible by employees or members such as end users and may not be accessible by the general public. Such Instrumenting or modification of applications for internal or limited use is described further herein with reference to .

In some embodiments the host device s or audit server s may be employed to generate load traffic to be used for load testing validation testing or other testing of online services hosted by one or more enterprise backend servers . Moreover in some embodiments load test server s may be employed to generate the load traffic . The load traffic may be generated by playing back transaction data . The transaction data may be obtained by monitoring the interaction of the host device with the enterprise backend server using the techniques described above. For example the object data may be extracted during the interaction. The transaction data may be used by the load test server the host device or both to replay at least a portion of the interaction for testing purposes. Such load testing is described further herein with reference to .

At one or more analysis points are set in object s corresponding to identified security risks of the application as described above. For example an analysis point may be set in a member method of an object that communicates with an external website to enable monitoring of one or more member variables that store data for the destination address or port of the communications one or more member variables that store the payload data being communicated or other member variables.

At additional assembly code data may be injected or otherwise incorporated into the assembly code data for the application. In some embodiments the additional assembly code data includes functionality for data logging. The data logging is configured to write the contents of member variables out to data logs in storage when the application executes on a client device . The additional assembly code data may also include instructions to capture information for the application state when the data is logged including a stack trace for the application contents of variables classes objects or instances of objects or other data useful for monitoring the operation of the application. For example where the application is accessing data from its host device and communicating that data externally the additional assembly code may write to memory the data being accessed and communicated and the destination URL IP address port and so forth where the data is being sent. In this way embodiments may enable the application to be monitored for security breaches while it is executing on a device which connects to a corporate or organizational network.

At one or more additional modifications may be made to the assembly code for the application. These modifications may disable one or more functions of the application that are determined to be associated with a security risk. For example where the application would otherwise be able to access an address book on a device its assembly code may be modified to block such access or prevent the accessed data from being communicated externally or transferred to other objects of the application.

At a binary version of the application may be created by compiling the original e.g. unmodified assembly code for the application with the additional assembly code added at and the modified assembly code modified at . At this binary version of the application is provided for use by one or more end users . In some embodiments the modified version of the application is provided to an end user s device through an internal app store that is accessible to company employees organizational members or some other subset of the general user population.

After the end users download Install and execute the modified version of the application on their client devices at the log data generated during execution of the instrumented application is received from the client devices and analyzed to determine whether any additional security risks have manifested. In some embodiments the log data may be periodically uploaded e.g. daily to the audit server or to another device for analysis. In some embodiments the log data may be retrieved when the client device connects to the corporate or organizational network. In some embodiments the log data is retrieved under particular network conditions such as when the client device connects to the corporate network via a WiFi connection instead of a cellular data connection e.g. a 3G connection .

In some embodiments where the application for audit is written in Objective C data logging may be performed inserting assembly code including calls to the NSLog function. Execution Sample 6 shows an example data log generated through monitoring of calls to NSURLConnectionInternalConnection.

At load is generated on the enterprise backend server s by sending requests to the enterprise backend server s . In some embodiments load is generated by sending requests from the load server s . Load may also be generated by sending requests from the host device s or the audit server s . In some embodiments the requests are sent to the enterprise backend server s to access one or more features of the services hosted on the enterprise backend server s which are under test thus placing a load on such services. The requests may be based at least in part on the transaction data as described above. For example where the hosted services under test include a web site for online banking the requests sent may replay interactions which establish cancel or maintain accounts deposit withdraw or transfer funds apply for a loan order checks or money orders or perform other activities relevant to online banking. In some cases the requests may be sent with a particular timing or from a particular number of devices to generate a particular load on the enterprise backend server s . This may enable the functionality of the hosted services to be tested with measured load or usage conditions.

At one or more responses may be received to the requests sent at . If the traffic is encrypted e.g. if the requests and responses were sent using HTTPS or another encrypted communications protocol at the responses may be decrypted using one or more encryption keys associated with the enterprise backend server s . For example where the requests are sent using the Secure Sockets Layer SSL or Transport Layer Security TLS cryptographic protocols e.g. as in the HTTPS protocol the enterprise public key may be used to decrypt the response traffic.

At the responses are compared to expected responses to determine whether the enterprise hosted services have functioned correctly under the applied traffic load. In some embodiments the comparison may be a comparison between the received responses and a baseline response previously generated by the hosted services under lesser load or minimal load. In some embodiments the baseline for comparison may be provided by the enterprise expected behavior of the services as designed. In some embodiments the comparison may compare baseline source code to the source code of at least a portion of a web page received in response to the requests sent. In some embodiments the baseline may be determined based on the object level analysis of assembly code data for the application as described above.

At a determination is made whether the response s are consistent with the comparison baseline e.g. the expected response s . If not then at a report may be made of a possible regression error or bug detected during the load testing of the hosted services on the enterprise backend server s . The process may then proceed to block .

Returning to if the responses are consistent with the comparison baseline the process may proceed to . At the load may then be increased and the process repeated under a different load. In such cases the responses received in the previous test may be used as a baseline during the subsequent iteration.

In many cases web sites or other online services include certain features designed to be optimally used through a mobile device such as a smartphone tablet computer eBook reader and the like. In some embodiments where the host device s include mobile devices embodiments provide a means for generating a given load of mobile device traffic for load testing the mobile device specific functionality of a web site. Such mobile device traffic may be generated under a variety of network connectivity scenarios to test the web site under a variety of real world conditions. For example the host devices may be controlled to operate over a variety of network connections including a wireless network e.g. WiFi 3G or 4G cellular data network or a wired connection with varying connection strengths e.g. varying number of bars as shown on the device .

Object data may be extracted during communications between the host device s and the backend server s to generate the transaction data . The object data may include communications payloads as well as data indicating the address port and other information identifying the source and destination of each communication. The transaction data comprising the extracted data may be replayed with a predetermined number of connections or at a predetermined frequency to create a predetermined load to be placed on the backend server . By replaying the extracted data at the predetermined traffic load the services running on the backend server s may be load tested using the mobile device traffic extracted during communications between mobile devices of the host device s and the backend server s .

In some cases the transaction data indicative of the mobile device traffic may be played back from devices such as the load test server s that may not themselves be mobile devices. In some embodiments playback of the transaction data may be through a web load testing tool such as HP Load Runner from Hewlett Packard Company of Palo Alto Calif. or the WireShark packet analyzer and TShark network protocol analyzer from the Wireshark open source project. In such cases the extracted mobile communications data may be provided as input to the replay functionality of the web load testing tool. In some embodiments the transaction data may be formatted in a file format used by HP Load Runner WireShark TShark or other tools. For example the transaction data may be formatted in a packet capture PCAP file format suitable for input to such tools.

Execution Samples 7 and 8 provide example execution outputs from a web load testing tool. Execution Sample 7 provides an example output of a web testing tool to measure the performance of a website www.abc123.com to create a benchmark for its performance. In this example traffic generated from an iPhone 4S is replayed using 10 threads with each thread issuing 10 HTTP requests in parallel. The traffic is over a 4G WiFi connection with a request rate of 1.2 requests second with a traffic load of 127 KB second.

Execution Sample 8 provides an example output of a web testing tool to measure the performance of the same website but with different network conditions using a 4G connection with 4 bars using traffic from the same device. Execution Sample 8 shows a degradation in reply rate from an average reply rate 1.1 to an average reply rate of 1.0.

Those having ordinary skill in the art will readily recognize that certain steps or operations illustrated in the figures above can be eliminated combined subdivided executed in parallel or taken in an alternate order. Moreover the methods described above may be implemented as one or more software programs for a computer system and are encoded in a computer readable storage medium as instructions executable on one or more processors.

Separate instances of these programs can be executed on or distributed across separate computer systems. Thus although certain steps have been described as being performed by certain devices software programs processes or entities this need not be the case and a variety of alternative implementations will be understood by those having ordinary skill in the art.

Additionally those having ordinary skill in the art readily recognize that the techniques described above can be utilized in a variety of devices environments and situations. Although the present disclosure is written with respect to specific embodiments and implementations various changes and modifications may be suggested to one skilled in the art and it is intended that the present disclosure encompass such changes and modifications that fall within the scope of the appended claims.

