---

title: Method and apparatus enabling multi threaded program execution for a Cobol program including OpenMP directives by utilizing a two-stage compilation process
abstract: A method and apparatus is disclosed for compilation of an original Cobol program with support for improved performance by increased parallelism during execution using multiple threads of processing. The approach includes a two stage compilation process, the first compilation/translation step by a first specialized compiler/translator that takes as input a Cobol source program that includes parallelization directives, and produces as output an intermediate computer program in a second computer programming language, the intermediate program including parallelization directives in the second computer programming language. The intermediate program is then compiled utilizing a selected second compiler that provides support for parallelism described in the second programming language. The approach optionally allows for use of pragmas serving as parallelization directives to the compiler in the original Cobol program or in the intermediate program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08869126&OS=08869126&RS=08869126
owner: Bull HN Information Systems Inc.
number: 08869126
owner_city: Chelmsford
owner_country: US
publication_date: 20121228
---
This Patent Application claims priority to and is a continuation of U.S. patent application Ser. No. 12 589 304 filed on Oct. 20 2009 the disclosure of which is hereby incorporated herein by reference in full and in its entirety as part of this specification. All other referenced patents and applications are also incorporated herein by reference in their entirety. Furthermore where a definition or use of a term in a reference which is incorporated by reference herein is inconsistent or contrary to the definition of that term provided herein the definition of that term provided herein shall govern the meaning of such term.

This invention is related to the fields of computing machines parallel processing parallel computing multiple thread program execution the computer language Cobol the computer languages JAVA C C and Fortran computer program compilers computer languages and other closely related computer art.

In the field of computing machines and computing performance computer users have become accustomed to computer performance increasing steadily over the years as a result of technological innovation in the hardware of computers. However there are limits on technology which tend to limit continued increases in computer hardware performance. For example certain technical limitations tend to limit how fast a computer program can run on a single computer.

An alternative to increasing performance of a program on a single or small number of processing units is to spread the work to be done across multiple processors or multiple computers. Innovation and technical advancement in this area have provided for increasing computer program performance by developing techniques for spreading work across a plurality of computers or central processing units. A common term for this spreading of work is parallelization . There are many forms of parallelization and ways of achieving parallelization which are discussed at length in literature surrounding the art and which will not be discussed here. One particular area of research and significant development which is of particular interest in the field of parallelization is a standard for describing and enabling parallelization called OpenMP Architecture Open Multi Processing Architecture . OpenMP is a trademark of the OpenMP Architecture Review Board and the standard is described on the Internet at a website OpenMP.org The OpenMP Architecture is described within this webpage as API Specification for Parallel Programming . Wikipedia.org further describes OpenMP as 

OpenMP as a project was initiated in 1997 at a major conference on High Performance Computing Networking and Storage held in San Jose Calif. The conference was named Supercomputing 1997 . The proposal for a parallel programming standard grew out of a birds of a feather session to unveil new portable programming interfaces for shared memory parallel computers. Following the conference a company was set up to own and maintain the new informal standard and it was called the OpenMP Architectural Review Board ARB .

The OpenMP architecture provides a methodology and programming language enhancements that enable processing with parallel threads of processing. OpenMP requires support within or by a compiler that is it is not just a library that is called it requires support by the compiler itself. OpenMP today is supported by several major compilers GNU C compiler Intel Microsoft for computer programs written in the languages of C C and Fortran. There are books and classes on parallel programming based upon OpenMP.

However OpenMP architectural support for programs written in other computer languages such as Cobol Pascal and other either older or less common computer programming languages is not provided by major computer program compiler manufacturers such as Intel Microsoft or by providers of open source compilers such as GNU.org. As a result the benefits of programming utilizing OpenMP to achieve parallelism are not currently available for programs written in these older languages and support is not likely to be provided in the future by major compiler manufacturers because most new program development is done in more modern languages.

However Cobol is still the programming language for many large computer business applications that are in production use today and the performance of these programs or applications is often critical to operation of a business. Therefore it would be beneficial if these large computer applications could be made to benefit from parallel programming in order to improve their performance during execution. Improvement in performance of what are commonly called batch programs might be especially important. The term Batch is used to describe a job often run at night that typically processes a large amount of data from a day of recorded transactions. Oftentimes batch programs are run at night and oftentimes must be completed before more transaction data can be accumulated the next day for example .

Providing support for parallelization techniques by a compiler for a language such as Cobol is a very significant task for several reasons. First of all developing a new compiler or significantly enhancing an existing compiler for any purpose can be a large task. Second providing for parallelization enabling concepts within generated code from a compiler is a difficult job and would be a very significant development task. Third one major component of good compilers is providing a facility mechanism capability for carrying out very extensive optimization of generated code in order to achieve good performance during execution and support for OpenMP would typically have impact on those optimizations. For these reasons and others such as lack of limited resources innovation financial burdens etc. major compiler builders have not provided a Cobol compiler that supports parallelism such as the OpenMP architecture.

Because of the business nature of most Cobol applications existing Cobol compilers used by large businesses are very carefully maintained by vendors in providing for backwards compatibility and to avoid any possible introduction of bugs or flaws in the code generation process. The importance of producing correct calculations is emphasized and thus even the smallest changes are typically verified carefully by running large numbers of test programs. As a result changes and improvements to Cobol compilers are made slowly and carefully possibly even reluctantly.

Another reason parallelization support has not been provided for the Cobol programming language is that the language of Cobol is not necessarily well suited to parallelization. The Cobol language because it is quite old has typically been used to describe a program that exists statically in memory with static memory variables and oftentimes without the use of modern programming constructs such as stacks or automatic memory allocation and de allocation. This tends to create conflicts in the use of memory based variables when attempts are made to parallelize program execution because parallelization typically requires at least some degree of isolation of memory between the units of parallelized code. Also there are no OpenMP library facilities available which directly provide OpenMP support for the Cobol language.

But improving the performance of programs written in Cobol is potentially important and improving performance by providing for support of parallel processing in the execution of a Cobol program would result in a potentially significant increase in performance by enabling application and utilization of multiple processors or computing cores to a single program or problem which was normally run in the prior art as a single thread process or procedure. The same is also true for other languages such as Pascal PL 1 or other possibly older languages where no support for parallelism is currently provided by major compiler providers.

The state of the art has also evolved such that parallelization or multithreading of programs now has some increased potential for being automated or at least done with more help by tools than in the past. One company that is exploring this area of research is a Swedish company called Nema Labs which is developing a tool called FasThread . Nema Labs has a website at NemaLabs.com . From the company s website is the statement Nema Labs is a privately held company founded in 2006 with the mission to provide programmers with powerful and easy to use threading tools for multi core platforms. The technology base originates on world class research . . . 

Nema Labs provides a tool which attempts to semi automate the parallelization of programs written in C and is currently working on a version of the tool which also supports C . The FasThread s analysis and processing tool includes a mechanism for inserting OpenMP pragmas into programs in the C language based upon analysis by the tool. This type of tool provides the potential of being useful in achieving parallelization. It utilizes OpenMP and is not applicable to a source program described in any language except its native input language of C.

A Cobol programmer may thus now be motivated to look at the potential for parallelization of certain possibly large Cobol programs in spite of the possibility that parallelization of these programs may not have been feasible in the past.

It would therefore be an advantage to provide a method and or apparatus for compilation of a program written in a source computer language not normally supported for OpenMP which enables parallelization during execution of the generated code either object or executable . It is also an advantage to provide a method of compilation designed to eliminate need for development of a Cobol compiler with integrated parallelization support and with the method further providing for minimal maintenance effort in the support of providing such a method and or apparatus.

An illustrated embodiment of the present invention provides support for a method and apparatus for carrying out compilation of an original Cobol program which produces an executable program that supports multiple threads of processing improving performance of the original Cobol program during execution.

The method according to an illustrated embodiment implements a two step or two phase approach in performing a compilation of an original Cobol program. In the illustrated embodiment a first compiler or translator is utilized in a first phase of the two phase approach to analyze process and translate the original Cobol program source into an intermediate source form in a second computer programming language. This intermediate source produced in the first phase is in a form for describing a program in a manner suited for parallelization through the use of parallelization directives such as the type used by the OpenMP architecture. In a subsequent second phase of the two phase approach a second selected compiler which provides support for the parallelization of an input program described in that second computer language is utilized to compile the intermediate source and produce as an output a multithread executable program for running on multiple processors or computing cores.

More specifically as described with reference to the illustrated embodiment a first compiler translates in a special way a Cobol source program into an intermediate program. A second selected compiler reads the intermediate program and produces as an output file or files an executable program having functionality described by the original Cobol source and which further includes code containing directives that enables parallelism within at least some regions of processing when the resulting executable program is run or executed. The second compiler may also as an alternative produce an object file which is used typically with other object files in producing an executable program. In one illustrated embodiment the first compiler translates in a special way a Cobol program into an intermediate program in the C programming language. A second compiler reads as input the intermediate C program and builds an executable object file or executable program file with parallelization enabled processing by multiple threads . Executable program being meant to describe in general terms any sort of file that may be used in processing. Examples of this type of file are an actual executable file or an object file that can be used to produce an executable file or a DLL Dynamic Link Library file or any file which at run time can be loaded or processed and loaded into memory for execution .

In this manner an executable or executable program is produced based upon the input Cobol program the executable program providing parallelism by utilizing multiple threads of processing during execution. Because of multi threaded execution or processing the executable program is typically capable of running observably faster than a program run with no parallelism single thread . That is the rate of observable work completed in a given time will typically be improved i.e. be made greater when the executable program is processed by multiple processing threads in comparison to a standard approach in which the executable program or at least the main part of the executable program is processed by only one thread. In some cases the rate of work being completed can be seen to increase at a rate related almost directly proportional to the number of threads used.

The compilation analysis and translation by a compiler in the first stage of the illustrated embodiment is a specialized translation resulting in an output in a specific syntax style and having an ordering of output statements and declarations supportive of parallelization. The compiler in the first stage or first phase analyzes the original Cobol program and produces as output a translated or intermediate program typically in C C of Fortran which is specifically organized so as to enable the building of an executable program which provides for parallelism using multiple threads and whose organization is the same or similar to the organization typically required by a parallelization standard such as OpenMP. That is the style constructs chosen for use in the translation and syntax of the translated output from the first compiler is dependent on the specific parallelization desired and the style necessary in order for the intermediate program to be processed by a second parallel capable compiler of the illustrated embodiment.

As discussed the compiler of the first stage produces an intermediate program in a second computer program language that intermediate program is translated in a manner organized to accommodate and include within the intermediate program parallelization directives that are in form suitable to be processed in a second stage of compilation by a selected second compiler the second compiler is specifically selected to provide support for parallelization directives such as the exemplary OpenMP standard. The second compiler is utilized to build the executable program that executable program providing for processing by multiple threads of operation during its execution. The organization syntax and style of the components of the intermediate program and the parallelization directives which are generated by the first stage of processing are constrained and designed so as to be compatible and in a form suitable for processing by the second stage standard compiler.

The method s and approach of the present invention have the potential or opportunity to provide the following several specific improvements and advantages over the above discussed approaches of the prior art 

The first improvement is achieved through use of the two step or two phase or two stage approach of the present invention described briefly above. That is as described with reference to one illustrated embodiment translating a Cobol source program into C and then compiling the C program with a second compiler to produce an executable program the two step process providing throughout such process provisions for both describing parallelism and for building an output executable program which includes parallelism during execution. This will be described in more detail later herein.

The second improvement is also provided as part of the two step approach by choosing or selecting as the second stage compiler that produces an executable program that is highly performant. That is since the second compiler is the program that actually builds an executable program it is very important in terms of achieving best performance to choose or select as a second compiler a compiler that generates as an output a well optimized highly performant executable program. This best choice of compiler is likely to result in selecting a compiler from a company that is a manufacturer or designer of the processor itself such as Intel Corporation or from a large company such as Microsoft Corporation with many resources in terms of personnel and expertise and with good relations with the hardware designers. It is possible also that an Open Source compiler such as GNU C C would be a good choice because of the large amount of effort expended by many people to make it a good compiler. The point is that using a very good compiler such as that from Intel Corporation in a second stage of compilation results in producing an executable program that is likely to perform better on that company s hardware than using a methodology based upon development of a single stage compiler.

With regards to the third improvement described above these maintenance benefits are achieved by utilizing in the manner just discussed a best choice or major compiler as the second compiler. Further when new hardware evolves or new compilation or programming efficiencies are developed the first compiler can be adapted if necessary or maintained with very minimal support because it is translating a program into a standard language such as C and therefore changes in technology which are developed are likely to be provided in that standard language or accommodated by the second compiler. Thus only small changes to the first compiler are likely to be needed to support advancement the larger part of the changes most likely to be provided by the standard second compiler.

Considering the above again but in more detail with reference to an illustrated embodiment of the invention parallelism is achieved by a method that implements a two phase approach. The first phase is a translation performed by a special compiler that operates to translate a Cobol program to an intermediate computer program which is in a second computer language. The translation includes the operations of the ordering of the Cobol statements and the translation of the Cobol statements into a form specifically designed for parallelism which are recognizable by a selected or chosen second compiler.

The second phase is a compilation step performed by the chosen second compiler for building an executable program utilizing the intermediate computer program in the second language i.e. generated from the first phase as input to the second compiler. The second compiler is utilized to build the actual output executable program or object file. The second compiler is a carefully selected already existing standard compiler that supports parallelization such as OpenMP architecture . The specialized first compiler is designed specifically for the purpose of preparing input in a manner acceptable to the selected second compiler with the input to the second compiler including description of the program including variables and program flow description of parallelism with the program variables and program flow being in form which accommodates the description of parallelism.

This approach provides for parallelism without requiring developing or procuring a compiler designed with both direct OpenMP architectural support and direct support for Cobol as an input programming language. Moreover this approach overcomes the need for developing such a compiler when a compiler which supports OpenMP architecture is not available in the marketplace for a Cobol source program and even if such a compiler were to be available this approach provides for improvements such as reduced maintenance improved performance and better support for outside tools such as debug tools developed by other companies for a common language such as C C .

It will be appreciated that it is not just a lack of the availability of any general compiler for achieving parallelism in Cobol that enables an improvement over the prior art. The invention also satisfies a need for performance a desire for broad machine support good debug tools measurement and analysis tools and other similar advantages which are offered by using commercial vendors tools with these features provided in best form on important modern languages such as C C and Fortran. With application of the method of present invention some or all of these advantages are provided for a program written in Cobol while also providing for parallelization utilizing multiple threads of processing during execution of the resulting executable program.

In order to further appreciate how the method of the present invention differs from the typical prior art approach it is helpful to compare in greater detail the method of the present invention with the typical approach of providing a parallelizing Cobol compiler through development of a single pass Cobol compiler which directly supports the OpenMP architecture. While to the inventor s knowledge no such single pass compiler exists this approach would be typical of development approaches known in the prior art This prior art approach without requiring a very major investment would likely not achieve the quality robustness and broad base of tool support provided by the utilization of a major commercial compiler as a second step in the processing of the Cobol program. In fact without an intimate knowledge of the hardware and software it would be likely that even with considerable investment both the performance and the features provided by a single pass compiler would not be as good. Further support for ever evolving hardware software platforms and features would require continued maintenance whereas with the approach and method of the present invention as improvements are made to the selected commercial compiler these improvements will be naturally provided without any or with minimal added development on the first compiler.

Because of close and intimate knowledge of the workings of their own company s hardware and software and because of partnerships with other major commercial vendors companies such as Microsoft Corporation or Intel Corporation can develop compilers which provide for better optimization and more features than what is likely to be provided by individual developers or developers in smaller or less connected companies. For example utilizing a major compiler such as a C C compiler from Intel Corporation as a second compiler provides the benefits of good optimization and continued improvement as hardware changes and evolves. According to the teachings of the present invention using the special compiler in a first phase to perform a special translation of Cobol as for example which includes capability for expressing and describing parallelism within a Cobol program provides for that parallelism in the first phase and relies on use of an already existing compiler from a major vendor in a second phase and takes advantage of features of both compilers.

The OpenMP standard for parallel processing in C C or Fortran programs already provides directives specifically designed to accommodate the languages of C C and Fortran. Thus the OpenMP standard provides an opportunity for accomplishing parallelization which is an alternative to building a compiler with completely automatic parallelization such approach having been shown in the past to be a difficult task for a compiler. Other exemplary prior art approaches for describing or providing parallelization include MPI which is a Message Passing Interface and PThreads which IEEE POSIX standard Institute of Electrical and Electronic Engineers and Portable Operating System Interface .

The OpenMP standard itself can be found on the OpenMP.org website with the latest version at this being Version 3.0 dated May 2008. As discussed OpenMP architecture provides a way for a runtime entity to perform processing using multiple threads with threads being an entity that is able to independently execute a stream of computer instructions. Multiple threads may interact but can also run independently. OpenMP architecture provides for a single set of source files that can be run as a single thread or for enabling multiple threads of operation. Multiple threads may be executed on a single processor or on a machine with multiple processors and or multiple cores . Multiple threads typically work concurrently to accomplish the work of executing a parallel program.

Also OpenMP architecture provides directives to create teams of threads for parallel execution to specify how to share work among the threads to declare and describe both shared and private variables and also to provide means for synchronization and communication between the threads. OpenMP architecture provides these directives for programs written in the C C and Fortran computer programming languages. According to the teachings of the present invention and in order to take advantage of utilizing the OpenMP architecture approach and the OpenMP library to create and manage parallel processing in a Cobol program the Cobol program is analyzed and translated by a special compiler with specific regard to accommodating the generation of a parallel executable program by a second compiler. That is the translation performed by the special compiler includes an analysis of the Cobol program and generation of intermediate program code that is specifically designed to be in a form recognizable by the second compiler. A general straight forward translation of Cobol to C as typically performed in the prior art will not provide for C C or Fortran in a form that will allow or enable parallelization. Further the straight forward approach of performing a simple translation also does not provide for an intermediate program for which parallelization directives could be inserted as for example by hand e.g. by the programmer .

It will be noted that OpenMP architecture provides a fairly small number of directives for describing parallelization in a C C program. A Parallel Construct defines a region of code in which parallelization is allowed. Work Sharing Constructs provide a mechanism for describing parallelization of loops single threading of specific sections within a region of parallelized code and splitting of work into Sections . OpenMP architecture also provides synchronization constructs such as Barriers Critical areas Atomic constructs Locks and defining a Master thread. The Cobol to C translator developed and utilized according to the teachings of the present invention provides for describing multiple threads in a manner which can be applied to a Cobol program with the translator transforming the Cobol program to express parallelization in a related C C or Fortran transformed program with this transformed program being written to an intermediate program file for further compilation by a selected second compiler.

Considering as an example the Cobol programming language provides a statement called a PERFORM statement which describes repeated execution looping of a specified section of code. In Cobol a PERFORM statement may describe looping of code that is described in a different area of the program not immediately following the PERFORM statement . The PERFORM statement works in a manner somewhat similar to that of invoking a subroutine or macro in the C language. The PERFORM statement in a simple translation might be translated to a sequence of code that increments a loop variable and tests for conclusion or termination of the loop with an IF statement with the work of the PERFORM block being handled as a subroutine call. This translation approach in general does not however provide for C C code which allows for parallelization.

As another example A COBOL PERFORM statement might be translated in the manner of the prior art e.g. the OpenCobol.org compiler into a C WHILE statement. This approach however produces C code which is not supported by OpenMP architecture for parallelization because for example the WHILE construct is not supported by OpenMP for parallelization . Therefore according to the teachings of the present invention the first stage of translation is carried out in a manner with the specific intent of producing intermediate program code that is in an order style organization and supportive of compilation by a chosen or selected second compiler that produces parallelization in the output executable program.

The present invention provides a method for compilation of an original Cobol program that method providing for building an executable program with support for multiple threads of processing during execution or running of the executable program. Multiple threads of operation provide in some cases for significantly improved performance in the execution of the Cobol program in comparison to using a single thread of execution. The improvements achieved can potentially provide for a performance improvement approaching 2 3 or more as two three or more threads of processing are applied in comparison to the performance achieved by the use of a single thread.

As described herein in an illustrated embodiment of the present invention with reference to a special purpose compiler is utilized to read an original Cobol source program from a computer file system into an addressable memory of a computer system. The variable declarations and the structure of the Cobol program are analyzed in memory and as a result of the analysis specific regions of the Cobol program are identified as having potential for application of multiple threads to the processing in the manner of the original Cobol source program. Regions for potential parallelization may also be identified based upon user input or embedded content within the Cobol source program itself.

The special purpose compiler provides several functions the first of which is to translate the Cobol source program into a substantially equivalent program expressed in a second computer language with the translated output written to a file on the computer system. In this illustrated embodiment the second language is either C C or Fortran. The special purpose compiler further provides analysis of the input original Cobol program and utilizes the results of analyzing the structure program order variable types and other such information based on analysis of the Cobol source program to define regions of parallelization or regions for potential parallelization. Again selection and determination of these regions may be further based upon both programmer input to help guide the compiler in determining or locating the potential possible or the best regions for parallelization.

As part of the translation process the special purpose compiler organizes and arranges the program statements in the second language in an order and in a form suitable for describing regions of potentially parallelizable code to a second compiler the second compiler being a compiler supporting generation of an executable program which enables parallelism through the use of multiple threads of execution. In this illustrated embodiment the intermediate program is written to a file operatively coupled to or included within the computer system and then the intermediate program given to the second compiler program for processing. The parallelization directives may for this illustrated embodiment be in the form of the OpenMP standard. The second compiler reads the intermediate program file processes it in the memory of the computer system the same computer system or a different one and builds an executable program which is written as output into another computer file that file being in a special format and marked as intended for execution. The compiler may optionally produce either an object file or an executable file the object file being a file which can be combined with other objects to build an executable program. The executable program can be specified to be prepared for execution on the same computer on which it is compiled or on another computer or on different model of a computer.

The method and system of the invention provides for significant potential improvement in the execution time performance of a Cobol program by enabling parallel processing using multiple threads of processing during execution of the Cobol program.

The method and system of the invention provides further advantage in that development of a compiler with direct support for Cobol for example is not required thus reducing development time and cost debug time and cost maintenance time and cost and significantly increasing potential for reliability of the parallelism constructs in the generated program code.

The method and system of the invention also optionally provides potential for use of existing debug performance measurement and program analysis tools which already exist for the already supported form or language that supported form typically being C C or Fortran and also typically with the OpenMP approach.

It is a further advantage of the method and system of the invention to provide for Cobol language support for example in a generated executable program for debug and application of debug tools and debug environments in the manner currently provided for C C and or Fortran.

It is a further advantage of the method and system of the invention to provide measurement tools for analyzing performance as an aid to a programmer in determining areas best suited for parallelization.

It is a further optional advantage of the method and system of the invention to provide as part of the overall Cobol compilation process for inclusion of code in the output executable program which would aid in verifying correctness of any multi threaded execution of a Cobol program.

Translation of a source program described in one computer language to a second source program described in a second source language is not unique or novel. Indeed there are a number of programs that provide for some manner of Cobol to C translation. However simple translation in the manner described in the prior art does not provide support for parallelization constructs and further as discussed above support for parallelization cannot be provided using the output from a simple translation. Consideration of specific constructs proper choice of variable types specific structure and ordering of the code and other such requirements are necessary to enable parallelism. Thus in view of the above it is seen that it is not currently feasible for Cobol programs of any significant complexity to use a simple Cobol to C translation as it exists in the prior art to achieve parallelism in an output executable program. The translation techniques of the prior art are unable to translate Cobol to C in a manner that allows use of OpenMP architectural or parallelization constructs. Further the prior art manner of translation does not lend itself to the introduction of parallelization constructs such as those used in OpenMP architecture even if those constructs were to be added by hand by a programmer after to the intermediate file after the translation was made.

In one illustrated embodiment the present invention provides for translation by a first compiler of an original Cobol source program to an intermediate source program in C C in a specialized manner designed to provide for including for specification in the manner of OpenMP architecture of parallelization constructs to be then applied by passing the intermediate source program through a second compiler the second compiler typically being available from a major vendor and producing an output executable program that provides for multiple threads of execution with such multiple threads providing for observably improved performance during subsequent execution of the output executable program wherein the improvement in performance is achieved during execution of instructions within regions of the program designated as supporting multiple threads and the improvement in each region being related to the number of threads utilized during its execution.

A two stage approach of compiling a Cobol program utilizing a known typically commercial compiler second compiler means that the input format recognized by the known compiler is specified by the manufacturer of that compiler. That is the input source program to the known compiler is provided in a specific form in order to be properly processed by the known compiler. More specifically according to an illustrated embodiment of the present invention the input to the second compiler is a C C program properly formed for processing by the second compiler. In order for parallelization to be enabled the source to that second compilation further provides for the specification of parallelization constructs in the manner specified by the manufacturer of the known second compiler. And also the program code is generated such that the parallelization constructs can be successfully applied to enable multiple threads of processing in the output executable program.

For purposes of further illustration of the above let us assume that the Intel C C compiler is chosen as a known second compiler and that it is to be run with provision in the input source files for OpenMP pragmas . These pragmas are typically processed when enabled by a compiler option. In an illustrated embodiment of the present invention an original Cobol source program is processed translated by a first compiler program according to the teachings of the present invention and the output of that processing is an intermediate source program in the C C language. This C C intermediate source program is then processed by the Intel C C compiler to produce an output executable or object file. The translation by the first compiler program includes provision for generating OpenMP pragmas in a proper form and includes them in the intermediate source program. The intermediate source program is then submitted for processing by the Intel C C ICC compiler for example to produce an executable or object file that enables parallelism through the use of multiple threads during program execution.

An important factor in realizing the potential for success using the two stage translation compilation approach of the present invention is determining and expressing precisely the details of style ordering and selection of constructs to be utilized in the expression of the Cobol source program in the intermediate second form in order to enable application of parallelization constructs by the second compiler e.g. example Intel C C compiler . It is essential that there is correctness in the translation of the original Cobol source program into an intermediate program having the same relative functionality as the original Cobol source program but expressed or defined in a second language for example C C and that the intermediate form generated by the first compiler enables parallelization in a manner that is supported by the second compiler e.g. Intel ICC compiler . Achieving this requires consideration of a broad number of factors in determining the specifics of the translation process. These factors include utilization of one or more of the following rules or guidelines 

1 providing a method of translating variable names as declared in the original Cobol source program into variable names that meet the requirements of the second language for example changing hyphens to   underscores because Cobol allows hyphens in names and C C does not 

2 providing a method of translating variable names as declared in the original Cobol source program so as to preserve recognition by a human when those names are observed after the first translation process for example translating SAMS CASH VALUE to SAMS CASH VALUE rather than into a computer generated name which is less recognizable by a human such as X126 

3 providing allowance for translated variable names which collide meaning that alternative naming is to be provided to prevent two variable names in the original Cobol source program from being translated into the same variable name in the second language C C 

4 providing for Cobol like parallelization directives such as OMP PERFORM for a Cobol PERFORM statement translated into C C OMP pragmas such as pragma omp parallel for for a C C for statement 

5 providing for declaration of variables in a manner so that the variables can be instantiated in memory with proper scope so that during execution processing can be performed by multiple threads without interference between memory references from different threads to the same variables and 

6 providing for locating the declaration of some variables within the structure of the intermediate source program so as to provide for declaration of the variables within the limited scope of a parallelized region of the code thus providing isolation of variable data between multiple threads.

The techniques of providing for the translation of a Cobol source program in a manner that enables parallelization to be described utilizing directives such as those provided in OpenMP architecture through an intermediate program language such as C C or Fortran is further illustrated with reference to examples of the current state of the art described in contrast to the teachings of the present invention.

By way of background in the prior art utilizing a single stage compiler without support for parallelization a Cobol source file describing a Cobol program is typically read in during a first pass of the single stage compiler and at that time internal tables are built to describe within the first compiler the Cobol variables the Cobol program statements and optionally the comments within the Cobol source program. These internal tables are then examined during subsequent passes of the first compiler to determine and organize the desired functionality the desired Cobol variables and their data types and other such information as is standard in a computer program compiler. Once these internal tables are completed the functionality and flow of the Cobol source program can be understood and analyzed further by the compiler.

Typically in a standard way the compiler generates an executable program file that includes machine code or assembly language instructions which implement the desired Cobol program functionality including initialization and preparation of the data structures. Providing support for many different hardware platforms and operating system software platforms however may require significant development and verification when this approach is used.

It is noted that in the OpenMP standard a region of code is defined within the standard as all code encountered during a specific instance of the execution of a given OpenMP construct or library routine. A region includes any code in called routines as well as any implicit code introduced by the OpenMP implementation .

Another approach of the prior art for providing compilation of a Cobol program is illustrated in . This prior art method provides for generation of an executable program using two distinct phases of processing. The first phase provides for compilation by a first compiler to translate a program from a first language into a second language instead of outputting of machine code or assembly language . Then the computer program in the second language is fed into a second compiler which supports understands the second language to produce an output executable. That is a first compiler produces a second computer program in a second language instead of an executable with the second computer program describing the functionality of the Cobol program in that different or second computer programming language. This second language is then compiled by a second compiler to produce in a standard way an output executable. This output executable from the second compiler will perform functionally as described by the programmer in the original Cobol source program even if the second compiler did not provide support for input in the first language of Cobol. This approach to translation of a Cobol source file to a second source file the second source file being in an intermediate language followed by compilation of that second source file with a second compiler to produce an output executable has been described and implemented in an open source compiler from the organization OpenCobol.org. OpenCobol.org offers a compiler that translates Cobol to C or C . The OpenCobol compiler is used to read in a Cobol source program and perform a translation to C which is written to an intermediate output file. The intermediate output file is then provided as input to a second compiler which is typically a standard C compiler such as GCC GNU Compiler . The second compiler reads and compiles the C language description in the intermediate file and generates either an output executable or an object file that can be used to build an executable. The output executable performs the functions described in the original Cobol source program. The approach used by OpenCobol.org in their OpenCobol compiler is described on the OpenCobol.org website as follows 

The standard language translation approach as implemented by OpenCobol.org shown in does not however provide any support for parallel programming and in fact generates intermediate C code that is not suited for the addition of parallel programming constructs or directives even by hand in the intermediate output.

In the translation approach of OpenCobol.org and computer language translation approaches of the prior art assumptions are made for ease of programming and techniques of translation are chosen which expedite implementation of the translator and or efficiency of the generated code. These approaches and assumptions typically result in a translated output that is not suitable for the addition or inclusion of parallelization constructs even if attempted by hand because the translated code although functionally operative and correct is not expressed in a form to which parallelization constructs can be applied. The problems posed in trying to adapt a translator of the prior art for an application enabling parallel programming are not readily apparent until an attempt is made to use the intermediate code and to try to accomplish parallelization.

As a first example it can be observed using the OpenCobol.org compiler that variables in the original Cobol program are translated to variable names which are unrelated to the original Cobol variable names. For example Cobol variables total amount final value and balance may be translated to C variables such as a5 a6 and a7 respectively. This does not affect the functionality of the executable output because the internal variable names used in describing an application program or any computer program in Cobol or any other language are typically invisible to the actual user of that application program. However parallelization oftentimes requires detailed study and analysis of the variables within a program both during a first step of designing and describing proposed parallelization and also in debugging an application in which parallelization may not be producing expected results. It is a significant improvement to provide variable names which are readily understood by the programmer with reference to the original Cobol variable names rather than creating and utilizing computer generated names which make little sense at first glance.

Continuing with a discussion of variables and variable names the word scope is typically used as a general term describing the visibility or accessibility to a variable in a program. For example an index variable in a program loop may or may not be visible outside the code of the loop itself. In attempting parallelization it is often important to analyze a variable s scope for example when multiple threads may either share or make private certain specified variables when the code referencing those variables is to be executed by multiple threads. Tools for analyzing variables by name are available one example being a tool called ThreadChecker available from Intel Corporation.

As a second example the Cobol language typically provides for variable types which exist statically in memory. That is Cobol variables which are visible only inside a subroutine are typically not created on entry to the subroutine and then released upon exit from the subroutine. This simplistic approach is both good and bad in that it may require more memory to persist or always keep static variables in memory but less time is taken in creating and releasing variables on a memory stack. With modern hardware memory stacks are often accommodated quite efficiently with hardware support for a stack approach so the benefits or disadvantages of not utilizing a stack are not necessarily predictable it depends on the specifics of the program itself. For parallelization a stack approach may be preferable because variables that are used only within a parallelized region can be created as threads are created and these variables are then automatically isolated from each other between threads . Standard translation of Cobol to C as in the manner of OpenCobol does not provide for this alteration in variable scope and or type.

As a third example variables in Cobol which are independently named may be translated into variables which are simply references to locations in memory or an array in memory. For example Cobol variables X Y and Z may be translated to references to array locations ARRINT 122 ARRINT 125 and ARRINT 321 . This choice prevents a programmer from choosing parallelization which keeps X in static memory for example and which would put Y in private stacked memory because the C programming language does not allow one location in an array to be defined with a different memory management type than another location in the same array.

A fourth example regards optimization typically done by standard compilers to provide for more efficient faster execution. Optimization by a compiler may combine the processing of several statements into one piece of generated machine code. Optimization may also move code in and out of loops if the compiler optimizer decides that is both beneficial and still correct. There are many types of optimization. For parallelism to succeed however optimization cannot be applied across the boundaries defined for parallelization. For example initialization of a variable which is described inside a PERFORM block of Cobol code might be moved outside the PERFORM block and done instead just prior to entering the PERFORM code if the compiler determines that will still result in correct operation. However when parallelized it might be a requirement for correct operation to retain initialization within every thread of execution utilized in parallelizing a PERFORM statement. Therefore the translator should be prevented from making certain optimizations which cross parallelization boundaries.

A fifth example is the choice of constructs chosen for use in the translation of Cobol source code to another language. For example a PERFORM VARYING construct in Cobol might in the prior art be translated correctly to C code which might implement the checking for completion of the loop using a C WHILE construct. However although functionally correct a C WHILE construct is not supported for parallelization by OpenMP. Another approach may be to break down a PERFORM statement into a more primitive faun in a second language and express the functionality of the PERFORM using simple compute statements and IF statements. For example a PERFORM n TIMES in Cobol could be translated into a series of statements in the C C language such as 

Another more complex example is illustrated with the Cobol same PERFORM n TIMES construct. This construct causes looping of the code a specified number n times. Outside the loop and typically just prior to the loop variables which vary with each pass through the looping code are initialized and then within the loop typically at the beginning or end of the loop these variables are modified. When a construct such as this is parallelized the code for determining the value of a variable during each pass through the loop is required to be based upon a variable which is related to the pass number for the loop. This may require that a variable be created by the translation program that does not exist within the original Cobol source and that created variable is used as the basis for determining the value of variables as passes are made through the code by each of a plurality of threads.

Therefore in order for parallelization to be successful a translation approach is utilized which implements a COBOL PERFORM n TIMES using the C C construct of a C C FOR loop.

Often it may also be true that it is not until the details of proposed parallelization are analyzed by a programmer that it can be decided precisely which approach to translation will provide the most benefit in terms of enabling parallelization. Therefore it is a further advantage in accomplishing parallelization if the programmer is provided with constructs to suggest a proper method of translation. These suggestions would probably be implemented as new pragmas for influencing the translation process. Of course other methods of providing these guidelines or suggestions to the translation process would be readily apparent to one skilled in the art.

The intermediate C C program is then given over for processing by a second compiler such as the Intel C C Compiler which provides for parallelization of programs using OpenMP. The Intel compiler then produces as its output an Executable Program file which is an executable that provides for multiple threads of processing when that executable program is executed run . As mentioned previously the executable can also be in the form of an object file.

An alternative approach to achieving parallelization in another illustrated embodiment according to the teachings of the present invention is illustrated in . In this illustration parallelization is achieved by having the first stage Special Compiler analyze a Cobol Source Program and suggest parallelization regions that is regions where the special compiler suggests parallelization might be achievable based upon analysis of the Cobol program flow. The special compiler produces a C C intermediate Program which includes within it suggested OpenMP pragmas defining potential or suggested regions of parallelization within the C C program . The Special Compiler also optionally produces a report describing in more detail information related to each suggested region of the Parallelization Report . As indicated in block the programmer can then examine the C C intermediate Program and make the selection of parallelization regions for processing by marking that selection in a file . This file is then processed in a normal manner by the second compiler to build an output executable with parallelization. With this approach the special first compiler serves as an aid to the programmer in looking for and identifying potential regions for parallelization the special compiler basing its suggestions on analysis of the Cobol program statements and variable declarations.

In it can be seen that the prior art compiler generates a while loop i.e. shown in reference line . This while loop could not be parallelized because OpenMP does not support the while construct.

It can be seen also that an IF statement i.e. shown in reference line is used to evaluate the looping variable for exit from the loop. This manner of loop control is also not supported by OpenMP.

It can also be observed that the variable names within the code designated as reference line are not related to the variable names used in the Cobol program of . Further some variables are provided as pointer variables or intermediate pointer variables i.e. shown in reference line . These constructs are not easily maintained in implementing parallelization using OpenMP.

It is also noted that the translation illustrated in does not provide a human predictable translation of variable names so that parallelization directives which relate to variables specified by Cobol variable names can be easily applied to the C C code in the generated code.

with the result that the C program is in a form suitable for successful application of parallelization directives by a second compiler. corresponds to a C translation based upon the Cobol source code shown in . corresponds to a C translation based upon the Cobol source code shown in . corresponds to a C translation based upon the Cobol source code shown in . The entire program as exemplified in B and C however is typically read as a whole into the first compiler in order that the first compiler will have available to it knowledge of the overall program such as variable declaration types names and other such information as it is making a translation of the input Cobol source program in its entirety into a related C program with provision for parallelization.

In variable declaration statements in the C C programming language included in reference lines are shown which relate to the Working Storage Section of the Cobol source program. Tables A B and C are translated from Cobol form to a C STRUCT which contains within it these three tables in the same memory format as would be defined by a normal single pass Cobol compiler such as MicroFocus Cobol compiler . The variable names are translated in a human predictable manner as in this example from a name such as TABLE A in Cobol reference line into TABLE TABLE A in C reference line . In similar manner a BINARY type variable in Cobol is translated from I BUMP reference line into I BUMP in the C code reference line . The level or scope of the variables declared in the C code may be or are dependent on the parallelization directives in the original Cobol source program.

In and B executable C program code of reference lines is illustrated as being produced by translation of the Procedure Division of the original C program in a manner supportive of the application of parallelization directives shown for exemplary purposes as being translated into OpenMP style parallelization pragmas.

Within and C inserted parallelization directives reference lines are shown illustrating Cobol parallelization directives which are translated by the first compiler into related illustrative OpenMP parallelization directives reference lines respectively which are in the form of pragmas. In the manner and style of OpenMP for C according to the teachings of the present invention Cobol parallelization directives have been defined which are translated by the first compiler into OpenMP pragmas and the program code is further translated by a second compiler in a manner that supports the application of the OpenMP pragmas. Within reference line illustrates a Cobol parallelization directive expressed in Cobol comment form pragma which is then translated in a related way into an OpenMP pragma as shown in reference lines in . In similar manner reference lines and in are translated in a related way into OpenMP pragmas as shown in reference lines and respectively in .

It will be noted that the executable C code as shown in reference lines and in are C FOR statements expressed in a form suitable for application of the preceding OpenMP Pragma statements in reference lines and respectively. Note also that the paired braces . . . surrounding the C code of each FOR loop on reference lines and in correspond to the regions of code defined by the corresponding PERFORM and END PERFORM statements in the original Cobol source code to which the parallelization directives have been applied.

A User typically a programmer selects for inclusion further processing via for example a workstation or terminal device one or more of the regions of potential parallelization. The selection might be made by deleting or commenting out parallelization directives that are not selected or selection might be made in many ways readily apparent as could be easily determined by one skilled in the art of programming.

After the selection has been completed a C C program file which includes the selected pragmas presented in a manner so that they will be processed is applied as input to a standard compiler such as the GCC or Intel compiler . This compiler includes the requisite support for generating an executable program that provides for multiple threads of processing within the executable code achieving the goal to improve performance of the program over the performance that which would be achieved without parallelism or without multiple threads of processing . The various files of the overall compilation process are stored on a file storage device s such as a disk drive which are accessed typically through a CPU I O System . The overall computer system which includes memory the I O system file storage space and other hardware can then be used to run or execute the resulting executable program. The executable program could also be moved to another computer system for execution or processing. In order to gain significant benefit in performance CPU hardware which includes multiple cores is best suited in performing the processing although improvement with multiple threads might even be possible running on a machine having a single processing unit.

The C C program which includes the pragmas is then presented as input to a standard compiler such as the GCC or Intel compiler . This compiler includes the requisite support for generating an executable program that provides for multiple threads of processing within the executable code achieving the goal of improving performance of the program over that which would be achieved without parallelism or without using multiple threads of processing .

The various files of the overall compilation process are stored on a file storage device s such as a disk drive which are accessed typically through a CPU I O System . The overall computer system which includes memory the I O system file storage space and other hardware can then be used to run or execute the executable program. The executable program could also be moved to another computer system for execution or processing. In order to gain significant benefit in performance CPU hardware which includes multiple cores is best suited in performing the processing although improvement with multiple threads might even be possible when run on a machine having a single processing unit.

Considering in greater detail it is seen that a Cobol Source Program is annotated by a user typically a programmer to form an Annotated Cobol Source Program . The Annotated Cobol Source Program includes both the original Cobol Source Program code and designations of potential regions for parallelization within the Cobol program . This Annotated Cobol Source Program is then translated by a special first compiler which is another form of a special compiler translator program into a C C program intermediate computer program in a second computer programming language . The translation is performed so that in whatever regions identified as a potential region for parallelization the annotated Cobol program is translated so that parallelization directives can be applied to at least those related regions of the intermediate computer program. If analysis by the translator program determined that this was not possible an error message could be issued by the translator program as described above.

Then in the same manner as described in connection with the intermediate C C program including the defined regions for parallelization is run through the Intel or GCC C C Compiler producing a multithreaded program for execution on the computer system that includes a CPU I O System multiple cores for processing and the appropriate files stored on a disk subsystem .

The techniques described above for providing improvements in parallelization and other techniques which may be defined by those skilled in the art are not necessarily all that is required to achieve any parallelization but by combining a plurality of techniques according to the teachings of the present invention improves the likeliness of success that is the goal of achieving higher performance.

As a further example of the above the ordering of the program statements in the second language is also important. Compilers oftentimes move or change the order of generated code to provide for efficiencies in execution or other reasons. When contemplating parallelization it is important that the generated code in the second language be divided and ordered in a predictable way so that the second compiler can apply parallelization without destroying or affecting the overall functionality of the program. Some optimization can be done by the first compiler but overall program flow between Cobol paragraphs is best maintained for success in parallelization. That is statements can be combined or re ordered when it makes no difference in the resulting functionality relative to any entry points into a procedure but re ordering should not be done across boundaries in the program which are subject to change when parallelization is being considered or implemented.

Describing parallelization in a manner that makes the description available to the second compiler also requires special techniques. In the prior art parallelization is often described to a compiler using what are called pragmas as previously indicated. Pragmas are comments that are optionally interpreted by the compiler which may describe constructs and information not generally provided in the standard computer language. The OpenMP language is based upon the use of pragmas these pragmas providing for normal single thread compilation if the pragmas are ignored and providing for parallelism or multi thread operation in the executable when they are considered by the compiler. Some compilers may choose to ignore some pragmas while providing support for other pragmas.

In providing a two stage approach which supports parallelization according to the teachings of the present invention an improvement results by providing for processing of the pragmas in the source files of the first language Cobol as they are being translated into the second language. First provision must be made for passing any comments at all from the source files of the Cobol program to the intermediate form. Normally or typically comments are ignored by translation programs. That is comments are simply discarded meaning they are left completely out of the translated code or they might be maintained in basically the same form as in the original source files. For parallelization to be successful it is an improvement to provide at least some recognition and processing of comments in the original Cobol source especially those which can be recognized as being related to parallelization or those which are actual parallelization pragmas .

For example pragmas may reference variable names the variable names possibly being altered as the translation is made from the first language to the second language. In the prior art pragmas which are typically just comments might be ignored discarded or left in original form. Providing improved support for parallelization however suggests that any variable names in the pragmas be translated into variable names in the second language in the same manner as variable names are translated in the normal source of the program. In other words it is an improvement to have the first compiler actually translate comment statements pragmas in the same manner that the normal program statements are translated.

It is also a further improvement to maintain the order of comments especially those comments recognized as relating to parallelization relative to the normal Cobol source statements. That is for example it is beneficial to maintain a comment statement that describes the next line of the Cobol program as being a parallelizable construct such as a potential FOR loop in the C language in the same relative location as in the translated intermediate fowl in order to provide that parallelization description properly to the second compiler.

Thus while the principles of the invention have now been made clear and described relative to a number of illustrative embodiments or implementations it will be immediately obvious to those skilled in the art the many modifications or adaptations which can be made without departing from those principles. While the invention has been shown and described with reference to specific illustrated embodiments it should be understood by those skilled in the art that various changes in form and detail may be made such implementations without departing from the spirit and scope of the invention as defined by the following claims.

Having described the preferred embodiments of the invention it will now become apparent to one of skill in the arts that other embodiments or implementations incorporating the teachings of the present invention may be used. Accordingly these embodiments should not be limited to the disclosed embodiments or implementations but rather should be limited only by the spirit and scope of the following claims.

