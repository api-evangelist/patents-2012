---

title: Using separate processes to handle short-lived and long-lived jobs to reduce failure of processes
abstract: A method, system and computer program product for reducing the failure of processes. After a job is received, a determination is made as whether the received job is a “short-lived job” or a “long-lived job.” A short-lived job refers to a job who accomplishes a given task in less than a threshold period of time. A long-lived job refers to a job who accomplishes a given task in greater than a threshold period of time. For an identified long-lived job, the long-lived job is executed on a single process apart from other processes; whereas, the short-lived job is executed on at least one process separate from the processes executing long-lived jobs. As a result of executing the long-lived jobs on separate processes from the short-lived jobs, the likelihood of having a process fail is lessened since the duration of time that the process is running will be lessened.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043644&OS=09043644&RS=09043644
owner: International Business Machines Corporation
number: 09043644
owner_city: Armonk
owner_country: US
publication_date: 20121204
---
The present invention relates to processes in a computing system and more particularly to using separate processes to handle short lived and long lived jobs to improve stability of the system.

A process is an instance of a computer program that is being executed. That is a computer program is a passive collection of instructions and a process is the actual execution of those instructions. Depending on the operating system a process may be made up of multiple threads of execution that execute instructions concurrently.

A process may fail for a variety of reasons. For example there may be a software bug in the software running or in the underlying middleware or kernel software. A software bug is an error flow mistake failure or fault in a computer program or system that produces an incorrect or unexpected result or causes it to behave in unintended ways.

A process may be designed to handle many types of jobs where a job refers to a set of functions that need to be completed in order to accomplish a given task e.g. deploying a new instance of a virtual machine . If a process runs multiple jobs then a software bug in one of the jobs may result in the entire process failing thereby causing the other jobs executing on the process to fail. Furthermore a process that runs multiple jobs is more likely to run for an extended period of time thereby preventing the process from being recycled i.e. stopped and restarted which increases the chances of a process failure occurring.

As a result running multiple jobs in the same process may increase the chances in the failure of both the process and the jobs executing on the process.

In one embodiment of the present invention a method for reducing the failure of processes comprises identifying a first job as being a short lived job where a time duration of the short lived job to be completed is less than a first threshold period of time. The method further comprises identifying a second job being a first long lived job where a time duration of the first long lived job to be completed is greater than the first threshold period of time. Additionally the method comprises executing the first long lived job on a first process. In addition the method comprises executing by a processor the short lived job on at least one process separated from the first process executing the first long lived job.

Other forms of the embodiment of the method described above are in a system and in a computer program product.

The foregoing has outlined rather generally the features and technical advantages of one or more embodiments of the present invention in order that the detailed description of the present invention that follows may be better understood. Additional features and advantages of the present invention will be described hereinafter which may form the subject of the claims of the present invention.

The present invention comprises a method system and computer program product for reducing the failure of processes. In one embodiment of the present invention after a job is received a determination is made as whether the received job is a short lived job or a long lived job. A short lived job refers to a job whose set of functions that need to be completed to accomplish a given task takes less than a threshold period of time. A long lived job refers to a job whose set of functions that need to be completed to accomplish a given task takes greater than a threshold period of time. For an identified long lived job the long lived job is executed on a single process apart from other processes. For an identified short lived job the short lived job is executed on at least one process separate from the processes executing long lived jobs. As a result of executing the long lived jobs on separate processes thereby separating the short lived jobs from the long lived jobs the likelihood of having a process fail is lessened since the duration of time that the process is running will be lessened. In addition by having a single long lived job execute on a single process the process can be recycled more quickly i.e. stopped and restarted thereby lessening the chances of a failure in the process. Furthermore by having the long lived jobs execute on separate processes the failure of a process will only affect the single job being executed on the process and will not affect the other jobs executing on the other processes.

In the following description numerous specific details are set forth to provide a thorough understanding of the present invention. However it will be apparent to those skilled in the art that the present invention may be practiced without such specific details. In other instances well known circuits have been shown in block diagram form in order not to obscure the present invention in unnecessary detail. For the most part details considering timing considerations and the like have been omitted inasmuch as such details are not necessary to obtain a complete understanding of the present invention and are within the skills of persons of ordinary skill in the relevant art.

It is understood in advance that although this disclosure includes a detailed description on cloud computing implementation of the teachings recited herein are not limited to a cloud computing environment. Rather the embodiments of the present invention are capable of being implemented in conjunction with any type of clustered computing environment now known or later developed.

In any event the following definitions have been derived from the The NIST Definition of Cloud Computing by Peter Mell and Timothy Grance dated September 2011 which is cited on an Information Disclosure Statement filed herewith and a copy of which is provided to the U.S. Patent and Trademark Office.

Cloud computing is a model for enabling ubiquitous convenient on demand network access to a shared pool of configurable computing resources e.g. networks servers storage applications and services that can be rapidly provisioned and released with minimal management effort or service provider interaction. This cloud model is composed of five essential characteristics three service models and four deployment models.

On Demand Self Service A consumer can unilaterally provision computing capabilities such as server time and network storage as needed automatically without requiring human interaction with each service s provider.

Broad Network Access Capabilities are available over a network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms e.g. mobile phones tablets laptops and workstations .

Resource Pooling The provider s computing resources are pooled to serve multiple consumers using a multi tenant model with different physical and virtual resources dynamically assigned and reassigned according to consumer demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction e.g. country state or data center . Examples of resources include storage processing memory and network bandwidth.

Rapid Elasticity Capabilities can be elastically provisioned and released in some cases automatically to scale rapidly outward and inward commensurate with demand. To the consumer the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.

Measured Service Cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service e.g. storage processing bandwidth and active user accounts . Resource usage can be monitored controlled and reported providing transparency for both the provider and consumer of the utilized service.

Software as a Service SaaS The capability provided to the consumer is to use the provider s applications running on a cloud infrastructure. The applications are accessible from various client devices through either a thin client interface such as a web browser e.g. web based e mail or a program interface. The consumer does not manage or control the underlying cloud infrastructure including network servers operating systems storage or even individual application capabilities with the possible exception of limited user specific application configuration settings.

Platform as a Service PaaS The capability provided to the consumer is to deploy onto the cloud infrastructure consumer created or acquired applications created using programming languages libraries services and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including networks servers operating systems or storage but has control over the deployed applications and possibly configuration settings for the application hosting environment.

Infrastructure as a Service IaaS The capability provided to the consumer is to provision processing storage networks and other fundamental computing resources where the consumer is able to deploy and run arbitrary software which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems storage and deployed applications and possibly limited control of select networking components e.g. host firewalls .

Private Cloud The cloud infrastructure is provisioned for exclusive use by a single organization comprising multiple consumers e.g. business units . It may be owned managed and operated by the organization a third party or some combination of them and it may exist on or off premises.

Community Cloud The cloud infrastructure is provisioned for exclusive use by a specific community of consumers from organizations that have shared concerns e.g. mission security requirements policy and compliance considerations . It may be owned managed and operated by one or more of the organizations in the community a third party or some combination of them and it may exist on or off premises.

Public Cloud The cloud infrastructure is provisioned for open use by the general public. It may be owned managed and operated by a business academic or government organization or some combination of them. It exists on the premises of the cloud provider.

Hybrid Cloud The cloud infrastructure is a composition of two or more distinct cloud infrastructures private community or public that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability e.g. cloud bursting for load balancing between clouds .

Referring now to the Figures in detail illustrates a network system configured in accordance with an embodiment of the present invention. Network system includes a client device connected to a cloud computing environment via a network . Client device may be any type of computing device e.g. portable computing unit personal digital assistant PDA smartphone laptop computer mobile phone navigation device game console desktop computer system workstation Internet appliance and the like configured with the capability of connecting to cloud computing environment via network .

Network may be for example a local area network a wide area network a wireless wide area network a circuit switched telephone network a Global System for Mobile Communications GSM network Wireless Application Protocol WAP network a WiFi network an IEEE 802.11 standards network various combinations thereof etc. Other networks whose descriptions are omitted here for brevity may also be used in conjunction with system of without departing from the scope of the present invention.

Cloud computing environment is used to deliver computing as a service to client device implementing the model discussed above. An embodiment of cloud computing environment is discussed below in connection with .

It is understood that the types of computing devices shown in which may represent client device of are intended to be illustrative and that cloud computing nodes and cloud computing environment can communicate with any type of computerized device over any type of network and or network addressable connection e.g. using a web browser . Program code located on one of nodes may be stored on a computer recordable storage medium in one of nodes and downloaded to computing devices over a network for use in these computing devices. For example a server computer in computing nodes may store program code on a computer readable storage medium on the server computer. The server computer may download the program code to computing device for use on the computing device.

Referring now to illustrates a schematic of a rack of compute nodes e.g. servers of cloud computing node s that are managed by an administrative server in accordance with an embodiment of the present invention.

As shown cloud computing node s also may be referred to as a cluster may include a rack of hardware components or compute nodes such as servers or other electronic devices. For example rack houses compute nodes A E. Compute nodes A E may collectively or individually be referred to as compute nodes or compute node respectively. An illustrative virtualization environment for compute node is discussed further below in connection with . is not to be limited in scope to the number of racks or compute nodes depicted. For example cloud computing node may be comprised of any number of racks which may house any number of compute nodes . Furthermore while illustrates rack housing compute nodes rack may house any type of computing component that is used by cloud computing node . Furthermore while the following discusses compute nodes being confined in a designated rack it is noted for clarity that compute nodes may be distributed across cloud computing environment .

As further shown in rack is coupled to an administrative server configured to provide data center level functions. Administrative server supports a module referred to herein as the management software that can be used to manage all the compute nodes of cloud computing nodes monitor system utilization intelligently deploy images of data and optimize the operations of cloud computing environment . Furthermore management software can be used to identify jobs as being short lived jobs and long lived jobs as well as to use separate processes to handle short lived jobs and long lived jobs so as to reduce the likelihood of a failure of a process as discussed further below. A description of the hardware configuration of administrative server is provided further below in connection with .

Referring now to illustrates a virtualization environment for compute node in accordance with an embodiment of the present invention. Compute node includes a virtual operating system . Operating system executes on a real or physical computer . Real computer includes one or more processors a memory also referred to herein as the host physical memory one or more disk drives and the like. Other components of real computer are not discussed herein for the sake of brevity.

Virtual operating system further includes user portions A B identified as Guest 1 and Guest 2 respectively in referred to herein as guests. Each guest A B is capable of functioning as a separate system. That is each guest A B can be independently reset host a guest operating system A B respectively identified as Guest 1 O S and Guest 2 O S respectively in and operate with different programs. An operating system or application program running in guest A B appears to have access to a full and complete system but in reality only a portion of it is available. Guests A B may collectively or individually be referred to as guests or guest respectively. Guest operating systems A B may collectively or individually be referred to as guest operating systems or guest operating system respectively.

Each guest operating system A B may host one or more virtual machine applications A C identified as VM 1 VM 2 and VM 3 respectively in such as Java virtual machines. For example guest operating system A hosts virtual machine applications A B. Guest operating system B hosts virtual machine application C. Virtual machines A C may collectively or individually be referred to as virtual machines or virtual machine respectively.

Virtual operating system further includes a common base portion referred to herein as a hypervisor. Hypervisor may be implemented in microcode running on processor or it may be implemented in software as part of virtual operating system . Hypervisor is configured to manage and enable guests to run on a single host.

As discussed above virtual operating system and its components execute on physical or real computer . These software components may be loaded into memory for execution by processor .

The virtualization environment for compute node is not to be limited in scope to the elements depicted in . The virtualization environment for compute node may include other components that were not discussed herein for the sake of brevity.

Referring now to illustrates a hardware configuration of administrative server which is representative of a hardware environment for practicing the present invention. Administrative server has a processor coupled to various other components by system bus . An operating system runs on processor and provides control and coordinates the functions of the various components of . An application in accordance with the principles of the present invention runs in conjunction with operating system and provides calls to operating system where the calls implement the various functions or services to be performed by application . Application may include for example a program for reducing the failure of processes by using separate processes to handle short lived jobs and long lived jobs as discussed further below in association with A B and .

Referring again to read only memory ROM is coupled to system bus and includes a basic input output system BIOS that controls certain basic functions of administrative server . Random access memory RAM and disk adapter are also coupled to system bus . It should be noted that software components including operating system and application may be loaded into RAM which may be administrative server s main memory for execution. Disk adapter may be an integrated drive electronics IDE adapter that communicates with a disk unit e.g. disk drive. It is noted that the program for reducing the failure of processes by using separate processes to handle short lived jobs and long lived jobs as discussed further below in association with A B and may reside in disk unit or in application .

Administrative server may further include a communications adapter coupled to bus . Communications adapter interconnects bus with an outside network e.g. network of .

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or flash memory a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the present invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the function acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the function acts specified in the flowchart and or block diagram block or blocks.

As stated in the Background section a process may be designed to handle many types of jobs where a job refers to a set of functions that need to be completed in order to accomplish a given task e.g. deploying a new instance of a virtual machine . If a process runs multiple jobs then a software bug in one of the jobs may result in the entire process failing thereby causing the other jobs executing on the process to fail. Furthermore a process that runs multiple jobs is more likely to run for an extended period of time thereby preventing the process from being recycled i.e. stopped and restarted which increases the chances of a process failure occurring. As a result running multiple jobs in the same process may increase the chances in the failure of both the process and the jobs executing on the process.

The principles of the present invention provide a means for reducing the failure of processes by using separate processes to handle short lived jobs and long lived jobs as discussed further below in connection with A B and . illustrates the software components used in reducing the failure of processes. are a flowchart of a method for reducing the failure of processes. is a flowchart of a method for monitoring long lived jobs. is a flowchart of a method for handling the failure of a job manager. is a flowchart of an alternative method for handling the failure of a job manager.

Referring now to as stated above is a diagram of the software components used in reducing the failure of processes in accordance with an embodiment of the present invention. In one embodiment these software components may reside in application .

The following provides a brief description of these software components. A more detailed description of these software components is provided below in conjunction with and where their functionalities are discussed in connection with the method for reducing the failure of processes the method for monitoring long lived jobs and the methods for handling the failure of a job manager.

The software components used in reducing the failure of processes includes a job engine configured to handle short lived jobs and long lived jobs. A short lived job refers to a job whose set of functions that need to be completed to accomplish a given task takes less than a threshold period of time. A long lived job refers to a job whose set of functions that need to be completed to accomplish a given task takes greater than a threshold period of time.

In one embodiment the long lived jobs are executed on separate processes as discussed further below in connection with . As a result of executing the long lived jobs on separate processes the likelihood of having a process fail is lessened since the duration of time that the process is running will be lessened. Furthermore by having the long lived jobs being executed on separate processes the failure of a process will only affect the single job being executed on the process and will not affect the other jobs executing on the other processes.

As illustrated in job engine includes a job manager A B job manager A is identified as job manager and job manager B is identified as job manager in . Job managers A B may collectively or individually be referred to as job managers or job manager respectively. In one embodiment job manager is configured to monitor the long lived jobs to ensure they do not hang. In one embodiment job manager is configured to monitor a heartbeat message from the long lived jobs to ensure they do not hang. In one embodiment long lived jobs periodically send heartbeat messages to job manager to indicate they are still executing. If job manager does not receive a heartbeat message within a threshold period of time the process in which the long lived job was executing is terminated by job manager as discussed in further detail below in connection with .

Each job manager A B may include a queue A B respectively configured to hold long lived jobs to be executed. Queues A B may collectively or individually be referred to as queues or queue respectively.

Furthermore in one embodiment job manager may be a long lived job itself and may fail. As a result if job manager has failed job manager may be restarted by a job manager restarter . Once restarted the restarted job manager will discover any running long lived jobs that are still executing and job manager will then begin its normal processing.

A method for reducing the failure of processes using the software components of will now be discussed in connection with . are a flowchart of a method for reducing the failure of processes in accordance with an embodiment of the present invention.

In step a determination is made by job engine as to whether the received job is a short lived job or a long lived job. As stated above if the time for the job to complete its task is less than a threshold period of time then the job is deemed to be short lived. If however the time for the job to complete its task is greater than a threshold period of time then the job is deemed to be long lived. 

If the duration of time to complete the task of the job exceeds the threshold period of time then in step job engine identifies a long lived job. If however the duration of time to complete the task of the job does not exceed the threshold period of time then in step job engine identifies a short lived job.

Upon identifying a short lived job job engine in step executes the short lived job on at least one process separate from the processes executing long lived jobs. By executing short lived jobs separate from long lived jobs the likelihood of having a process fail is lessened since the duration of time that the process is running will be lessened.

In step a determination is made by the short lived job as to whether the time to complete a segment of work in the short lived job is expected to exceed a threshold period of time. If the time to complete a segment of work in the short lived job is expected to exceed a threshold period of time then in step the short lived job creates a long lived job to perform the task. In step job engine returns the short lived job to the user. For example each REpresentational State Transfer REST Application Programming Interface API call that is received by management software creates a short lived job that runs on a thread within the process to which the request is sent. If the short lived job determines that a segment of its work e.g. deploying a new instance of a virtual machine needs a greater time than a threshold period of time to complete then the short lived job creates a long lived job to perform that task. The short lived job then returns to the user with a Hypertext Transfer Protocol HTTP status code accepted and a Uniform Resource Identifier URI that may be used to query the status of the long lived job that will perform the work. In one embodiment the user may query the status of the long lived job using this URI to determine when the job starts and whether it has completed successfully or has failed.

Referring to step if the time to complete a segment of work in the short lived job is not expected to exceed a threshold period of time then in step a determination is made by job engine as to whether the short lived job has completed its execution.

If the short lived job has not completed its execution then job engine continues to determine whether the short lived job has completed its execution in step .

If however the short lived job has completed its execution then in step a determination is made by job engine as to whether any other jobs are executing within the process. If there are other jobs executing within the process then the executing short lived job determines in step as to whether the time to complete a segment of work in the short lived job is expected to exceed a threshold period of time.

If however there are no other jobs executing within the process then in step job engine terminates the process. Upon terminating the process the process can later be restarted thereby recycling the process.

Referring to in conjunction with upon returning the short lived job to the user in step or upon identifying the long lived job in step in step job engine updates the status of the long lived job to pending. 

In step job engine adds the long lived job to queue of job manager for execution. In step job manager determines whether it is time to execute the queued long lived job.

If it is not time to execute the queued long lived job then job manager continues to determine whether it is time to execute the queued long lived job in step .

If however it is time to execute the queued long lived job then in step job manager removes the long lived job from queue . In step job manager instantiates a process in which the long lived job is to execute.

In step job manager executes the long lived job in the instantiated process. In step job manager updates the status of the long lived job to started from pending. 

In step a determination is made by job manager as to whether the long lived job has completed execution. If the long lived job has not completed execution then job manager continues to determine whether the long lived job has completed execution in step .

If however the long lived job has completed execution then in step job manager updates the status of the long lived job to either successful or failed depending on whether the job successfully completed its task or failed in completing its task. In step job manager terminates the process.

By having each long lived job execute on separate processes the likelihood of having a process fail such as by a memory leak is lessened since the duration of time that the process is running will be lessened. Furthermore by having the long lived jobs execute on separate processes the failure of a process will only affect the single job being executed on the process and will not affect the other jobs executing on the other processes. In addition by having a single long lived job execute on a single process the process can be recycled more quickly i.e. stopped and restarted thereby lessening the chances of a failure in the process.

In some implementations method may include other and or additional steps that for clarity are not depicted. Further in some implementations method may be executed in a different order presented and that the order presented in the discussion of is illustrative. Additionally in some implementations certain steps in method may be executed in a substantially simultaneous manner or may be omitted.

As discussed above job manager is configured to monitor long lived jobs to ensure they do not hang. A description of such a monitoring process is provided below in connection with .

Referring to in conjunction with and A B in step job manager monitors the long lived jobs executing on separate processes to ensure that the long lived jobs do not hang.

In step a determination is made for each long lived job monitored by job manager as to whether it received a heartbeat message from the long lived job within a threshold period of time. In one embodiment the long lived job periodically sends heartbeat messages to job manager to indicate they are still executing.

If job manager receives a heartbeat message from the long lived job within the threshold period of time then job manager continues to monitor the long lived job and determine whether it received a subsequent heartbeat message from the long lived job within a threshold period of time in step .

If however job manager does not receive a heartbeat message form the long lived job within the threshold period of time then in step job manager terminates the process in which the job was executing

In some implementations method may include other and or additional steps that for clarity are not depicted. Further in some implementations method may be executed in a different order presented and that the order presented in the discussion of is illustrative. Additionally in some implementations certain steps in method may be executed in a substantially simultaneous manner or may be omitted.

As discussed above job manager may itself be a long lived job and fail. A description of handling the failure of job manager is provided below in connection with .

Referring to in conjunction with and A B in step a determination is made by job manager restarter as to whether job manager has failed. If job manager has not failed then job manager restarter continues to determine whether job manager has failed in step .

If however job manager has failed then in step job manager restarter restarts the failed job manager . The restarted job manager will then discover any running long lived jobs that are still executing and begin its normal processing in monitoring those long lived jobs to ensure they do not hang.

In some implementations method may include other and or additional steps that for clarity are not depicted. Further in some implementations method may be executed in a different order presented and that the order presented in the discussion of is illustrative. Additionally in some implementations certain steps in method may be executed in a substantially simultaneous manner or may be omitted.

Another embodiment for handling the failure of job manager involves the situation where two job managers e.g. job managers A B of are both running in a mode referred to herein as the active active mode as discussed below in connection with . In such an embodiment the long lived jobs will have the ability to send heartbeat messages to either of the job managers in case it loses connectivity to one of the job managers but wants to continue running.

Referring to in conjunction with and A B in step a determination is made by job manager restarter as to whether job manager has failed. If job manager has not failed then job manager restarter continues to determine whether job manager has failed in step .

If however job manager e.g. job manager A has failed then in step job manager restarter provides for the other job manager e.g. job manager B to take over monitoring jobs the failed job manager e.g. job manager A was responsible for monitoring.

While the foregoing discusses the use of two job managers running in an active active mode any number of job managers may be running to monitor long lived jobs to ensure they do not hang thereby providing higher availability in case one of the job managers failed. For example if three job managers are running in active mode then the jobs monitored by the failed job manager may be taken over by the remaining two job managers still running.

In some implementations method may include other and or additional steps that for clarity are not depicted. Further in some implementations method may be executed in a different order presented and that the order presented in the discussion of is illustrative. Additionally in some implementations certain steps in method may be executed in a substantially simultaneous manner or may be omitted.

The descriptions of the various embodiments of the present invention have been presented for purposes of illustration but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to best explain the principles of the embodiments the practical application or technical improvement over technologies found in the marketplace or to enable others of ordinary skill in the art to understand the embodiments disclosed herein.

