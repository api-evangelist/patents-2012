---

title: Opportunistic, priority-based object synchronization
abstract: Mechanisms for synchronizing an object set with a remote data store are often performed at a particular frequency, e.g., once per hour or day. However, the objects of the object set may have different priorities, and it may be advantageous to synchronize higher-priority objects more often than regular-priority objects. The synchronization mechanisms may also differ (e.g., high-priority object synchronization may be direct and/or holistic, while regular-priority object synchronization may be differential, cached, and/or involving version and/or conflict resolution). Additionally, a resource-based threshold may be applied to the high-priority objects (e.g., a bandwidth cap) in order to reduce resource exhaustion, and high-priority objects that are not synchronized within the threshold may be synchronized with the regular-priority objects. These techniques may be particularly advantageous for synchronizing objects comprising an application state of applications of current or recent usage by a user, where application state “staleness” is acutely visible to the user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09489440&OS=09489440&RS=09489440
owner: Microsoft Technology Licensing LLC
number: 09489440
owner_city: Redmond
owner_country: US
publication_date: 20121213
---
Within the field of computing many scenarios involve a synchronization of the objects of an object set between a local data store and a remote data store. The synchronization may be unidirectional e.g. altering the remote data store to match the local data store or vice versa or bidirectional e.g. merging changes in the remote data store and the local data store and or holistic e.g. copying entire objects from the local data store to the remote data store or differential e.g. copying deltas of the objects from the local data store to a remote device for application to the objects of the remote data store . Such scenarios may be performed with many variations such on a desired frequency throttled to conserve bandwidth and with various types of rules for resolving versioning conflicts.

For example a bidirectional synchronization may be performed by comparing each object in the local data store and the remote data store choosing the later updated of the compared objects and copying the later updated object over the earlier updated object. Each object of the object set may be synchronized in the same manner until the object sets are identical.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In many scenarios the synchronization of the object set may be performed without particular regard to the types of objects comprising the object set. For example a bidirectional synchronization may simply iterate through a sequence of objects irrespective of the order or types of the objects. If the object set is large this iterative synchronization may be protracted such that some object updates may take a while to propagate.

However in many such scenarios it may be desirable to perform the synchronization differently for different types of objects. In particular it may be desirable to synchronize high priority objects at a higher frequency than regular priority objects e.g. in order to propagate changes among the high priority objects between the local data store and the remote data store faster than for regular priority objects. One such scenario involves the synchronization of objects comprising an application state of an application that a user is currently or has recently used on one device and may continue using on another device. A delayed propagation of changes to the application state in a prompt manner may be more noticeable to the user than delays in propagating changes to objects that the user has not utilized in a while.

In view of these differences in object types presented herein are techniques for configuring a device to perform a priority based synchronization of an object set with a remote data store where regular priority objects are synchronized with the remote data store at a regular priority synchronization frequency while high priority objects as identified by various criteria are synchronized at a high priority synchronization frequency that is greater than the regular priority synchronization frequency. Moreover in order to avoid exhausting the resources of the device the high priority synchronization may be throttled e.g. by applying a bandwidth cap only during the high priority synchronization. High priority objects that are not synchronized during the high priority synchronization e.g. those for which synchronization may exceed the bandwidth cap may be synchronized during the regular priority synchronization. These techniques enable a tradeoff between more frequent synchronization of high priority objects and conservation of computing resources.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

Within the field of computing many scenarios involve a synchronization of an object set between a device and a remote data store. As a first example the object set may comprise a set of files and the device and remote data store may each store a copy of the file set and may interoperate to maintain synchrony therebetween. As a second example the object set may comprise a set of database records stored by both the device and a database server and the device and the database server may interoperate to propagates updates to one version of the database with the other version.

In these and other scenarios the device and the remote data store may perform many types of synchronization in order to maintain synchrony between the versions of the object set stored in each location. As a first example a unidirectional synchronization may be performed to propagate changes from the device to the remote object store e.g. the device may store the authoritative version of the object set and the synchronization may always endeavor to alter the remote object store to match the local device or vice versa. Alternatively a bidirectional synchronization may be performed wherein any object update on either the device or the remote data store is propagated to the other object set. For example in a simple bidirectional synchronization the device and remote data store may compare every object in the object set. Objects existing only in one of the object sets may be copied into the other object set and for objects existing in both object sets the modification dates may be compared the later modified version of the object may be copied over the earlier modified version of the object. More sophisticated bidirectional synchronization techniques may involve journaling e.g. wherein one or both of the device and the remote data store maintain a journal of updates as a more efficient technique for identifying differences between the object sets. As a second example the synchronization may be holistic e.g. where any object to be updated in one version of the object set is entirely copied from the other version of the object set or differential e.g. where an update of an object in one version of the object set is achieved by receiving and applying a diff or delta indicating how the old object is to be modified in order to match the new version of the object .

In addition to the synchronization frequency in view of the synchronization scenario the type of objects comprising the object set and the resources of the device and the remote data store many factors of the synchronization may vary. As a first such example the user may specify a variety of rules for identifying object updates e.g. by comparing the entire binary contents of each version of the object by comparing a hashcode computed for each version of the object by comparing the modification dates of the versions of the objects and or by consulting a journal stored by the device and or the remote data store . As a second such example the user may specify a variety of rules for performing version conflicts e.g. the manner of choosing the version of an object to be kept in case two versions of an object are found to differ . These and other properties may be altered to achieve various types of synchronization of the object set .

While the synchronization performed in the exemplary scenario of may succeed in maintaining synchrony of the object set between the device and the remote data store it may be appreciated that some aspects may present some disadvantages. For example the synchronization may be achieved by iterating over all of the objects of the object set in no particular order and performing the comparison and updating. However it may be appreciated that different objects may have different semantics such as different amounts of visibility in the staleness of an object on the device and or the remote data set . As one such example the device may comprise a set of applications and some objects may comprise the application state of an application. Moreover the user may apply the synchronization to achieve synchrony of the application states of the applications of the device and other devices that also synchronize with the remote data store e.g. a shared browser session that maintains a current set of web pages the states of the web pages and the contents of the cookie cache among two or more devices such that the user may continue interacting with the same set of web pages even while switching devices .

In such scenarios it may be desirable to maintain synchrony of the objects comprising the application state of the second application which is currently in use by the user than for other objects such as the application state of the first application that is not in use and of the music recordings of a music library . However if all of the objects are synchronized at a synchronization frequency that is generally selected for the object set e.g. synchronizing once per hour or once per day then the application state of the second application may appear to be frequently and or extensively stale on the device the remote data store and or other devices that also synchronize with the remote data store e.g. the other devices may present web browsers reflecting an outdated set of web pages and an outdated cookie cache . Conversely the synchronization frequency may be raised significantly in order to maintain an acceptable degree of staleness of the application state of the second application e.g. once every ten minutes but if such high frequency synchronization involves the entire object set the device and remote data store may expend considerable computational resources e.g. processor capacity bandwidth and battery or utility power performing an extensive comparison of many objects that have not changed thereby creating significant inefficiency.

It may be appreciated that this problem arises due to the insensitivity of the synchronization in the exemplary scenario of to distinguish among the objects based on priority e.g. distinguishing objects of a higher priority that are to be synchronized more frequently from objects of a regular priority that are to by synchronized less frequently. The synchronization may therefore be altered to identify the priorities of the objects and to synchronize different objects at different synchronization frequencies based on identified priorities. However synchronization involving a higher synchronization frequency may exhaust the resources of the device and or remote data store e.g. if the user is actively using the second application and the second application state is changing continuously the device may synchronize the object associated with the second application state with the remote data store very frequently e.g. once per minute which may present an inefficient utilization of computing resources as compared with the value to the user of constantly synchronized application state . Therefore in addition to considering the comparative priorities of the objects the device and or remote data store may be further adapted to perform a higher frequency synchronization opportunistically i.e. while the computing resources of the device and or remote data store that are involved in the synchronization e.g. processor capacity bandwidth and or power remain within an acceptable high priority data threshold. When this threshold is exceeded the high priority synchronization may be throttled back to the frequency of the regular priority synchronization. In this manner the synchronization may be adapted to achieve more frequent synchronization of higher priority objects while also conserving the computational resources of the device and or remote data store .

A fourth embodiment of the techniques presented herein may comprise an computer readable medium comprising processor executable instructions configured to apply the techniques presented herein. Such computer readable media may include e.g. computer readable storage media involving a tangible device such as a memory semiconductor e.g. a semiconductor utilizing static random access memory SRAM dynamic random access memory DRAM and or synchronous dynamic random access memory SDRAM technologies a platter of a hard disk drive a flash memory device or a magnetic or optical disc such as a CD R DVD R or floppy disc encoding a set of computer readable instructions that when executed by a processor of a device cause the device to implement the techniques presented herein. Such computer readable media may also include as a class of technologies that are distinct from computer readable storage media various types of communications media such as a signal that may be propagated through various physical phenomena e.g. an electromagnetic signal a sound wave signal or an optical signal and in various wired scenarios e.g. via an Ethernet or fiber optic cable and or wireless scenarios e.g. a wireless local area network WLAN such as WiFi a personal area network PAN such as Bluetooth or a cellular or radio network and which encodes a set of computer readable instructions that when executed by a processor of a device cause the device to implement the techniques presented herein.

An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the exemplary embodiment comprises a computer readable storage medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to the principles set forth herein. Some embodiments of this computer readable medium may comprise a computer readable storage medium e.g. a hard disk drive an optical disc or a flash memory device that is configured to store processor executable instructions configured in this manner. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

The techniques discussed herein may be devised with variations in many aspects and some variations may present additional advantages and or reduce disadvantages with respect to other variations of these and other techniques. Moreover some variations may be implemented in combination and some combinations may feature additional advantages and or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments to confer individual and or synergistic advantages upon such embodiments.

A first aspect that may vary among embodiments of these techniques relates to the scenarios wherein such techniques may be utilized.

As a first variation of this first aspect the techniques presented herein may be utilized with many types of devices such as servers server farms workstations laptops tablets mobile phones local storage devices such as hard disk drives game consoles and network appliances such as network attached storage NAS devices. Such devices may also provide a variety of computing components such as wired or wireless communications devices human input devices such as keyboards mice touchpads touch sensitive displays microphones and gesture based input components automated input devices such as still or motion cameras global positioning service GPS devices and other sensors output devices such as displays and speakers and communication devices such as wired and or wireless network components.

As a second variation of this first aspect the remote data store may also comprise many types of devices including those provided above with respect to the types of the device . The device and the remote data store may also comprise equivalent device types or different device types. The remote data store may also comprise a network based service provided by a file server an object server a database server or an email server. Such services may be provided via a local area network LAN such as a local WiFi or cellular network or a wide area network WAN such as a cloud service provided via the Internet. Additionally the device and the remote data store may interact in a client server relationship with the device operating as either the client or the server in a peer to peer relationship in a hybrid relationship or in a different type of relationship.

As a third variation of this first aspect the object set may comprise many types of objects such as files documents media objects application binaries database records email messages or mailboxes or interactive agents. The object set may also comprise a mixture of such object types e.g. a portion or entirety of the data comprising a computing environment of the device such as the files user profiles applications application settings and application state representations used by the device to present the computing environment to the user . Many such scenarios may advantageously utilize a variation of the techniques presented herein.

A second aspect that may vary among embodiments of these techniques involves the manner of identifying the priority of respective objects of the object set as a high priority or a regular priority .

As a first variation of this second aspect many criteria may be used to determine the priority of an object . For example this determination may be based on at least one prioritization criterion selected from a prioritization criteria set comprising an object type of the object a data access frequency of the object e.g. how frequently the user or an application accesses the object a data update frequency of the object e.g. how frequently the user or an application updates the object a data significance of the object e.g. an indication from a user or an application that an object is of high significance or regular significance a relationship with a second object of the object set e.g. a dependency relationship with a high priority object and a user preference of a user of the device e.g. an indication that the user wishes to have a particular object synchronized with a high frequency .

As a second variation of this second aspect the device may comprise a high priority object synchronization policy that identifies the objects to be regarded as high priority and regular priority . For example the high priority object synchronization policy may indicate that all objects associated with an application that is currently or has recently been invoked by the user optionally defining a utilization duration within which the application is regarded as recently utilized e.g. invoked by the user within the last hour is to be regarded as high priority and all other objects are to be regarded as regular priority . As another example the high priority object synchronization policy may also indicate that the priority determination is to be based on the role of the user associated with the object e.g. objects associated with a high ranking user may be synchronized at a higher frequency than those associated with lower ranking users .

As a third variation of this second aspect the device may perform the priority determination with many times of timing with respect to the synchronization . As a first such example the determination may be made on an ad hoc basis e.g. when the time arrives to synchronize a particular object the object may be identified as either high priority or regular priority . As a second such example the determination may be made in advance. For example the device may periodically or continuously evaluate the objects to determine the priority thereof and may associate high priority objects with a high priority object identifier e.g. setting a priority metadata bit in a file system entry of a file system associated with the object . This determination may be altered or updated in response to particular events e.g. clearing the priority metadata bit of an object that is unused for particular duration or setting the priority metadata bit of an object upon a user interaction with the object . At the time of synchronization the device may then perform the priority determination simply by determining whether or not the object is associated with a high priority object identifier. By persisting and reusing determinations made before the synchronization this variation may expedite the synchronization by utilizing precomputed metadata rather than performing the determination anew for each object . Many such variations in the priority determination of the objects may be included in various embodiments of the techniques presented herein.

A third aspect that may vary among embodiments of these techniques relates to the manner of synchronizing the objects of the object set between a device and a remote data store .

As a first variation of this third aspect the high priority objects and the regular priority objects may be synchronized in different ways. As a first such example the high priority objects may be directly synchronized with the remote data store e.g. for each such object directly comparing the versions of the object in the local data store and the remote data store while the regular priority objects may be synchronized with the remote data store through an object cache where all such updates may be stored upon detecting the update and efficiently synchronized as a batch. As a second such example the high priority objects may be holistically synchronized with the remote data store e.g. comparing and or copying the entire object while the regular priority objects may be synchronized as an object update e.g. generating a diff or delta that may be applied to an older version of the object stored on the remote data store to transform it into the newer version of the object stored on the device and sending the diff or delta to the remote data store or vice versa . Such differences may be advantageous e.g. in scenarios where the high priority objects are likely to be small in both number and size such as in scenarios where the high priority objects represent the application state of an application wherein directly and holistically synchronizing the small object set may be frequently performed at a high frequency while the remaining objects of the object set may be synchronized as object updates stored in an object update cache.

As a second variation of this third aspect the device and the remote data store may communicate during the synchronization in various ways. As one such example the remote data store may comprise a high priority end point and a regular priority end point e.g. representing different network addresses and or network ports . The device may synchronize the high priority objects during the high priority synchronization through the high priority end point and may synchronize the regular priority objects during the regular priority synchronization through the regular priority end point. This manner of partitioning the communication regarding the synchronization may be advantageous e.g. for enabling the remote data store to allocate more resources for the high priority synchronization occurring on at the higher frequency and or for logging the different types of synchronization such as for tracking throughout for comparison with the high priority data threshold .

As a third variation of this third aspect the device and or remote data store may apply conflict resolution processes during the high priority synchronization and or the regular priority synchronization e.g. determining which of two updated version of an object takes priority and or merging updates to two or more versions of an object . As one such example it may be advantageous to expedite the high priority synchronization by resolving conflicts only during the regular priority synchronization . Such conflict resolution during the regular priority synchronization may include resolving conflicts created during the high priority synchronization of the object set e.g. upon detecting that both versions of a high priority object have been updated while performing the high priority synchronization simply store both versions of the object and perform conflict resolution during the regular priority synchronization .

As a fourth variation of this third aspect the high priority objects may be synchronized only during the high priority synchronization e.g. maintaining a partition between the high priority objects and the regular priority objects . Alternatively the high priority objects may also be synchronized during the regular priority synchronization e.g. factoring the synchronization as a high priority synchronization of the high priority subset of the object set and a regular priority synchronization that comprehensively synchronizes the entire object set . These and other variations of the synchronization may be included in embodiments of the techniques presented herein.

A fourth aspect that may vary among embodiments of the techniques presented herein involves the manner of throttling the high priority synchronization of the object set e.g. the manner of calculating and applying the high priority data threshold .

As a first variation of this fourth aspect the high priority data threshold may be calculated in various ways. For example the high priority data threshold may be selected from a high priority data threshold set comprising a high priority synchronization maximum data threshold e.g. a maximum amount of data exchanged in a particular instance of the high priority synchronization or over a particular period a high priority synchronization maximum object count threshold e.g. a maximum number of objects updated during a particular instance of the high priority synchronization or over a particular period and a high priority synchronization bandwidth consumption threshold e.g. a maximum consumption of available bandwidth . A combination of such metrics may also be utilized e.g. both a maximum available bandwidth threshold and a maximum object count .

As a second variation of this fourth aspect the high priority data threshold may be adjusted in view of the available synchronization related resources of the device and or the remote data store . As one such variation an exemplary system may include a high priority data threshold selecting component that is configured to monitor a resource capacity of at least one synchronization resource of the device e.g. processor capacity or bandwidth and to adjust the high priority data threshold in view of the resource capacities of the synchronization resources of the device . As a first such example a device and or remote data store may raise the high priority data threshold during busy periods in order to maintain high consistency of application state while applications in heavy use and lower the high priority data threshold during idle periods in order to allocate computing resources away from synchronization and toward other idle time tasks since application state is infrequently changing . As a second such example the device and or the remote data store may lower the high priority data threshold during busy periods in order to reallocate computing resources toward more significant computation and may raise the high priority data threshold during idle periods in order to maintain highly consistent application state when more significant computational tasks are not being performed.

As a third variation of this fourth aspect the high priority data threshold may be applied by the device and or the remote data store . As a first such example the high priority data threshold may be applied only by the device or only by the remote data store and the other of the device and the remote data store may allow unlimited high priority synchronization . As a second such example both the device and the remote data store may apply the high priority data threshold e.g. both may track the total amount of data exchanged during high priority synchronization . As a third such example both the device and the remote data store may track and apply different high priority synchronization thresholds e.g. each of the device and the remote data store may monitor local synchronization based resource availability and throttle the high priority synchronization accordingly e.g. upon exceeding a percentage of available bandwidth for either the device or the remote data store .

As a fourth variation of this fourth aspect when the high priority synchronization exceeds the high priority data threshold the device and or remote data store may respond in various ways. As a first example the device and or remote data store may gently throttle the high priority synchronization e.g. substantially reducing the available bandwidth but allowing the high priority synchronization to continue. Alternatively the device and or remote data store may suspend and or terminate the high priority synchronization and may resume or reinitiate the high priority synchronization at a later time e.g. at the next instance of the high priority synchronization frequency . As a second example for any unsynchronized high priority objects that were not synchronized during the high priority synchronization due to the high priority data threshold the device and or remote data store may wait until the next high priority synchronization to synchronize these unsynchronized high priority objects and or may synchronize these objects during the next regular priority synchronization i.e. using the regular priority synchronization to complete the high priority synchronization and or regarding the unsynchronized high priority objects as regular priority objects . In such scenarios it may be advantageous to perform the regular priority synchronization by synchronizing the high priority objects before the regular priority objects thus utilizing the priority designation even for high priority objects that were not synchronized during the high priority synchronization .

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB Firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

