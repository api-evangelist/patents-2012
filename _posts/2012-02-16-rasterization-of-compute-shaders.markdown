---

title: Rasterization of compute shaders
abstract: Described are compiler algorithms that partition a compute shader program into maximal-size regions, called thread-loops. The algorithms may remove original barrier-based synchronization yet the thus-transformed shader program remains semantically equivalent to the original shader program (i.e., the transformed shader program is correct). Moreover, the transformed shader program is amenable to optimization via existing compiler technology, and can be executed efficiently by CPU thread(s). A Dispatch call can be load-balanced on a CPU by assigning single or multiple CPU threads to execute thread blocks. In addition, the number of concurrently executing thread blocks do not overload the CPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09529575&OS=09529575&RS=09529575
owner: Microsoft Technology Licensing, LLC
number: 09529575
owner_city: Redmond
owner_country: US
publication_date: 20120216
---
Recent trends indicate significant increase in the use of GPUs graphics processing units for general purpose computing GPGPU . That is GPUs are tending to be used for computing not necessarily related to computer graphics such as physics simulation video transcoding and other data parallel computing. Furthermore the introduction of on chip shared memory in GPUs has led to marked performance improvements for widely used compute intensive algorithms such as all prefix sum scan histogram computation convolution Fast Fourier Transform FFT physics simulations and more. Microsoft Corporation offers the Direct X HLSL High Level Shading Language Compute Shader as a software API application programming interface to access and utilize shared memory capabilities. Note that Direct X the HLSL and Compute Shader will be referred to as examples with the understanding that comments and discussion directed thereto are equally applicable to other shading languages such as CUDA Compute Unified Device Architecture OpenCL Open Compute Language etc. These will be referred to generically as compute shaders .

A complete software platform should provide efficient software rasterization of a compute shader or the like on CPUs to provide a fallback when GPU hardware is not an option or when the software platform is used in a headless VM Virtual Machine scenario without the need to implement both GPU and CPU hardware solutions. That is it is sometimes desirable to execute shader language code on a CPU rather than a GPU. However mapping GPU centric compute shaders onto CPUs efficiently is non trivial primarily due to thread synchronization which is enforced by thread barriers or syncs .

While the efficiency of scalar shader code is important discussion herein relates to efficiently mapping onto CPUs as opposed to GPUs the parallelism found in compute shaders. Compute shaders may expose parallelism in different ways. For example the Direct Compute Dispatch call defines a grid of thread blocks to expose parallelism on a coarse level which is trivial to map onto CPU threads. Each thread block is an instance of a compute shader program that is executed by multiple shader threads a shader is analogous to a kernel in CUDA for example . The shader threads of a block may share data via a shared memory that is common to threads in the block but private to the thread block. The threads of each thread block may be synchronized via barriers to enable accesses to shared memory without concern for data race conditions arising. GPUs typically execute compute shaders via hardware thread contexts in groups of threads warps or wave fronts and each context may legally execute the program until it encounters a barrier at which point the context must wait for all other contexts to reach the same barrier. Hardware context switching in GPUs is fast and heavily pipelined. However CPUs do not have such hardware support which makes it difficult to efficiently execute compute shaders on CPUs.

Techniques discussed below relate to transforming a compute shader program into an equivalent CPU program that delivers acceptable performance on CPUs.

The following summary is included only to introduce some concepts discussed in the Detailed Description below. This summary is not comprehensive and is not intended to delineate the scope of the claimed subject matter which is set forth by the claims presented at the end.

Described herein are compiler algorithms that partition a compute shader program into maximal size regions called thread loops. The algorithms may remove original barrier based synchronization yet the thus transformed shader program remains semantically equivalent to the original shader program i.e. the transformed shader program is correct . Moreover the transformed shader program is amenable to optimization via existing compiler technology and can be executed efficiently by CPU thread s . A Dispatch call can be load balanced on a CPU by assigning single or multiple CPU threads to execute thread blocks. In addition the number of concurrently executing thread blocks do not overload the CPU. Note that CPU thread s execute multiple thread blocks instances of the compute shader program . The Dispatch call may specify the execution of millions of instances. If all of these thread blocks are launched together there may be problems such as overconsumption of memory poor cache utilization and frequent context switching.

Many of the attendant features will be explained below with reference to the following detailed description considered in connection with the accompanying drawings.

There are several ways that a compute shader can be mapped onto a CPU. A na ve approach is to mimic the GPU model i.e. interpret the original program in groups of threads and yield the execution upon encountering a barrier. However with this approach performance can be poor due to the high overhead of context switching for a CPU. Alternatively the shader can be partitioned at barriers e.g. 

This technique is both correct and efficient. A thread loop t loop is denoted as for all threads do . As the name implies a t loop executes one iteration for each thread t of a thread block. To maintain the semantics of the original shader program the original variables must be privatized i.e. each thread uses its own set of variables called t loop variables. Among other ways this may be achieved for example by making each variable v an array of size T the number of threads in a thread block so that thread t uses v t as its copy. Thus the notation B t which indicates that the original code block B uses the variable set private to thread t. Note that not all variables should be replicated and some optimizations are possible. Moreover while efficient scalar code generation is useful discussion herein concerns mapping compute shader parallelism onto CPUs efficiently. Thus a t loop may also be referred to as a parallel for all loop. As will be seen iterations of a t loop are independent and can legally be executed in any order by one or multiple CPU threads.

The approach above is straightforward for simple partitioning. However if a barrier is nested within a control flow construct e.g. an if statement switch statement etc. care must be taken to not break the scoping structure of the program. Since HLSL and other shading languages have well defined scopes Sub If Switch and Loop these may be readily optimized. To preserve scoping properties each t loop should be properly nested. Alternatively an arbitrary go to might be needed which would complicate the optimization significantly and might not be acceptable for just in time JIT compiling. Consider the following example 

Notice that any barrier must execute in uniform control flow UCF all threads execute the statement . In other words all threads of a thread block must reach the barrier in a correct program. Therefore if c1 in the example above must be a uniform transfer and it is sufficient to check only one instance e.g. c1 instance of thread 0 c1 0 .

At step unless the current operation is the end of the subroutine an OpBeginThreadLoop operation is inserted right after the current operation. Finally at step if the current operation is a barrier or analogous type of synchronization operation the operation is removed because the original data dependencies are now enforced by the order of the execution of the thread loops.

Note that the partitioning algorithm creates maximal size t loops without breaking the scoping structure and inserted t loops are properly nested. There are however control flow transfer operations such as break continue and return that may transfer control outside of a t loop. These may need to be specially treated to preserve correctness of the shader program. If these operations do not transfer control outside of a t loop i.e. they are nested within their corresponding scopes they are handled in a standard way.

Regarding the term maximal this term means that it is not possible to increase the amount of code encompassed by a t loop without breaking the nested structure of the program. A minimal size t loop or region would encompass a single operation also a possible partitioning but the program will be slow due to t loop overheads. Maximal size t loops reduce the overall number of t loops and thus reduce the associated overhead.

Four helper flag variables are used one for each for four different types of control transfer break continue switch break and return . Each such variable is a scalar because the value of the transfer conditional is uniform. The variables are initialized to false before a t loop if they are used in the t loop. A loop break continue nested in a uniform t loop will set the bBreakFlag bContinueFlag to true and transfer control to the next iteration of the enclosing t loop and after the t loop is complete break continue the corresponding loop if the bBreakFlag bContinueFlag is set. An executed uniform switch break nested in a uniform t loop sets the bSwitchBreakFlag to true and transfers control to the next iteration of the enclosing t loop and after the t loop is done breaks the switch if bSwitchBreakFlag is set. Finally uniform return nested in a uniform t loop sets the bReturnFlag to true and transfers control to the next iteration of the enclosing t loop and after the t loop is done returns from the subroutine if the bReturnFlag is set.

It may happen that a transfer outside of a t loop is divergent non uniform . shows an example of such a return causing divergent control flow DCF . DCF input is transformed as shown in output . The transformation introduces a t loop mask TLoopRetMask one instance per thread to capture which threads executed a divergent return. If a subroutine contains such a return the rules for the insertion of TLoopRetMask are as follows 

 1 Initialize TLoopRetMask to true on entry to the subroutine at the very beginning of the entry t loop. If there is no entry t loop generate one.

 2 Set TLoopRetMask to false for every DCF return as well as UCF return that transfers control outside of a t loop if there is at least one DCF return that transfers control outside of this t loop.

 3 For every t loop that starts in DCF generate guarding code at the very beginning of a t loop that would skip the iteration if TLoopRetMask is false.

 4 Re initialize TLoopRetMask to true on exit from the subroutine at the very end of the exit t loop unless it is the main subroutine. If there is no exit t loop generate one.

It is sufficient to use only one TLoopRetMask per program even though it may be required in several subroutines. While this reduces overhead it is also the reason for re initialization of the mask on exit from the subroutine. Using more mask variables which are replicated across threads increases memory footprint and is not desirable.

A loop s break and continue that transfer control outside of a t loop cannot be in DCF. If the break or continue did so transfer control the entire loop wouldn t have been in DCF due to the back edge and cannot execute any barrier. And because the t loops are induced by barriers such a loop must be nested inside a t loop according to our partitioning algorithm.

A DCF switch break that transfers control outside of a t loop can be handled in exactly the same manner as the DCF return via managing the state of TLoopSwitchMask. To avoid using several such variables and complicated code generation TLoopSwitchMask may be initialized to True right before such a switch and TLoopSwitchMask may be re initialized to True right after the switch. This approach correctly transforms nested switches. Suppose switch S is nested in a case of switch S. If S requires TLoopSwitchMask S contains a nested barrier otherwise it would have been nested in a t loop so both S and S must start in UCF. Furthermore the control is uniform in S s case at least up until the beginning of S otherwise S would have been in DCF thus TLoopSwitchMask must be true before the start of S. Since the effect of the DCF switch break in S propagates only to the end of S and has no effect on control flow type in S it is safe to re initialize TLoopSwitchMask right after S because TLoopSwitchMask has not yet captured any effect of S s DCF break although it was used inside S . What may be done here is to insert extra re initializations of TLoopRetMask and TLoopSwitchMask to essentially avoid complicated analysis of where exactly to insert mask initializations for the situation that would occur rarely in performant compute shaders. Finally the guarding condition for t loops that are nested in a switch and start in DCF must be set to TLoopRetMask TLoopSwitchMask to account for effects of both DCF return and switch break.

To achieve high performance it may be helpful to minimize overhead of synchronization by having fairly coarse units of work and by load balancing the processors. A typical invocation of a compute shader dispatch call creates many instances of the compute shader program each of which usually performs roughly similar amounts of work. Thus it is natural to use a single CPU thread to execute an instance units of work are coarse the concurrency overhead of executing t loops does not exist due to serial execution and the load balance is reasonable.

Some compute shaders though are written to stream units of work rather than rely on the Dispatch call to do the streaming i.e. the Dispatch call instantiates just a few instances of the compute shader program and each instance has a streaming loop that processes several units of work one after another. In this scenario the load balance may suffer due to under utilization of some CPU threads. To avoid this several CPU threads can be used to run each thread loop which is legal because t loop iterations are independent. These threads must synchronize before and after each t loop and use atomic increment to obtain the thread index t of a t loop iteration. The result is better load balancing at the expense of small synchronization overhead. Note that Dispatch and its equivalents in various shader languages may be able to not only invoke shader language code for execution but a Dispatch or Draw call may also reference various graphical objects in the shader language such as pixels vertices etc. Additional details of Dispatch and its equivalents and thread blocks are available elsewhere see e.g. Practical Rendering and Computation with Direct3D 11 Zink et al. 2011 CRC Press .

Usually the Dispatch call or its equivalent creates hundreds or thousands of compute shader instances. When run on a CPU rather than a GPU executing all of the instances concurrently will 1 create too many threads 2 use too much memory 3 cause many expensive context switches and 4 pollute the cache due to frequent context switches. This results in poor performance due to overbooking of the system. Thus it may be helpful to limit the number of compute shader instances that execute concurrently for example the number of compute shader instances may be limited to two plus the number of CPU cores.

Embodiments and features discussed above can be realized in the form of information stored in volatile or non volatile computer or device readable storage media. This is deemed to include at least physical storage media such as optical storage e.g. compact disk read only memory CD ROM magnetic media flash read only memory ROM or any means of physically storing digital information excluding carrier waves signals per se and the like . The stored information can be in the form of machine executable instructions e.g. compiled executable binary code source code bytecode or any other information that can be used to enable or configure computing devices to perform the various embodiments discussed above. This is also deemed to include at least volatile memory such as random access memory RAM and or virtual memory storing information such as central processing unit CPU instructions during execution of a program carrying out an embodiment as well as non volatile media storing information that allows a program or executable to be loaded and executed. The term media as used herein refers to physical devices and material and does not refer to signals per se carrier waves or any other transient forms of energy per se. The embodiments and features can be performed on any type of computing device including portable devices workstations servers mobile wireless devices and so on.

