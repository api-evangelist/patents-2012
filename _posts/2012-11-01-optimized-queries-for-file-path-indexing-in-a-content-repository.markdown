---

title: Optimized queries for file path indexing in a content repository
abstract: Techniques for indexing file paths of items in a content repository may include taking turns in querying each different item type or folder type in a round robin schedule to visit select nodes of the folder tree of that type to update and maintain the file path indexes. Item types or folder types may be associated with a count of instances or children of instances that are missing indexes. For each item type or folder type, a query may be performed for instances of the item type or folder type having children that are missing indexes, the instances or children of the instances returned may be associated with file path indexes, and the count of instances or children of instances may be adjusted based on the associating.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08914356&OS=08914356&RS=08914356
owner: International Business Machines Corporation
number: 08914356
owner_city: Armonk
owner_country: US
publication_date: 20121101
---
The invention relates to data storage and more specifically relates to file paths of items in folder trees.

Documents and content stored as files in a content repository may be logically represented as a folder tree where each file in the content repository may be associated with and accessed by a file path that specifies a unique location of the file in the content repository. In some examples the content repository may maintain an index for the file paths of the files in the content repository referred to as a file path index so that the file path of a file in the content repository may be quickly determined instead of having to be determined on the fly when retrieving or otherwise accessing a file. As files are created deleted moved and otherwise modified in the content repository it may be necessary to update the file path index for the content repository.

In one aspect the disclosure is directed to a method for indexing file paths of items in a content repository. The method may include for each item type having one or more instances that are not associated with file path indexes and that are filed in one or more folders in a content repository out of a plurality of item types in turn in a round robin sequence querying by the at least one processor the content repository for instances of the item type that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index and responsive to the querying returning by the at least one processor one or more instances of the item type associating the one or more instances of the item type with the one or more file path indexes.

In another aspect the disclosure is directed to a computing system. The computing system may include one or more processors. The computing device may also include an indexer operable on the one or more processors and configured to for each item type having one or more instances that are not associated with file path indexes and that are filed in one or more folders in a content repository out of a plurality of item types in turn in a round robin sequence query the content repository for instances of the item type that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index and responsive to the query returning one or more instances of the item type associate the one or more instances of the item type with the one or more file path indexes.

In another aspect the disclosure is directed to a computer readable storage medium containing instructions. The instructions when executed on at least one programmable processor may cause the at least one programmable processor to perform operations. The operations may include for each item type having one or more instances that are not associated with file path indexes and that are filed in one or more folders in a content repository out of a plurality of item types in turn in a round robin sequence querying the content repository for instances of the item type that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index and responsive to the querying returning one or more instances of the item type associating the one or more instances of the item type with the one or more file path indexes.

In another aspect the disclosure is directed to a method for indexing file paths of items in a content repository. The method may include for each folder type having one or more instances that have one or more child items that are not associated with file path indexes in a content repository out of a plurality of folder types in turn in a round robin sequence querying by the at least one processor the content repository for child items of instances of the folder type that are not associated with one or more file path indexes and responsive to the querying returning by the at least one processor one or more child items of instances of the folder type associating the one or more child items of instances of the folder type with the one or more file path indexes.

The details of one or more aspects of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

In general techniques are described for creating and updating file path indexes for files that are represented as a folder tree in a content repository. Previous techniques such as crawling the folder tree to create and update file path indexes of files in the folder tree may be too resource intensive in an enterprise environment requiring high performance high scaling high stress high load and many users. One technique for ameliorating those deficiencies may include broadly querying across all types in a content repository to identify nodes that are missing file path indexes and to associate those nodes with file path indexes. However querying broadly across all types in the content repository may be too resource intensive slow and complex to execute because such a broad query may necessitate evaluation of all possible folder and document types including any combinations of folder and document types. In some examples such queries may exceed the query language limits of the content repository so that such queries are not able to be executed by the content repository. As such there is a need for techniques for creating and updating file path indexes for files that are represented as a folder tree in a content repository that is less resource intensive less complex and faster to execute.

The techniques disclosed herein may take turns in querying each different item type or folder type to visit select nodes of the folder tree of that type to update and maintain the file path indexes. For example an optimized indexer is described that may for example visit only nodes within the folder tree that are of the specified type and that are missing indexes or may visit only folders that are of the specified type and that contain children missing indexes. This may significantly reduce or completely eliminate cost of visiting nodes that are already indexed or visiting nodes in the part of the content repository that should not be optimized for paths or indexed. Furthermore by taking turns in querying each different item type or folder type the queries may be less resource intensive. In addition the queries may be able to find instances without file path indexes at different levels of the folder tree as opposed to some techniques that traverse the folder tree a level at a time. In this way the efficiency of identifying files without file path indexes and creating file path indexes for those files within the folder tree hierarchy may be improved.

In some examples the content repository may be accessed via a services layer. The services layer may maintain the file path indexes for the files in the content repository so that a file path for a file in a folder tree may be quickly looked up. The services layer may create or update the file path indexes based on changes made to files in the content repository by applications accessing the content repository through the services layer. However in some computing environments certain applications may directly access the content repository without using the services layer to create delete move or otherwise modify the files in the content repository thereby causing the file path indexes maintained in the services layer to become out of date. As described the techniques may be used for example to optimally update the file path indexes maintained by the services layer and to determine whether any files in the content repository do not have an associated file path index maintained by the services layer.

In accordance with the techniques described herein an indexer may periodically determine whether instances of each item type or folder type in the content repository qualify for an associated file path index but do not have an associated file path index by issuing queries for items of a specified type and may create file path indexes for those unindexed instances.

Computing system may be made up of one or more computing devices that each includes one or more programmable processors. In some examples computing system is a part of an enterprise environment. Content repository services layer indexer one or more applications and one or more applications may be operable on one or more computing devices. In some examples a single computing device comprises content repository services layer indexer one or more applications and one or more applications . In some other examples content repository services layer indexer one or more applications and one or more applications are spread out over a plurality of computing devices.

Content repository may be an enterprise repository that includes one or more data stores for storing documents or other digital content in computing system as files on one or more computer readable storage media. In some examples content repository is organized into a hierarchy of folders and may natively support file paths or folder trees for accessing files stored within the folders. In some examples items in content repository may be associated with types and the items in content repository may be grouped or otherwise organized according to its associated type. For example an item s associated type can denote the department that the item belongs to in an organization or can denote the database table the item resides in.

In some examples content repository is a relational database that receives queries and returns one or more files based on the queries. If content repository is a relational database then content repository may include tables A N tables and each of the tables may include one or more items. Items in content repository may be associated with a plurality of different types. For example items may be associated with a type based on which table out of tables in the relational database includes the item so that items A B H and J may be associated with type 1 because they are included in table1 A items C E F and I may be associated with type 2 because they are included in table2 B and items D G K and L may be associated with type N because they are included in table N.

In some environments content repository may include indexable content and non indexable content . Indexable content may include items that may be represented hierarchically as part of one or more folder trees by services layer . Items in indexable content may have an associated file path index in file path indexes so that the items may be uniquely identified by a file path of the item in a folder tree. In some examples file path indexes is stored in content repository and may be considered a part of non indexable content . Conversely non indexable content may include items that are not represented as folder trees by services layer . For example non indexable content includes e mail archives or e mail inboxes that are not typically represented hierarchically as a folder tree.

Services layer may be operably coupled to content repository and may provide one or more software services and interfaces to software applications such as one or more applications for accessing items stored in content repository . In some examples the services and interfaces provided by services layer includes an application programming interface API that applications may use to access data stored in content repository . In some examples services layer provides web services that applications use to access data stored in content repository .

Services layer may abstract the items in indexable content of content repository for one or more applications so that they may appear as a part of one or more folder trees. For example services layer may maintain file path indexes that includes a file path index indicating the file path for each item in a folder tree in indexable content . For example as shown in file path indexes may include a file path index for file C indicating a file path of A B C thereby indicating that file C may be contained in folder B which may be contained in folder A which may be at the root folder of a folder tree. The file path index for file C may also indicate the type associated with type C. The services and interfaces provided by services layer for example enables one or more applications to specify an item in indexable content by a file path that uniquely identifies the item in the folder tree. As shown items of one type can be contained in folders of another type. For example while item C is associated with type 2 folders A and B are both associated with type 1.

One or more applications may also directly access content repository without use of services layer and may directly create delete move or otherwise modify files in content repository without using or notifying services layer . Thus file path indexes maintained by services layer can become out of date if one or more applications add delete move or otherwise modify items in indexable content . For example one or more applications may directly create a new file under a pre existing folder in a folder tree or may move a file from one folder to another folder in a folder tree.

Indexer may be operably coupled to content repository and services layer and may index items in indexable content in content repository . Indexer may determine the item types in content repository that are subject to file path indexing and may calculate the maximum possible number of missing file path indexes for each item type that is subject to file path indexing. For each item type in content repository that has at least one missing file path index indexer may associate that item type with the count of missing file path indexes and may store that association in a map not shown . Indexer may item type by item type in a round robin schedule for each of the item types associated with the count of missing file path indexes in the map determine instances of the item type in indexable content that do not have associated file path indexes and are filed in a folder that is associated with a file path index and may create file path indexes for those instances of the item type. If content repository is queryable such as by being a relational database indexer may determine the instances of the item type in indexable content that do not have associated file path indexes by sending queries to content repository . The number of instances of the item type that were found during the query and associated with file path indexes may be subtracted from the count of missing file path indexes associated with the item type in the map to keep track of the number of instances of the item type that are still missing file path indexes.

For example indexer may identify two item types that each has one or more missing file path indexes. Indexer may send a query to content repository for one or more instances of a first item type of the two item types that qualify for file path indexes such as items stored in indexable content do not have file path indexes in file path indexes and have a parent folder that has a file path index in file path indexes . Content repository may receive the query from indexer perform the query and return a query result to indexer . The query result may indicate one or more resulting instances of the first item type that met all of the requirements of the query. In response indexer may create file path indexes for the resulting instances from the querying may store each file path index in file path indexes and may decrement the number of missing file path indexes associated with the first item type by the number of instances of the first item type returned in the query result and associated with file path indexes.

Subsequently indexer may similarly send a query to content repository for one or more instances of a second item type of the two item types that qualify for file path indexes such as items stored in indexable content do not have file path indexes in file path indexes and have a parent folder that has a file path index in file path indexes . Content repository may receive the query from indexer perform the query and return a query result to indexer . The query result may indicate one or more resulting instances of the second item type that met all of the requirements of the query. In response indexer may create file path indexes for the resulting instances from the querying may store each file path index in file path indexes and may decrement the number of missing file path indexes associated with the second item type by the number of instances of the second item type returned in the query result and associated with file path indexes.

Because indexer operates in a round robin schedule in querying for instances of item types associated with the number of missing file path indexes in a map the process may repeat with the first item type and subsequently the second item type until the number of missing file path indexes associated with the first item type and the second item type both reaches zero.

If the query for instances of an item type that qualify for file path indexes in file path indexes do not have file path indexes in file path indexes and have a parent folder that has a file path index in file path indexes returns zero instances of the item type the zero instances does not necessarily indicate that every instance of the item type that qualify for file path indexes is now associated with a file path index. Because the query includes the qualifier of having a parent folder that has a file path index if the parent folder for an instance of that item type is not yet associated with a file path index then the instance of that item type that is a child of the unindexed parent folder is also not returned by the query until its parent folder is associated with a file path index in file path indexes .

Alternatively instead of performing a query of different item types indexer may determine the folder types in content repository that are subject to file path indexing and may for each folder type that is subject to file path indexing calculate the maximum possible number of folder instances that has one or more children that are missing file path indexes. For each folder type in content repository that has at least one folder instance having one or more children that are missing a file path index indexer may associate that folder type with the count of folder instances having one or more children that are missing file path indexes and may store that association in a map or a folder type candidate list not shown . Similar to the above described technique where item types are queried item type by item type in a round robin schedule indexer may folder type by folder type in a round robin schedule for each of the folder types associated with the count of folder instances having one or more children that are missing file path indexes in the map or folder type candidate list determine folder instances of the folder type in indexable content that has one or more children that do not have associated file path indexes and are filed in a folder that is associated with a file path index and may create file path indexes for the children of those instances of the folder type that are missing file path indexes. If content repository is queryable such as by being a relational database indexer may determine the instances of the folder type in indexable content that have children that do not have associated file path indexes by sending queries to content repository . The number of instances of the folder type whose children are now all associated with file path indexes may be subtracted from the count of folder instances having children that are missing file path indexes associated with the folder type in the map or folder type candidate list.

For example if indexer identifies three folder types that each has one or more folder instances that have children that are missing file path indexes indexer may in turn for each of the three folder types send a query to content repository for children of one or more instances of the folder type that qualify for file path indexes such as items stored in indexable content do not have file path indexes in file path indexes and have a parent folder that has a file path index in file path indexes create and associate a file path index with each child item returned as a result of the query and subtract the count of instances of the folder type returned by the query from the count of total folder instances having children that are missing file path indexes associated with the folder type. Indexer may repeat the process for each of the three folder types in turn until the count associated with each of the folder types reaches zero. In some examples the count associated with each of the folder types will not reach zero because the count may include one or more instances in non indexable content that are missing file path indexes. Thus instead of determining if the count associated with each of the folder types reaches zero the process may end if all of the queries consecutively one after another all return zero items.

Indexer may periodically issue queries to content repository to keep file path indexes up to date. In some examples an enterprise administrator may manually cause indexer to issue queries to content repository . In some examples indexer may automatically issue queries on a periodic basis.

Indexer may for each item type associated with the count of the one or more instances in turn in a round robin sequence until the count of the one or more instances reaches zero for each item type process the item types to associate instances of the item types with file path indexes. Indexer may set a first item type in the map as the current item type . As shown in indexer may determine if the current item type is associated with a zero count of item instances in the map . If the item instance is associated with a zero count of item instances indexer may set the next item type in the map as the current item type and may determine if the current item type is associated with a zero count of item instances . Because indexer processes the item types in a round robin fashion if the current item type is the last item type in the map the indexer may circle back to the first item type in the map as the next item type. If the item instance is not associated with a zero count of item instances indexer may query content repository for instances of the current item type that qualify for file path indexes that are not associated with file path indexes and that have a parent folder that has a file path index . The query can find unindexed item instances at different levels of a folder tree as long as the item has an indexed parent folder because the query queries content repository for all item instances in content repository that meet the conditions of the query without regards as to the level each of those item instances are at in the folder tree as opposed to some techniques that traverse the folder tree a level at a time. Responsive to the query returning one or more instances of the current item type indexer may associate the returned one or more instances of the current item type with file path indexes and may adjust the count associated with the current item type by decrementing the count associated with the current item type in the map by the number of instances that were associated with file path indexes . Indexer may determine if every item type in the map is associated with a zero count . If so then the process may end. However if not every item type in the map is associated with a zero count then indexer may repeat the process with the next item type in the map including setting the next item type as the current item type . As discussed above because indexer processes the item types in a round robin fashion if the current item type is the last item type in the map the indexer may circle back to the first item type in the map as the next item type.

Indexer may for each folder type associated with the count of the one or more instances in turn in a round robin sequence until the count of the one or more instances reaches zero for each folder type process the instances of the folder type to associate any children of the instances that are missing file path indexes with file path indexes. Indexer may set the current folder type to a first folder type in the list of folder types . Indexer may determine if the current folder type is associated with zero instances that have one or more children that are missing file path indexes in the folder type candidate list. If the current folder type is associated with zero instances having children that are missing file path indexes in the folder type candidate list indexer may set the next folder type in the folder type candidate list as the current folder type and may determine if the current folder type is associated with zero missing file path indexes in the folder type candidate list . Because indexer processes the folder types in a round robin schedule if the current folder type is the last folder type in the folder type candidate list the indexer may advance to the next folder type by circling back to the first folder type in the folder type candidate list and set that folder type as the next folder type. If the folder type is not associated with a zero count of missing indexes indexer may query for instances of the folder type that have one or children that 1 quality for path indexes 2 are not associated with file path indexes and 3 have a parent folder that has a file path index . The query can find folder instances with unindexed child items at different levels of a folder tree as long as the unindexed child items have an indexed parent folder because the query queries content repository for all folder instances in content repository that meet the conditions of the query without regards as to the level each of those folder instances are at in the folder tree as opposed to some techniques that traverse the folder tree a level at a time. As shown in if the query returns one or more children of folder instances of the current folder type indexer may associate the returned one or more children of folder instances of the current folder type with file path indexes and may decrement the count associated with the current folder type in the folder type candidate list by the number of folder instances of the folder type that had one or more children be associated with file path indexes . Indexer may determine if every folder type in the folder type candidate list is associated with a zero count in the folder type candidate list . If so then the process may end. However if not every folder type in the map is associated with a zero count then indexer may repeat the process with the next folder type in the folder type candidate list including setting the next folder type as the current folder type . As discussed above because indexer processes the folder types in a round robin fashion if the current folder type is the last folder type in the folder type candidate list the indexer may advance to the next folder type by circling back to the first folder type in the folder type candidate list and setting the first folder type as the current folder type.

To determine if each query for instances of types returns no instances a type may be marked if the query for instances of the type returns no instances and if the immediately preceding query for instances of the type immediately preceding the type returned at least one instance. As long as subsequent queries for instances of subsequent types return no instances the marked type may remain marked. However if a subsequent query for instances of a subsequent type returns at least one instance the marked type may be unmarked. If the queries loop back to the marked type and the marked type remains marked then it may be determined that there are no instances in indexable content that are missing file path indexes and the querying may terminate. Some examples of marking a specified type may include associating the specified type with a marker or any other indication that the specified type is marked setting a marked type variable to the specified type or any other techniques of marking the specified type.

As shown in indexer may determine a list of types e.g. item types or folder types and may remove the types from the list of types that are not subject to file path indexing . Indexer may for each type in the list of types a count of instances that are not associated with file path indexes for item types or a count of instances that have one or more child items that are not associated with file path indexes for folder types . Indexer may set the current type to the first type in the list of types . Indexer may determine if the type is marked . Determining if the type is marked may in some examples include determining if the type is associated with a mark or an indication that the type is marked or may also include determining if a marked type variable is set to the type. If the type is marked then the process may end. If the type is not marked indexer may perform a query such as query shown in for item types and query shown in for folder types for instances with missing file path indexes . As shown in indexer may determine if the query returned at least 1 instance . If the query returned at least 1 instance of the type indexer may unmark any currently marked types associate the instance with file path indexes or associate the child item of the folder instance with file path indexes decrement the count associated with the current type set the next type as the current type and perform the query for the current type .

If the query did not return at least 1 instance of the type indexer may determine if a type is currently marked . If no types are currently marked indexer may mark the current type set the next type as the current type and perform the query for the current type . If a type is currently marked indexer may set the next type as the current type and perform the query for the current type .

Folder A file C folder B file E file F file H file folder J and folder K each already have an associated file path index and thus are considered to be indexed. In contrast file D1 folder G2 folder L3 folder M2 and file N1 do not have an associated file path index and thus are considered to not be indexed. As shown in items that are identified with a character together with a number may be associated with a type identified by the number so that file D1 and file N1 may be associated with type 1 folder G2 and folder M2 may be associated with type 2 and folder L3 may be associated with type 3.

An example indexer such as indexer may for each type of items may determine how many instances of each item type does not have an associated file path index. In the example folder tree indexer may determine that item type 1 has two instances that do not have an associated file path index because file D1 and file N1 do not have associated file path indexes that item type 2 has two instances that do not have an associated file path index because folder G2 and folder M2 do not have associated file path indexes and that item type 3 has one instance that does not have an associated file path index because folder L3 does not have an associated file path index.

For each item type that indexer determines to have a non zero count of instances that do not have associated file path indexes indexer may store in map in computing system an association of the item type and the count of the instances that do not have associated file path indexes. For example an association of type 1 with 2 instances that do not have associated file path indexes an association of type 2 with 2 instances that do not have associated file path indexes and an association of type 3 with 1 instance that does not have an associated file path index may be stored in the map.

For each item type that has a non zero count of instances that do not have associated file path indexes indexer may in a round robin schedule query content repository for instances of the type that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and associate the item instances if any returned by the query with file path indexes. The round robin schedule denotes that indexer may repeatedly cycle through the item types in order in a circular fashion until instances that are missing file path indexes are associated with file path indexes. Indexer may decrement the count of instances that do not have associated file path indexes associated with the item type in map by the number of instances returned as a result of the query and associated with file path indexes. If the count associated with the item type in map reaches 0 the item type and associated count may be removed from map and indexer may no longer query for instances of that item type. In some examples an associated count for the item type may never reach zero if there are one or more instances of the item type stored in non indexable content because the query may only query for and return instances that qualify for file path indexes.

In one example for the folder tree shown in indexer may first query for instances of item type 1 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query if any with file path indexes. As shown in file D1 has been associated with a file path index as a result and the count associated with type 1 in map has been decremented from 2 to 1.

In one example after querying for instances of item type 1 indexer may query for instances of item type 2 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query with file path indexes. As shown in folder G2 has been associated with a file path index as a result and the count associated with type 2 in map has been decremented from 2 to 1.

In one example after querying for instances of item type 2 indexer may query for instances of item type 3 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query with file path indexes. As shown in folder L3 has been associated with a file path index as a result and the count associated with type 3 in map has been decremented from 1 to 0. In some examples if the count associated with an item type becomes 0 the item type is removed from consideration so that indexer will not continue to query for instances of that item type. Thus if item type 3 is removed from consideration indexer will no longer query for instances of item type 3. In some examples the item type and its associated count may also be removed from map if the count associated with the item type becomes 0.

In one example after querying for instances of item type 3 indexer may re query for instances of item type 1 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query with file path indexes. Because the remaining instance of type 1 that qualify for file path indexes and is not associated with a file path index is file N1 which is a child of folder M2 which itself is not associated with a file path index the query will not return any instances of item type 1.

In some examples indexer tracks the number of resulting items returned by the query above to determine whether all of the items in indexable content of content repository that are missing file path indexes are now associated with file path indexes by tracking the number of resulting items returned by the query above. If the current query returns zero items and if the query previous to the current query returned one or more items indexer may mark the item type associated with the current query such as by setting a bit in map . If a subsequent query returns one or more items then indexer may unmark the previously marked item type. However if indexer loops through the item types in map and reaches an already marked item type then indexer may determine that all of the items in indexable content of content repository that are missing file path indexes are now associated with file path indexes and the process may terminate. Thus because the query for instances of item type 1 did not return any items and because the query for instances of item type 3 immediately previous to the query for instances of item 1 did return at least one item instance indexer may mark item type 1.

In one example after querying for instances of item type 1 indexer may re query for instances of item type 2 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query with file path indexes. Folder M2 may be returned as a result of the query and as shown in indexer may associate folder M2 with a file path index. Indexer may decrement the count associated with item type 2 in map from 1 to 0. Because the query returned one item instance item type 1 may be unmarked.

In some examples because item type 3 is associated with a count of 0 in map indexer may skip querying item type 3. In deciding whether to mark item type 3 skipping querying of item type 3 may be treated as the query of item type 3 returning zero items. Thus indexer may mark item type 3 in map . Instead of querying for instances of item type 3 after querying for instances of item type 2 indexer may re query for instances of item type 1 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query with file path indexes. As shown in file N1 has been associated with a file path index as a result and the count associated with type 3 in map has been decremented from 1 to 0. Because the query of item 1 returned an item instance previously marked item 3 may be unmarked.

After querying for item type 1 indexer may query for instances of item type 2. However as discussed above because item type 2 is associated with a count of zero in map item type 2 may be skipped. Item type 2 may also be marked because item type 2 is skipped and because the immediately preceding query for instances of item type 1 returned at least one instance. Because all three item types in map have an associated count of 0 queries for item types 3 and 1 will also be skipped by indexer . In addition when indexer once again reaches item type 2 indexer may end the query in response to determining that item type 2 is marked and that a query for instances of item type 2 would return zero instances. Thus indexer may determine that all items missing file path indexes in indexable content are now associated with file path indexes and may terminate the indexing process.

Instead of querying for item types indexer may also query for folder types. are conceptual diagrams illustrating an example technique for indexing files in a folder tree by an example indexer such as indexer shown in according to aspects of the disclosure. As shown in folder tree includes files and directories arranged hierarchically so that a folder may contain files and directories and those directories may contain files and directories and so on.

Folder A file C folder B file E file F file H file folder J and folder K each already have an associated file path index and thus are considered to be indexed. In contrast file D1 folder G2 folder L3 folder M2 and file N1 do not have an associated file path index and thus are considered to not be indexed. As shown in items that are identified with a character together with a number may be associated with a type identified by the number so that file D1 and file N1 may be associated with type 1 folder G2 and folder M2 may be associated with type 2 and folder L3 may be associated with type 3.

An example indexer such as indexer may for each type of folder determine how many instances of each folder type has child items that do not have an associated file path index. In the example folder tree indexer may determine that folder type 1 has two folder instances having children that do not have an associated file path index because folder A1 includes a child file D that does not have an associated file path index and because folder M1 includes a child file N that also does not have an associated file path index. Indexer may determine that folder type 2 has two folder instances having children that do not have an associated file path index because folder B2 includes a child folder G that does not have an associated file path index and because folder L2 includes a child folder M1 that also does not have an associated file path index. Indexer may determine that folder type 3 has one folder instance having children that do not have an associated file path index because folder K3 includes a child folder L2 that does not have an associated file path index.

For each folder type that indexer determines to have a non zero count of instances having children that do not have associated file path indexes indexer may store in map in computing system an association of the folder type and the count of the instances having children that do not have associated file path indexes. For example an association of folder type 1 with a count of 2 instances having children that do not have associated file path indexes an association of folder type 2 with a count of 2 instances having children that do not have associated file path indexes and an association of folder type 3 with a count of 1 instance having children that does not have an associated file path index may be stored in map .

For each folder type that has a non zero count of instances having children that do not have associated file path indexes indexer may in a round robin scheme query content repository for instances of the folder type having children that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and associate the children of folder instances if any returned by the query with file path indexes. The round robin scheme denotes that indexer may repeatedly cycle through the folder types in order. Indexer may decrement the count of instances having children that do not have associated file path indexes associated with the folder type in map by the number of folder instances returned as a result of the query that has its children associated with file path indexes. If the count associated with the folder type in map reaches 0 the folder type and associated count may be removed from map and indexer may no longer query for instances of that folder type.

In one example for the folder tree shown in indexer may first query for children of instances of folder type 1 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the child items returned by the query with file path indexes. As shown in file D has been associated with a file path index as a result and the count associated with folder type 1 in map has been decremented from 2 to 1.

In one example after querying for instances of folder type 1 indexer may query for children of instances of folder type 2 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the child items returned by the query with file path indexes. As shown in folder G has been associated with a file path index as a result and the count associated with folder type 2 in map has been decremented from 2 to 1.

In one example after querying for instances of folder type 2 indexer may query for children of instances of folder type 3 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the child items returned by the query with file path indexes. As shown in folder L2 has been associated with a file path index as a result and the count associated with folder type 3 in map has been decremented from 1 to 0. If the count associated with a folder type becomes 0 the folder type may be removed from consideration so that indexer will not continue to query for children of instances of that folder type. Thus indexer may no longer query for children of instances of folder type 3. In some examples the folder type and its associated count may also be removed from map if the count associated with the folder type becomes 0.

In one example after querying for instances of folder type 3 indexer may re query for children of instances of folder type 1 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the child items returned by the query with file path indexes. Because the remaining instance of folder type 1 is folder M1 which itself is not associated with a file path index the query will not return any children of instances of item type 1.

In some examples indexer tracks the number of resulting instances returned by the query above to determine whether all of the children of folders in indexable content of content repository that are missing file path indexes are now associated with file path indexes by tracking the number of resulting instances returned by the query above. If the current query returns zero instances and if the query previous to the current query returned one or more instances indexer may mark the folder type associated with the current query such as by setting a bit in map . If a subsequent query returns one or more instances then indexer may unmark the previously marked folder type. However if indexer loops through the folder types in map and reaches an already marked folder type then indexer may determine that all of the children of folders in indexable content of content repository that are missing file path indexes are now associated with file path indexes and the process may terminate. Thus because the query for instances of folder type 1 did not return any items and because the query for instances of folder type 3 immediately previous to the query for instances of folder type 1 did return at least one instance indexer may mark folder type 1.

In one example after querying for children of instances of folder type 1 indexer may re query for children of instances of folder type 2 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the child items returned by the query with file path indexes. As shown in folder M1 which is a child item of folder L2 has been associated with a file path index as a result and the count associated with folder type 2 in map has been decremented from 1 to 0. Because the query for folder type 2 returned at least one instance folder type 1 may be unmarked.

Because folder type 3 is associated with a count of 0 in map folder type 3 may be marked in map and instead of querying for children of instances of folder type 3 after querying for children of instances of folder type 2 indexer may re query for children of instances of folder type 1 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the child items of the instances returned by the query with file path indexes. As shown in file N which is a child item of folder M1 has been associated with a file path index as a result and the count associated with folder type 3 in map has been decremented from 1 to 0. Because the query for folder type 1 returned at least one instance folder type 3 may be unmarked. If termination of the indexing process is based on determining if all of the folder types in map are associated with zero counts then the indexing process may terminate.

After querying for folder type 1 indexer may query for instances of folder type 2. However as discussed above because folder type 2 is associated with a count of zero in map folder type 2 may be skipped. Folder type 2 may also be marked because folder type 2 is skipped and because the immediately preceding query for instances of folder type 1 returned at least one instance. Because all three folder types in map have an associated count of 0 queries for folder types 3 and 1 will also be skipped by indexer . In addition when indexer once again reaches folder type 2 indexer may end the query in response to determining that folder type 2 is marked and that a query for instances of folder type 2 would return zero instances. Thus if termination of the indexing process is based on determining if the query has reached an already marked item then indexer may determine that all items missing file path indexes in indexable content are now associated with file path indexes and may terminate the indexing process.

Computing device may include one or more processors memory a network interface one or more storage devices and user interface . Computing device may also include an operating system which may include modules and or applications that are executable by processors and computing device . Computing device in one example may also include indexer services layer and one or more applications which all may be executable by one or more processors of computing device . Each of components and may be interconnected physically communicatively and or operatively for inter component communications.

Processors in one example may be configured to implement functionality and or process instructions for execution within computing device . For example processors may be capable of processing instructions stored in memory or instructions stored on storage devices . These instructions may define or otherwise control the operation of operating system indexer services layer and one or more applications .

Memory may in one example be configured to store information within computing device during operation. Memory in some examples may be described as a computer readable storage medium. In some examples memory may be a temporary memory meaning that a primary purpose of memory is not long term storage. Memory may in some examples be described as a volatile memory meaning that memory does not maintain stored contents when computing device is turned off. Examples of volatile memories may include random access memories RAM dynamic random access memories DRAM static random access memories SRAM and other forms of volatile memories known in the art. In some examples memory may be used to store program instructions for execution by processors . Memory may in one example be used by software or applications running on computing device e.g. indexer to temporarily store information during program execution.

Computing device may in some examples also include network interface . Computing device may in one example use network interface to communicate with external devices via one or more networks. Network interface may be a network interface card such as an Ethernet card an optical transceiver a radio frequency transceiver or any other type of device that can send and receive information. Other examples of such network interfaces may include Bluetooth 3G and Wi Fi radios in mobile computing devices as well as USB. In some examples computing device may use network interface to wirelessly communicate with an external device such as a server mobile phone or other networked computing device.

Storage devices may in some examples also include one or more computer readable storage media. Storage devices may be configured to store larger amounts of information than memory . Storage devices may further be configured for long term storage of information. In some examples storage devices may include non volatile storage elements. Examples of such non volatile storage elements may include magnetic hard discs optical discs floppy discs flash memories or forms of electrically programmable memories EPROM or electrically erasable and programmable EEPROM memories.

In some examples storage devices may include content repository such as content repository shown in and file path indexes such as file path indexes shown in . Content repository may include one or more data stores for storing digital content. In some examples content repository may not natively support file paths or folder trees. For example content repository may be a queryable repository such as a relational database. In some examples content repository may be an enterprise repository. Content repository in some examples may include indexable content and non indexable content. Indexable content may include data that may be represented as folder trees by services layer . Non indexable content may include data that are not represented as folder trees by services layer . In some examples file path indexes may include a file path index indicating the file path for each file in a folder tree in indexable content of content repository so that services layer may for example enable one or more applications to specify an item in content repository by a file path that uniquely identifies the item in a folder tree. In some examples file path indexes may be stored in content repository and may be considered non indexable content.

Computing device may in some examples also include one or more user interfaces . User interface may be configured to receive input from a user e.g. tactile audio or video feedback . User interface may include a touch sensitive and or a presence sensitive screen mouse a keyboard a voice responsive system or any other type of device for detecting a command from a user. In some examples user interface may include a touch sensitive screen mouse keyboard microphone or camera.

User interface may also include combined or separate from input devices output devices. In this manner user interface may be configured to provide output to a user using tactile audio or video stimuli. In one example user interface may include a touch sensitive screen sound card a video graphics adapter card or any other type of device for converting a signal into an appropriate form understandable to humans or machines. In addition user interface may include a speaker a cathode ray tube CRT monitor a liquid crystal display LCD or any other type of device that can generate intelligible output to a user.

Computing device may in some examples also include operating system . Operating system may in some examples control the operation of components of computing device . For example operating system may in one example facilitate the interaction of indexer with services layer applications processors memory network interface storage device and user interface .

Computing device may in some examples further include indexer which may be similar to indexer shown in . Indexer may be an executable software application running on one or more processors and stored in memory or one or more storage devices . In some examples indexer may be configured to determine items in a content repository such as content repository that are not associated with file path indexes and to associate those items with file path indexes.

Indexer may be configured to associate each item type having one or more instances that are not associated with file path indexes and that are filed in one or more folders in a content repository out of a plurality of item types with a count of the one or more instances. Indexer may be further configured to for each item type associated with the count of the one or more instances in turn in a round robin sequence until the count of the one or more instances reaches zero for each item type query the content repository for instances of the item type associated with the count of the one or more instances that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index responsive to the query returning one or more instances of the item type associate the one or more instances of the item type with the one or more file path indexes and adjust the count of the one or more instances associated with the item type based on the associating the one or more instances of the item type with the one or more file path indexes.

Alternatively indexer may be configured to associate each folder type having one or more instances that have one or more child items that are not associated with file path indexes in a content repository out of a plurality of folder types with a count of the one or more instances. Indexer may be further configured to for each folder type associated with the count of the one or more instances in turn in a round robin sequence until the count of the one or more instances reaches zero for each folder type query the content repository for child items of instances of the folder type associated with the count of the one or more instances that are not associated with one or more file path indexes responsive to the query returning one or more child items of instances of the folder type associate the one or more child items of instances of the folder type with the one or more file path indexes and adjust the count of the one or more instances associated with the folder type based on the associating the one or more child items of instances of the folder type with the one or more file path indexes.

Computing device may in some examples further include services layer which may be similar to services layer shown in . Services layer may be an executable software application running on one or more processors and stored in memory or one or more storage devices . In some examples services layer may be configured to provide services and interfaces to applications such as one or more applications for accessing data stored in content repository . In some examples the services and interfaces provided by services layer may include an application programming interface API that applications may use to access data stored in content repository . In some other examples services layer may provide web services that applications may use to access data stored in content repository over the web.

In some examples services layer may also be configured to abstract items in content repository so that they may appear as one or more folder trees to one or more applications. For example services layer may be configured to maintain file path indexes that includes a file path index indicating the file path for files in a folder tree in content repository . The services and interfaces provided by services layer may for example enable one or more applications to specify an item in content repository by a file path that uniquely identifies the item in a folder tree.

Computing device may in some examples further include one or more applications such as one or more applications and one or more applications shown in . One or more applications may be an executable software application running on one or more processors and stored in memory or one or more storage devices . In some examples one or more applications may be configured to access items in content repository via services layer . In some examples one or more applications may be configured to directly access items in content repository without using services layer .

Any applications e.g. indexer implemented within or executed by computing device may be implemented or contained within operable by executed by and or be operatively communicatively coupled to components of computing device e.g. processors memory network interface storage devices and user interface .

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

