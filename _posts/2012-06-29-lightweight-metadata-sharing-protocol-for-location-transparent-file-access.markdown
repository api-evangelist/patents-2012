---

title: Lightweight metadata sharing protocol for location transparent file access
abstract: A storage processor having access to published logical unit numbers of a common block file system mounted on another storage processor processes requests for a particular file system object of the common block file system using metadata objects of the common block file system cached in both storage processors to access storage units shared between the two storage processors.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09223799&OS=09223799&RS=09223799
owner: EMC Corporation
number: 09223799
owner_city: Hopkinton
owner_country: US
publication_date: 20120629
---
A storage system includes multiple storage processors sharing common storage devices. A conventional storage system includes a Common Block File System CBFS that is mounted on one storage processor i.e. owning cannot be mounted on other storage processors i.e. non owning despite sharing the common storage devices. The files on the file system are exposed as Logic Units and the CBFS publishes Logical Unit Numbers LUNs of the file system referring to the file or objects to allow other storage processors to make reference to the files or objects.

The non owning storage processor will receives requests for a file system object using the published LUN. When the non owning processor receives a request for a LUN it does not own the non owning storage processor forwards the request to the owning storage processor for file system processing.

Unfortunately there are deficiencies with the above described conventional storage system. In particular having the non owning storage processor forward all the requests for a file system object to the owning storage processor will cause multiple context switches in both the owning storage processor and the non owning storage processor. The transfer of data between the storage processors also reduces bandwidth on both storage processors. Additionally the backend controller and the CPU of the owning storage processor becomes saturated processing the requests.

In contrast to the above described conventional storage system the improved technique provides lightweight access to file system objects by sharing among the extent cache of each of the storage processors metadata objects used to access objects of the common block file system stored in common storage devices.

Advantageously the improved technique reduces multiple context switches to satisfy the request for a file system object and evenly distributes I O over the multiple storage processors sharing common storage devices.

One embodiment of the improved technique is directed to a method of satisfying a request for a particular file system object by a second storage processor in a common block file system bound to a first storage processor a common message interface provided for communicating between the first storage processor and the second storage processor the common block file system storing metadata objects arranged as a tree structure bound to the first storage processor.

Further a cache of the second storage processor stores a portion of the tree structure in which the metadata objects are arranged. In particular the leaf node of the tree structure is stored in the cache of the second storage processor The method examines the request for the particular file system object for an instruction causing modification of any metadata object of the common block file system. If any instruction of the request causes a modification of metadata of the CBFS forward the request for the particular file system object to the first storage processor i.e. the storage processor that owns the CBFS via the CMI and receive in return the particular file system object from the first storage processor via the CMI. If there is nothing that will modify the metadata attempt service the request for a particular file system object locally by referencing a branch of the portion of the tree structure in order to seek a leaf node of the branch of the tree structure. The leaf node contains a metadata object including an identifier for physically satisfying the request for the particular file system object. Once the information is found access the storage on which the particular file system object is stored by using the identifier for physically satisfying the request for the particular file system object. Now that the particular object has been retrieved locally or remotely return the particular file system object to a requestor.

In another embodiment of the invention a proxy storage processor locally accesses a particular file system object stored on a common block file system mounted on a primary storage processor the storage processor includes a storage device storing objects of the common block file system including metadata objects arranged as a tree structure. An extent cache stores a portion of the tree structure in which the metadata objects are arranged. A common messaging interface provides communication with the primary storage processor. A controller circuit that provides access to objects of the common block file system the controlling circuitry constructed and configured to perform the method described above.

In a further embodiment the method described above is embodied as a computer program stored on a non transitory storage medium executed by a microprocessor.

The storage processors and further include the CBFS Logic for controlling and accessing the storage containing the objects of the file system. A FLARE Cache stores cache entries mapping logical addresses of an object of the file system to a physical address in a storage device and Common Message Interface CMI for passing message between the first storage processor and the second storage processor .

The CBFS exposes the logical unit number LUN of a file system object of the CBFS owned by one storage processor to multiple storage processors. A non owning storage processor receives a request to read a data block on the CBFS owned by storage processor at a driver not shown which identifies among other things including the LUN. The driver determines the LUN for the object is not owned by storage processor and passes the request to the CBFS API which checks if the request for the file system object will cause metadata of the CBFS to be modified. If the metadata of the CBFS will be modified by the request for the file system object then the request for the file system object is forwarded to the owning storage processor to process the request.

If the metadata of the CBFS will not be modified by the request for the file system object have the non owning storage processor check the extent cache for a leaf node of the branch of the metadata objects of the file system that would satisfy the request for the file system object. Each extent cache entry on any either owning storage processor or non owning storage processor indicates that a given file range or LUN range is available for mapping on either owning storage processor or non owning storage processor . If the leaf node exists then in the non owning storage processor use the logical address provided in the leaf node to translate the logical address to a physical address held in the FLARE Cache using the physical address to access the storage device locally. Each extent cache entry only contains a buffer pointer the buffer pointer points to the actual leaf node containing physical addresses.

If the leaf node does not exist the non owning storage processor requests that the owning storage processor loads the required branch of the metadata objects of the file system that would satisfy the request for the file system object. Once the branch of the metadata objects of the file system that would satisfy the request for the file system object are loaded use the logical address provided in the leaf node to translate the logical address to physical address using the FLARE Cache so that storage device may be accessed to satisfy the request.

When traversing the branch the logic of the CBFS API checks the extent cache for the presence of the indirect block . If the indirect block is present in the extent cache then the logic can then check if the next element indirect block is loaded in the extent cache . If it is then the CBFS API in the non owning storage processor can use an identifier of the data block by translating the logical address in the indirect block to a physical address and performing I O in the non owning storage processor .

However if during the walk of the branch of the tree structure there is a missing node of the tree structure for example if indirect node does not exist in the extent cache of the storage processor storage processor requests the indirect block from the storage processor by making the request for the indirect block across the CMI . The storage processor loads the leaf node into its extent cache which is then shared with the extent cache in the storage processor .

On a cache miss the CBFS Logic on the non owning storage processor will have to make an explicit request to the owning CBFS storage processor for caching the extents. To share the metadata objects in the extent cache between the storage processor and include a state machine tracking the cache entries.

Every non owning storage processor for example storage processor would maintain its own copy of the extent cache . On a cache miss the non owning storage processor would explicitly request for the metadata objects for read or write . The owning storage processor shares the metadata objects and tracks the outstanding references granted and then the non owning storage processor caches it locally and independently manages its local cache entry. References owned by the non owning storage processor is relinquished when the metadata objects entries on the local cache age out or the owning storage processor would explicitly force a non owning storage processor holding the metadata object to yield.

As both the owning storage processor and the non owning storage processor have copies of the cached metadata objects a nexus between the objects of the owning storage processor and the non owning storage processor is created.

The owning storage processor mounts the file system on bootstrap and publishes the objects hosted by the file systems. The storage objects can be accessed from non owning storage processor only after establishing a nexus between the storage node and non owning storage processor .

When there are multiple non owning storage processors there are multiple nexuses between storage objects hosted by the owning storage processor and the proxy object on one or more non owning storage processor . It should be understood that only one proxy object can be instantiated for a storage object on an owning storage processor . The storage object can be deleted only after releasing all the pending references on the object held by the proxy objects on the owning storage processor and non owning storage processor .

The nexus describes the association between a storage object and an instance of its proxy. The nexus is also used to describe the temporal association between the storage object and it s local client on the owning storage processor . Every storage object proxy association is described by an instance of a nexus. The storage objects and their proxy objects track their nexus independently. The table below enumerates the various states of the nexus state machine .

All the states described below are common for both owning and non owning storage processors. At step a new extent cache entry is allocated in entent cache .

At state there are no pending operations on the cache entry. The LRC and RRC have returned to zero. This state is also the initial state of a cache entry when it is first allocated. At state there are local references made to the cache entry. This state is common for both owning and non owning SPs and indicates local references on both SPs. At state one or more remote references are made to a cache entry with pending local references. At state both local and remote references have been released in this state the Buffer hint could potentially become invalid based on system load. Next state is used for exclusive operations only. There are no remote references pending on the cache entry at this time. It is primarily driven by the owning SP. At state the owning storage processor needs to perform an exclusive operation this state indicates a revoke in progress. Finally in state the LRC and RRC are both non zero an exclusive operation will transition this entry to state via state . A recycle operation would require a revoke state before the entry is available for use. In state the entry is undergoing a revoke operation for LRU recycling it is not available for general use.

At step a request for the particular file system object for an instruction causing modification of any metadata object of the common block file system is examined. If there is an instruction that causes a modification of the metadata then at step forward the request for the particular file system object to the first storage processor via the CMI . The first storage processor is the storage processor that mounts or owns the CBFS and it returns the particular data object . At step the storage processor receives the particular file system object from the first storage processor via the CMI .

If there is no instruction in the request for the particular file system object that causes the instruction causes the modification of metadata of the CBFS at step referencing a branch of the portion of the tree structure in order to seek a leaf node of the branch of the tree structure the leaf node containing a metadata object including an identifier for physically satisfying the request for the particular file system object . Then at step access a storage on which the particular file system object is stored by using the identifier for physically satisfying the request for the particular file system object . Either having retrieved the particular file system object by direct access or by requesting it from the storage processor at step return the particular file system object to a requestor of the particular file system object .

At step interrogate the cache for the leaf node of the branch of the portion of the tree structure. If the leaf node of the branch of the portion of the tree structure does not exist in the portion of the tree structure then at step request the leaf node of the branch of the tree structure via the CMI from the first storage processor. At step receive the leaf node of the branch of the tree structure via the CMI. Then at step store the received leaf node in the cache. Otherwise if the leaf node of the branch of the portion of the tree structure exists in the portion of the tree structure allow the reference to be completed.

