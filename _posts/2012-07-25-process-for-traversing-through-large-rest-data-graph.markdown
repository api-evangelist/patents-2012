---

title: Process for traversing through large rest data graph
abstract: A method for data discovery and retrieval is provided. A REST API client library provides a discovery document for a data graph. The discovery document is structured data containing: (1) a list of data graph endpoints and (2) the format of the information each endpoint returns. The client library uses the REST API to query the server for a data object, wrapping the data object in a new data object. The new data object contains: (1) fixed data from the server-returned data object and (2) a function for each graph node that is directly connected to the requested data object. When these functions execute, the next data objects in the data graph can be retrieved, allowing for quick graph navigation. Given a discovery document and the ability to generate closures based on the document, a query object can be constructed that traverses several layers of the API at once.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09184980&OS=09184980&RS=09184980
owner: Google, Inc.
number: 09184980
owner_city: Mountain View
owner_country: US
publication_date: 20120725
---
In the last few years there has been an increase in cloud computing and web based services. Representational state transfer REST web services are a unique kind of web services implemented using HTTP and the principles of REST which include a stateless client server architecture a uniform interface and a layered system. A REST web service follows four basic design principles 1 it uses HTTP methods explicitly 2 it is stateless 3 it exposes directory structure like URIs and 4 it transfers data in formats such as XML and or JavaScript Object Notation JSON . Web service providers provide developers access to REST web service data via REST application programming interfaces APIs .

Some REST APIs give developers access to large data graphs. A data graph is a data structure that stores data and shows relationships among data using a finite collection of points called nodes and lines called edges. Relationships within a graph are represented by connecting nodes with each other using edges as depicted in . A graph can be rootless and can be traversed both forwards and backwards across many nodes.

In there are six 6 nodes and seven 7 edges. Node is only connected to Node . Node is connected to Nodes and . Node is connected to Nodes and . Node is connected to Nodes and . Node is connected to Nodes and . In this data graph there is no direct relationship between Nodes and . Therefore the graph must be traversed to find a path from Node to Node .

There are several possible ways to get from Node to Node 1 Node Node Node Node 2 Node Node Node Node Node 3 Node Node Node Node Node Node and 4 Node Node Node Node Node . Path is the most efficient path between Node and Node because it requires visiting the least number of nodes. Discovering the most efficient path connecting nodes is often challenging because of the numerous paths available among nodes.

Large data graphs provided by REST APIs usually contain multiple data object nodes that are interconnected and sometimes hierarchical as depicted in . Most REST API providers give developers a client library or documentation which demonstrates how to retrieve data objects from their respective REST APIs. However it is often infeasible for a developer to obtain an entire data graph in a single server call using a REST API because a graph is typically too large and interconnected. Instead each server call will usually only bring back an individual data object node. Therefore developers have to make repeated calls to the sever using the REST API to obtain a complete data graph. This process can be tedious and time consuming.

This specification describes technologies relating to data discovery and retrieval and specifically to a method for efficiently traversing large data graphs using a REST API.

In general one aspect of the subject matter described in this specification can be embodied in methods for data discovery and retrieval. An exemplary method includes receiving a request for a data object associated with a data graph requesting the data object from a server receiving the requested data object wrapping the requested data object in a new data object containing fixed data from the requested data object and a function for each data object that is directly connected to the requested data object in the data graph and returning the new data object to the requestor. Another exemplary method includes receiving a query constructed with a plurality of chained closures collapsing the closures into a parseable structured markup language object sending the structured markup language object to the server where the chained closures may be executed as a series of queries and receiving an aggregated result from the series of queries executed by the server.

These and other embodiments can optionally include one or more of the following features the discovery document may contain a list of data graph endpoints and the format in which data will be returned from each endpoint when the endpoint is accessed or executed the discovery document may be formatted in JSON the discovery document may be formatted in XML or another schema form the function may retrieve the next data object in the data graph the function may be a closure the function may be a function pointer with parameters.

The details of one or more embodiments of the invention are set forth in the accompanying drawings which are given by way of illustration only and the description below. Other features aspects and advantages of the invention will become apparent from the description the drawings and the claims. Like reference numbers and designations in the various drawings indicate like elements.

According to an exemplary embodiment a REST API client library may include a discovery document as generated code so that a developer can efficiently traverse a data graph. A discovery document shows a developer how to find the next node in the connected graph. The discovery document may be provided as structured data and may contain 1 a list of data graph endpoints and 2 the format of the information that will be returned from each endpoint when the endpoint is accessed.

For the non limiting exemplary graph depicted in the discovery document may include the data graph s several endpoints and the format of each endpoint. The exemplary data graph describes an object called friend that has a list of friends a list of activities and an address object . The friend list may be further subdivided into lists of family and acquaintances . The graph shows that each friend list contains friend objects . The friend objects also each have a list of friends a list of activities and an address object . The address object can have a city object which is connected to a map image .

An exemplary discovery document as illustrated in shows efficient ways in which to traverse a data graph. The document may provide three pieces of information 1 the available objects in the graph 2 the available methods and 3 the format of all the available objects. Within this document the terms data object object and node are used interchangeably.

In order to provide a developer with a discovery document the API client library may or may not query the server for the document. In dynamic languages the discovery document is often retrieved from the server. For non dynamic languages the discovery document is often compiled and added to the API client library. Once the discovery list is acquired the developer can make a request for a data object based on information from the discovery document.

As depicted in an exemplary method begins with the API client receiving a request for a data object associated with a data graph . The API client requests the data object from a server . The requested data object and a discovery document associated with the data object are received . The requested data object is then wrapped in a new data object and the new object is returned to the requestor .

The new data object returned to the requestor contains the requested object s fixed data which is the data that was retrieved by the server and stored at the requested object s memory address. The new object also contains a closure or similar software object for each data object that is directly connected to the requested data object in the data graph . A closure is a function that retains information about the environment in which it was created. Knowing the environment allows the closure to use variables that are not local. When the closure is executed it binds non local variables to corresponding values of variables that were in scope at the time the closure was created. The scope is the context within a computer application in which the name of a variable or some other identification is valid and can be used or within which a variable declaration has effect.

According to aspects of the inventive concepts given a discovery document and the ability to generate closures based on the discovery document developer transparent calls can be made to the REST APIs that save roundtrips to the server. With the discovery document a developer can construct a single query object that traverses several layers of the API at a time. Executing this query object only requires one roundtrip to the server. The object allows for graph traversal in several different directions and returns an aggregate answer for the query.

As depicted in an exemplary method begins with an API client receiving a query that has a plurality of chained closures . The closures may be collapsed into parseable structured markup language object . The API client may then send the structured markup language object to the server where the chained closures may be executed as a series of queries . The API client receives the aggregated result from the series of queries executed by the server and sends the result on to the remote client . Obtaining the aggregate result is much more efficient than a conventional mechanism for querying the server.

For example in a conventional process an application may contain the following code to obtain a user Bob and a list of all of Bob s friends families.

In this example there is the potential for there to multiple calls from a remote client to the server. If Bob has ten 10 friends the developer s code may call the server for every one of Bob s friends. There may be a call to obtain Bob s user object one to obtain Bob s list of friends and then one call per friend to obtain each friend s list of families. In total twelve 12 calls could be made to retrieve Bob s friends families. The code would be equivalent to 

In an exemplary embodiment a developer would be provided with a discovery document an example of which is depicted in . With this discovery document closures can be generated. These closures can be used by the developer to construct a single query object that traverses several layers of the API at once. The query object only makes one roundtrip to the backend traverses the graph in different directions and returns an aggregate answer to the query for Bob s friends families.

With a discovery document and generated closures the code to retrieve Bob s friends families could be 

In this example the createQuery chains closures together to create a large JSON structure. Friend.get Bob returns a FriendQuery object. The FriendQuery object is a query results object that may include methods such as list which provides the list of friends and friend WhoseDisplayNameContains which can provide the list of friends whose display name contains specified criteria.

In the discovery document depicted in there are two example criteria for finding a friend the display name and the type. contains an example where the display name must match the regular expression Aman and the friend must be of type acquaintances for there to be a match to a specific query. In the above example friend must be of type family for there to be a match on this query.

Each method on FriendQuery can return more query result objects which in turn can be called to chain subsequent queries. When the query object is executed all FriendQuery objects are collapsed into a parseable JSON object that represents the chained query. Client.doQuery sends the parseable JSON object to the server which executes the series of queries and returns only the last result to the client.

Depending on the desired configuration the processor can be of any type including but not limited to a microprocessor P a microcontroller C a digital signal processor DSP or any combination thereof. The processor can include one more levels of caching such as a level one cache and a level two cache a processor core and registers . The processor core can include an arithmetic logic unit ALU a floating point unit FPU a digital signal processing core DSP Core or any combination thereof. A memory controller can also be used with the processor or in some implementations the memory controller can be an internal part of the processor .

Depending on the desired configuration the system memory can be of any type including but not limited to volatile memory such as RAM non volatile memory such as ROM flash memory etc. or any combination thereof. System memory typically includes an operating system one or more applications and program data . The application includes an application that can perform large scale data processing using parallel processing. Program Data includes storing instructions that when executed by the one or more processing devices implement a method for efficiently traversing large data graphs using a REST API. In some embodiments the application can be arranged to operate with program data on an operating system .

The computing device can have additional features or functionality and additional interfaces to facilitate communications between the basic configuration and any required devices and interfaces.

System memory is an example of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media can be part of the device .

The computing device can be implemented as a portion of a small form factor portable or mobile electronic device such as a cell phone a personal data assistant PDA a personal media player device a wireless web watch device a personal headset device an application specific device or a hybrid device that include any of the above functions. The computing device can also be implemented as a personal computer including both laptop computer and non laptop computer configurations.

The foregoing detailed description has set forth various embodiments of the devices and or processes via the use of block diagrams flowcharts and or examples. Insofar as such block diagrams flowcharts and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams flowcharts or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof. In one embodiment several portions of the subject matter described herein may be implemented via Application Specific Integrated Circuits ASICs Field Programmable Gate Arrays FPGAs digital signal processors DSPs or other integrated formats. However those skilled in the art will recognize that some aspects of the embodiments disclosed herein in whole or in part can be equivalently implemented in integrated circuits as one or more computer programs running on one or more computers e.g. as one or more programs running on one or more computer systems as one or more programs running on one or more processors e.g. as one or more programs running on one or more microprocessors as firmware or as virtually any combination thereof and that designing the circuitry and or writing the code for the software and or firmware would be well within the skill of one of skill in the art in light of this disclosure. In addition those skilled in the art will appreciate that the mechanisms of the subject matter described herein are capable of being distributed as a program product in a variety of forms and that an illustrative embodiment of the subject matter described herein applies regardless of the particular type of signal bearing medium used to actually carry out the distribution. Examples of a signal bearing medium include but are not limited to the following a recordable type medium such as a floppy disk a hard disk drive a Compact Disc CD a Digital Video Disk DVD a digital tape a computer memory etc. and a transmission type medium such as a digital and or an analog communication medium. e.g. a fiber optic cable a waveguide a wired communications link a wireless communication link etc. 

With respect to the use of substantially any plural and or singular terms herein those having skill in the art can translate from the plural to the singular and or from the singular to the plural as is appropriate to the context and or application. The various singular plural permutations may be expressly set forth herein for sake of clarity.

Thus particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition the processes depicted in the accompanying figures do not necessarily require the particular order shown or sequential order to achieve desirable results. In certain implementations multitasking and parallel processing may be advantageous.

