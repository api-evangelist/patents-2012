---

title: Enhancing client-side object caching for web based applications
abstract: An object request associated with a requesting entity can be identified. The object request can comprise of an object identifier and an object type associated with an object instance which can be a renderable entity. The entity can be a widget within an application executing within a client device. An object type associated with the object request can be determined which can be decomposed into an attribute request based a selected schema. The attribute request can comprise of an object instance identifier and an attribute identifier associated with an attribute value. An attribute index associated with a client-side object cache can be queried for the attribute value. When the attribute value exists in the attribute index, an appropriate attribute value associated with the attribute can be conveyed to the entity. When the attribute value is absent from the attribute index, the attribute request can be conveyed to a request aggregator.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09576067&OS=09576067&RS=09576067
owner: International Business Machines Corporation
number: 09576067
owner_city: Armonk
owner_country: US
publication_date: 20120224
---
This application is a continuation of U.S. patent application Ser. No. 12 940 294 filed Nov. 5 2010 pending which is incorporated herein in its entirety.

The disclosure relates to the field of Web based applications and more particularly to enhancing client side object caching for Web based applications.

Web 2.0 applications have become increasingly modular in both core application and user interface design. Many times a single application interface is composed of several independent sub components referred to as widgets . Widgets typically utilize objects e.g. JAVASCRIPT object to perform operations and execute functionality. Many times widgets utilize objects and object data to present information within an interface. For example a stock ticker widget can utilize stock market data within an object to present trending information for one or more stocks. Due to the dynamic nature of most widgets caching of appropriate objects can be indeterminable. For instance user interactions with widgets dictate what information and consequently which objects the widgets require.

In very rich dynamic interfaces these objects often include common data e.g. object attributes which can be used by several widgets. Since the widgets typically are isolated from other widgets to maintain modularity and flexibility this often results in redundant requests and or transmission of this common data. That is widgets often request the same common data e.g. objects frequently that other widgets previously requested. Consequently network and server resources can be unduly taxed from this superfluous communication.

Current approaches to this problem include traditional browser caches which cache objects on the client side. However traditional cache systems do not provide a means for sharing this common data. As such there is no mechanism to determine which common data can be shared. Further traditional caches cannot progressively reduce requests to server resources as they do not enable reconstruction of server side data models.

An object request associated with a requesting entity can be identified. The object request can comprise of an object identifier and an object type associated with an object instance which can be a renderable entity. The entity can be a widget within an application executing within a client device. An object type associated with the object request can be determined which can be decomposed into an attribute request based a selected schema. The attribute request can comprise of an object instance identifier and an attribute identifier associated with an attribute value. An attribute index associated with a client side object cache can be queried for the attribute value. When the attribute value exists in the attribute index an appropriate attribute value associated with the attribute can be conveyed to the entity. When the attribute value is absent from the attribute index the attribute request can be conveyed to a request aggregator.

The present disclosure is a solution for enhancing client side object caching for Web based applications. In the solution a client computing device can utilize a caching agent to permit attribute level object metadata sharing of renderable objects between applications. The caching agent can be a client side object cache which can intercept object requests process and respond with an appropriate object instance. The caching agent can utilize an object schema to allow an object type associated with the object request to be decomposed into constituent attributes. Each attribute can be queried from an attribute index associated with the object cache. Attributes which are stored within the index can be retrieved and utilized to build the object instance associated with the object request. When an attribute is not cached within the index server communication can be initiated to obtain relevant attributes.

As will be appreciated by one skilled in the art the disclosure may be embodied as a system method or computer program product. Accordingly the disclosure may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the disclosure may take the form of a computer program product embodied in one or more computer readable medium s having computer usable program code embodied in the medium.

Any combination of one or more computer usable or computer readable medium s may be utilized. The computer usable or computer readable medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CDROM an optical storage device a transmission media such as those supporting the Internet or an intranet or a magnetic storage device. Note that the computer usable or computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured for instance via optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory. In the context of this document a computer usable or computer readable medium may be any medium that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The computer usable medium may include a propagated data signal with the computer usable program code embodied therewith either in baseband or as part of a carrier wave. The computer usable program code may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc.

Computer program code for carrying out operations of the disclosure may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The disclosure is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

As used herein an object request can comprise of an object instance identifier and object type which can be used to query the caching agent for a specific object instance. The method can utilize a schema to decompose object requests into constituent attributes based on the provided object type. Attribute values stored within the client side object cache can be retrieved and an object instance can be composed utilizing attribute values. The composed object instance can be conveyed to the client device. It should be noted attribute values are instance values associated with an object instance. For the purposes of clarity object instance and attribute value can be referred to as object and attribute henceforth.

In one instance the Web application can be an Asynchronous Javascript and Extensible Markup Language AJAX enabled application e.g. portal which can communicate heavily with a server side resource e.g. object server . In the instance the caching agent can permit object requests to be serviced by dynamically building the object being requested using cached attribute values.

In step an object request originating from a requesting entity can be identified. For example the requesting entity can be a widget component of a Web application. In step if the object instance is resident in cache the method can proceed to step else continue to step . In step the object can be retrieved from cache and conveyed to the requesting entity.

In step the object type being requested can be decomposed into attributes utilizing a schema. That is the request information can be used to identify the object type which permits disassembly into one or more attribute requests using an object model schema. For example the object request can be associated with a JAVASCRIPT OBJECT which can be decomposed into attributes using a JAVASCRIPT OBJECT NOTATION schema. In step an attribute is selected. Selection can be ordered or arbitrary depending on configuration parameters resource availability and the like. In one instance selection can be performed alphabetically based on attribute names. In another instance selection can be performed based on attribute occurrence within the schema e.g. first in first out .

In step an attribute index associated with the client side object cache can be queried for the attribute values. In one instance the attribute index can be a hash table comprising attribute information including but not limited to resource identifier e.g. application identifier attribute identifier e.g. attribute name attribute value e.g. alphanumeric value and the like. In step if the attribute instance exists within the index the method can continue to step else proceed to step . In step the attribute value can be retrieved from the index.

In step if more attributes are requested the method can return to step else continue to step . In step the object can be generated using attribute values retrieved from the index. It should be appreciated that the schema utilized in step can be reused to combine the component attribute values into an appropriate object instance. In step the generated object can be conveyed to the requesting entity.

In step an attribute request can be conveyed to a request aggregator. The attribute request can be generated by caching agent in response to attribute absence within the index. The request aggregator can convey one or more attribute request to an object server. In step the value of the attribute instance can be retrieved from the object server via one or more traditional communication mechanisms e.g. Hypertext Transport Protocol request . In step the attribute value can be cached with the appropriate identifier e.g. application resource identifier . The method can return to step where the method can continue to execute until object requests are ceased.

Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. Steps can be executed for each attribute comprising the object requested. When an attribute is not resident within the attribute index steps can be executed until all attribute are obtained. It should be appreciated steps and steps can be executed simultaneously and or in parallel.

In one embodiment caching agent can function as a transparent caching proxy able to dynamically provide object e.g. as cached object data for client . That is caching agent can act as an intermediary for Web server enabling server resources to be freed. It should be appreciated that client application widget configuration can remain unchanged to enable the functionally described herein to be achieved.

As used herein object can represent an instance of an object type within system containing instance values. Object can comprise of attributes which can be one or more data structures. Object can include data structures associated with one or more computer programming languages including but not limited to JAVASCRIPT JAVA 2 ENTERPRISE EDITION J2EE and the like. Data structures can include but is not limited to arrays associative arrays booleans strings integers and the like. Object can be associated with a schema which can describe the structure of the object . In one instance object can be user interface elements which can be rendered within an interface e.g. interface .

Communication between system components can conform to a Representational State Transfer REST architecture Simple Object Access Protocol SOAP framework and the like. Communication can be synchronous and or asynchronous contingent on application widget and or system architecture. Communication between system components can include but is not limited to Hypertext Transport Protocol HTTP HTTP Secure HTTPS and the like. System components can be communicatively linked via one or more networks including but not limited to public networks private networks virtual private networks and the like.

Request can be a communication message associated with application and or widget identifying an object instance and object type to be retrieved. Request can identify resources e.g. object instance via one or more traditional mechanisms including but not limited to Uniform Resource Identifier URI Uniform Resource Locator URL and the like. Request can comprise of HTTP methods including but is not limited to GET POST PUT and the like. In one instance request message body can contain object type information application identification information instance identifiers and the like. In one instance request can include but is not limited to an XMLHTTPRequest XHR HTTP request and the like. In the instance request can be an AJAX method which can be intercepted by caching agent . In one embodiment request can comprise of multiple object instances and or object types to be retrieved. In the embodiment the multiple objects can be iteratively retrieved from the cache via traditional object caching mechanisms and or disclosure specific caching functionality

Caching agent can be a client side hardware software entity able to dynamically generate cached object from attribute values within index . Agent can comprise but is not limited to request broker caching engine cache schema request aggregator and the like. In one instance agent can be a component of client interface an application and the like. In the instance agent can be a component of an API enabling widget to communicate with agent in real time to obtain generated object instance data. In one embodiment caching agent can be a component of an IBM WEBSPHERE middleware.

Request broker can be a hardware software component able to process object request . Broker can receive request which can be decomposed into an appropriate collection of attributes utilizing object type information from request and schema . Broker can iteratively query cache via communication with caching engine for each attribute in the collection. In one embodiment when an attribute value is not returned from the cache e.g. attribute does not exist in the cache broker can forward an attribute request to request aggregator . In the embodiment mapping information e.g. mapping associated with schema can be utilized to generate a server request . Upon acquisition of necessary attributes broker can reconstruct the required object which can be conveyed as object response . In instances where the object already is constructed and cached object broker can convey the cached object instance to application immediately.

Caching engine can be a hardware software component configured to manage cache and or cached object . Engine can respond to request broker communication and can retrieve cached object and or attribute values within index . Engine can utilize traditional and or proprietary caching mechanisms including but not limited to distributed caching peer to peer caching and the like. Engine can utilize any number of traditional and or proprietary cache expiration algorithms including but not limited to least frequently used LFU least recently used LRU most recently used MRU first in first out FIFO last access time object size and the like. Caching engine can be used to determine valid objects and or attributes within cache and or index . It should be noted that attribute level tracking can be disfavored due to excessive resource consumption but object tracking can be preferred to enable system functionality to be achieved.

In one instance a checksum associated with the cache object can be computed to determine the object usability. Checksum can be computed by any component within caching agent including but not limited to cache caching engine and the like. Checksum can be include but is not limited to a hash value an HTTP ETAG entity tag and the like. In scenarios where nested objects exist within an object a checksum can be computed using checksums of the nested objects. For example a checksum for an object instance e.g. object type can be computed using a checksum for a nested object instance e.g. object type .

In one embodiment a checksum can be computed to track object changes. In the embodiment the checksum can be compared against a server computed checksum associated with object to determine object modification occurrence. In one configuration of the embodiment when the object checksum and server checksum for object are not identical the attribute values within index can be invalidated and the relevant attribute requests can be conveyed to request aggregator.

Schema can be an entity describing the semantic and or structure of objects within system . Schema can include but is not limited to JAVASCRIPT OBJECT NOTATION JSON Extensible Markup Language XML schema and the like. Schema can be automatically and or manually generated based on the configuration of client agent and or system components. Schema can specify mapping information for conveying attribute requests to aggregator . For example mapping can be used to create an attribute request e.g. GET webapp ObjectService Article json.txt title HTTP 1.1 for an article object instance named json.txt.

Request aggregator can be a hardware software component for receiving and processing attribute requests e.g. requests from broker . Aggregator can convey attribute requests to server as server request which can be processed by server . In one embodiment aggregator can operate using a sliding window mechanism which can be configurable using settings . In the embodiment aggregator can package multiple attribute requests into a single server request based on the number of attribute requests a time duration and the like.

Settings can be one or more rules for establishing caching agent behavior and or functionality. Settings can enable flexible and robust configuration of caching agent . Settings can permit cache to persist object across instance sessions. For example when a widget is terminated object can remain within cache for use by other widgets executing within application . Further settings can be utilized to establish coherency policies when cache is a component of a distributed cache.

Index can be an organizational data structure permitting identification and retrieval of attribute values e.g. entry associated with an object e.g. object instance . In one instance index can be associated with a database which can include but is not limited to a Relational Database Management System RDMBS an Object Oriented Database Management System OODBMS and the like. For example index can be a database table stored within a database. It should be appreciated that index can be stored within cache network attached storage storage area network and the like. In one instance index can be annexed to a standard object cache permitting enhancement of an existing object cache while minimizing caching framework changes.

Client can be a hardware software entity able to execute application instance . Client can comprise of but is not limited to application instance interface and the like. Client can include but is not limited to a desktop computer a laptop a netbook a mobile phone a portable computing device a portable media player a portable digital assistant a tablet and the like.

Application can be a software entity comprising component widget which can manage widget . Application can include but is not limited to a Web page application a Web service a portal application a desktop application and the like. For example application can be a rich internet application enabling document editing and management e.g. office suite . In one instance application can be a widget toolkit widget framework and the like. In the instance application can be component of an application programming interface API for communicating with Web server .

Widget can be one or more executable components of an application . Widget can comprise one or more scripting languages including but is not limited to Dynamic Hypertext Markup Language DHTML JAVASCRIPT ACTIONSCRIPT and the like. For example widget can be a DHTML widget for presenting flight arrival information. In one instance widget can be a JAVA 2 ENTERPRISE EDITION J2EE applet JAVA 2 MOBILE EDITION J2ME applet and the like. In another instance widget can be a user interface element able to be rendered within an interface .

Interface can be a user interface able to present widget . Interface can include but is not limited to a Web browser an application interface an operating system interface and the like. In one instance interface can a renderable canvas associated with application and or widget .

Cache can be a hardware software component for temporarily storing cached object . Cache can comprise of but is not limited to cached object one or more client side objects and the like. Cache can include but is not limited to non volatile memory volatile memory and the like. Cache can be a traditional and or proprietary caching mechanism which can be configured through settings .

Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. In one instance application can be a widget comprising sub component widgets . It should be appreciated request aggregator can be a stand alone component network component distributed computing element and the like. Agent can be a network element distributed computing element cloud based network element and the like. It should be noted schema can be stored within a computing element associated with system which can include but is not limited to client agent data store network attached storage and the like.

The flowchart and block diagrams in the illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the disclosure. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

