---

title: Method and system for automatic detecting and resolving APIs
abstract: The present invention provides a mechanism for detecting and resolving Application Programming Interfaces (APIs) comprising: requesting a server device by a client device for the APIs supported by the server; and responding by the server with a list containing the identifiers of the APIs supported by the server, wherein each of the identifiers contains the network address from which the corresponding API definition document can be obtained. The proposed mechanism provides a systematic way to establish the consensus on API definitions between a client and a server even if the client, the server, and the API definitions are each developed by a different party. Therefore, this invention allows independently developed devices to be easily integrated into a system, in which a client device can automatically and correctly determine the APIs for communicating with a server device at runtime.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09323587&OS=09323587&RS=09323587
owner: NATIONAL TAIWAN UNIVERSITY
number: 09323587
owner_city: Taipei
owner_country: TW
publication_date: 20120927
---
The present invention relates to application programming interfaces APIs and more particularly to detect and to resolve APIs in a distributed system.

A distributed system is a network of electronic devices interconnecting with each other through the use of a network. The devices typically include computers ranging from personal laptops to large mainframes but may also include other forms of computing devices such as mobile phones and home entertainment devices. A server device in the system provides services to other devices in the network by accepting request messages sent from a client device over the network and performs actions according to the request message. For example a network printer may print out a document upon receiving a printing request a network camera may pan to the left upon receiving a panning request and a database server may return a list of sales records upon receiving a sales report request. To trigger such actions on a server a client device needs to know what actions are available on the server as well as the messages needed to trigger the actions. More specifically a client device needs to understand the application programming interfaces APIs of the server. With the knowledge of the server s APIs the client device may trigger actions on the server by using corresponding methods described in the APIs.

If a client device intends to communicate with a particular server which is known when the client device is being developed the knowledge of the server and its APIs can be built into the client device directly. For example a client device may be built to obtain map information from a particular web based map server to display restaurant locations on a map. Since the web based map server is chosen at development time the information such as the web server s access URL and its APIs can be compiled into the client device s program.

In many applications however the server s information is unavailable while a client device is being developed. For example different company s networks may have different printer servers network cameras or database servers. The information about these servers is available only when a client device is participating in the network at runtime but not at development time. Historically to build a client device to communicate with such servers the program in the client is built to work with a particular set of APIs and the client uses an API detection mechanism to interrogate whether a given server supports the APIs at runtime. Since a client device may encounter many different servers in different networks it is often preferred that the API detection mechanism can be applied to a wide range of servers. This is increasingly important with advances in the Internet and in mobility technologies in that a client device has the potential to communicate with any server in the world.

Unfortunately at present API detection mechanisms can only be applied to a very limited set of servers that are closely related to the client device during their development phase and may even produce faulty results when applying to other servers. This is because most API detection mechanisms require some server specific information in the client device. Such information is not available at runtime and therefore must be built into the client device beforehand.

For example with the current API detection mechanism a server may present its APIs to a client by giving the client a list of API names such as CORBA interface IDs or Java interface class names. The client then compares the names with the API names that the client recognizes. However the API definition that each name represents is available only at development time and the API definition information is compiled into both the client s and the server s programs such information is not obtainable through the detection mechanism at runtime. A foreign client device that does not have the same API definition information will not be able to know what the API names on the server represent. Worse yet the foreign client device may have a different API definition that happens to be assigned with the same name used by the server a situation commonly known as API naming collision. Consequently the foreign client device will mistakenly assume that the server supports the API definition known by the foreign client whereas the server actually supports a different API definition. That is the client and the server do not have the consensus on the definition of the API identified by the name.

For another example with the current API detection mechanism a server may provide the full definition of its APIs to a client such as a list of function names that can be called remotely. This method does not eliminate the need of having server specific information in the client device in that the client must know the intended use of the functions on the particular server. A function named draw on one server may produce graphic outputs whereas a function named draw on another server may end a chess game in a tie. Accordingly knowing that the API definition obtained from a foreign server contains a function named draw is not enough for a client device to perform graphic actions on a server whereas blindly calling the function on the foreign server may lead to unintended results. This problem is also caused by the lack of consensus on the API definition due to API naming collision.

The aforementioned problems make current API detection mechanisms difficult to apply in detecting a web server s APIs. The large number of web application servers in the Internet dramatically increases the possibility of API naming collision whereas reaching the consensus on API definitions among different web servers is difficult since each web server may be operated by a different party. Without the consensus on API definitions a client cannot reliably detect a foreign web application server s API at runtime and correctly communicate with the server thereafter.

Therefore what is required is a mechanism that allows a client device to automatically resolve the APIs of a server in such way that the consensus of API definitions can be established between the client and the server even if the client the server and the API definitions are each developed by a different party.

This invention relates to a method and system that allows a client electronic device to automatically determine whether a server electronic device can be communicated in accordance with certain API definition using the information obtainable at runtime. This is achieved by requesting a server device for the APIs it supports from a client device and the server device responding with information containing a list of API identifiers wherein each identifier contains the network address where the corresponding API definition document is reposited. The client device then associates the API identifiers with the API that the client understands to resolve available APIs for communicating with the server. Here the client understands the API means that the client supports the API and can communicate with a device in accordance with the API.

The essence of this invention is to use the network address from which an API definition document can be fetched as an API identifier to assist the API detection and resolving process. Using such identifier is superior than using an arbitrary name in that the identifier establishes the consensus on the API definition among clients and servers referencing the API with the identifier since all devices are able to fetch the same copy of the API definition from the identified network address. Different APIs are reposited at different network addresses. Hence the use of such API identifiers is not subject to API naming collision. The API identifier also establishes the authority of the API definition because only the party that controls the device providing the API definition document at the identified network address can make changes to the API definition. Accordingly different servers will not be able to provide inconsistent definition documents to the same API identifier using this method thereby establishing the consensus on the API definition corresponding to the API identifier among devices.

In this invention one API can be extended from a list of original APIs to add extra communication actions to the original APIs the API with the extra actions is called an extended API whereas the original APIs are called the parent APIs of the extended API. The definition document of an extended API contains the definitions of the extra communication actions along with a list of network addresses each of which is the API identifier of a parent API. A server supporting an extended API can be communicated with the extra actions as well as all the actions defined in the extended API s parent APIs.

By listing the API identifiers of the parent APIs in an extended API s definition document this invention further allows a client electronic device to automatically resolve its API compatibility with a server electronic device even in the event that a server s API identifier is not directly recognized by the client. A client can investigate an unrecognized API identifier by recursively tracing the definition document corresponding to the unrecognized API identifier. The recursive tracing procedure is as follows the client fetches the API definition from the network address pointed to by the unrecognized identifier. If the definition contains a list of parent API identifiers that the API in question is extended from and client recognizes any of the parent API identifiers the client can communicate with the server through the recognized parent API. If the client device does not recognize the parent API identifiers in the list either the client may further fetch their API definitions which may contain even more parent API identifiers to be investigated. This recursive procedure goes on until the client recognizes a parent API identifier or all obtained parent API identifiers are investigated. Note that the APIs corresponding to all parent API identifiers obtainable through the recursive tracing procedure are all called the parent APIs of an extended API.

This invention also includes a method and system that allows a client electronic device to automatically discover a server electronic device that supports a particular API in a network. In the event that a client device seeks a server device that supports a particular API the client device sends a broadcast message containing the aforementioned API identifier of the API to all devices in the network. A server receiving the message will determine the compatibility between the requested API and the server s APIs and will report the server s network address to the client if the server determines that they are compatible.

The detailed embodiments accompanied with the drawings will illustrate the present invention. It is to be noted that the embodiments of the present invention are exemplary and the present invention is not limited to the embodiments. The embodiments provided make the disclosure of this invention full and clear therefore those skilled in the related art can make and use this invention.

In this invention the client electronic devices and the server electronic devices are devices with computing power and connecting to networks such as personal computers mainframe computers mobile phones home entertainment devices or embedded devices with computing and networking capabilities. Whether a device is a client device or a server device depends on the device s role in a particular operation a device making a request is called a client device whereas a device responding to the request is called a server device. One device can be a client device in one operation but becomes a server device in another operation. For example a network printer is a server device when responding to printing requests whereas the same printer becomes a client device when requesting date and time information from a network time server.

The API definition document is reposited in a host computer in the distributed system and a is the network address from which document can be fetched in the system . Many standard technologies allow the computer to provide the document over the network. For example computer may have a web server running on it and provides the document over HTTP upon request. In such case a is the HTTP URL address where the document may be obtained from the web server. Here a is also used as the API identifier that represents the API definition described in the document . We call this API as API a for brevity in this discussion.

The client device is built to communicate with any server that supports API a . When developing the client a programmer fetches the API definition document from the network address a step I and the computer will return a copy of the document step II . The programmer then builds the client program that is able to send communication actions to a server in accordance with the communication methods described in the document . The API identifier a is also included in the client program to be used in the API detection process.

The server device is built to support API a which means that the server will accept requests and produce responses in accordance with the API definition document . When developing the server a programmer fetches the API definition document from the network address a step III and the API definition document is returned from the computer step IV . The programmer then builds the server program based on the API definition. The API identifier a is also included in the server program to be used in the API detection process.

It should be noted that the API definition document used in this invention needs not contain the program code that is capable of carrying out the defined communication actions. Different client devices may have different programs written in different programming languages to implement the communication actions in accordance with the API definition document. Similarly programs in different server devices may also be written in different programming languages to communicate with clients in accordance with the API definition document.

At runtime the program on server starts listening to network requests. The client device received the network address of the server from sources such as user inputs configuration files or from communicating with another server. The client then intends to communicate with the server . Since the client has never communicated with the server before the client needs to detect the APIs of the server and to resolve whether API a that the client understands is one of the APIs supported by the server. Accordingly the client sends an API inquiry request to the server step V and the server returns a server specification document step VI . It should be noted that the mechanism for sending the API inquiry request depends on the network protocol between the client and the server . For example the server may be a web server using HTTP protocol and the server s HTTP URL location is given to the client . In such case the API inquiry request sent from the client is just a standard HTTP GET request sent to the server s URL location and the server will return the document in an HTTP response message.

A server specification document contains a list of API identifiers corresponding to the APIs which the server supports and optionally a list of communication action definitions specific to the server that are not part of the listed APIs. A server may support a number of APIs and their API identifiers are listed in the server s specification document. The server specification document may be created during the development of the server or be generated at runtime by the server program from the list of API identifiers that the server supports.

In this embodiment the specification document contains the API identifier a . Once the client obtained the document the client compares the API identifiers listed in the document with the API identifier a . If the identifier a matches an API identifier listed in the document the client concludes that the client may communicate with the server by using methods described in API a . For example if the API a contains the definition of a remote function the client device may call the remote function on the server . It should be noted that a client may be built to support multiple APIs and will determine whether each API is supported by a server then select the supported APIs to communicate with the server accordingly.

The significance of this API detection method lies in that the client does not need to have the knowledge of the information pertaining to the server built into the client program to correctly detect the server s APIs. By recognizing the API identifier a from the server specification document at runtime the client has great confidence that the server supports the same API definition as that understood by the client because the API identifier a explicitly points to the API s definition document . This allows the client and the server to be independently developed by different developers who share little information between them and yet their products may communicate with each other correctly.

It should be noted that the host computer may be operated by a third party that is different from the developers of the client or the server. Accordingly neither developers of the client or the server can alter the definition of API a since only the one who operates the computer has the right to modify the API s definition document . In other words only the operator of the host computer has the authority over the API a s definition. This ensures the consistency of the overall system in that no one else may give API a a different definition.

Nonetheless the operator of the computer may still make change to the document and therefore alter the definition of the API a perhaps to add new functions or to fix problems. A device built with an old version of the API a will not be able to correctly communicate with devices built with the latest version of the API. In light of this the program in a device may fetch the API definition document periodically at runtime and compare it to the version used when the program was built to detect changes in the API a s definition. Here the client device and the server device can each periodically fetch the document at runtime and perform the aforementioned comparison to ensure that the API a understood by the device is consistent with the current definition of API a or trigger actions to deal with the changes such as notifying the developer. In any case there will be no confusion as to what the latest definition of API a is since the latest version is always the document currently available on the computer .

It should also be noted that devices in the distributed system may be interconnected by homogeneous as well as heterogeneous networks. That is the client the server and the host computer need not be interconnected with the same network technology. For example the client may use the Bluetooth technology to communicate with the server whereas the computer is on the Internet accessible through the TCP IP protocol. The client may obtain the server specification document over a Bluetooth connection whereas the API definition document is fetched through HTTP over a TCP IP connection. Each API identifier listed in a server specification document may reference the network address in a different networking technology. Similarly each parent API identifier listed in an extended API definition document may also reference the network address in a different networking technology.

The client device is built to communicate with any server that supports the API b . At runtime the client device receives the network address of the server from sources such as user inputs configuration files or from communicating with another server. The client then intends to communicate with the server . The client needs to detect the APIs of the server and to resolve whether API b that the client understands is one of the APIs supported by the server . Accordingly the client sends an API inquiry request to the server step I and the server returns the server specification document step II which contains a list of API identifiers c and d . Since neither identifier c nor d matches the API identifier b understood by the client the client needs to further investigate whether API c or API d is extended from API b and therefore is compatible with API b .

One API may be extended from a second API by adding extra features such as a list of extra function names with their respective input and output data types that may be called on the server a list of extra properties that may be read from or write to the server and a list of extra special data type definitions that may be used in the communication and so on the first API is called an extended API and the second API is called the parent API of the extended API. An extended API may be extended from a number of parent APIs. A server supports an extended API may be communicated with extra features defined in the API as well as all actions defined in the API s parent APIs. The purpose of an extended API is to allow a server to support the extra features in the API while still being compatible with client devices that only understand the extended API s parent APIs. For example an old API may allow a client device to search music albums on a server device by album titles whereas a new extended API may extend the old API and add a search by artist name feature clients that understand the new extended API will be able to search by album titles and artist names whereas clients that understand only the old API can still search by album titles.

The API definition document of the extended API contains a list of network addresses each of which is the API identifier of a parent API along with the definitions of extra communication actions such as a list of function names with their respective input and output data types that may be called on the server a list of properties that may be read from or write to the server and a list of special data type definitions that may be used in the communication and so on. It should be noted that the API extension relationship may extend beyond one level in that one API is extended from a parent API which in turn is extended from yet another parent API and so on. All APIs that an extended API directly or indirectly extended from are called the parent APIs of the extended API.

In this embodiment the client needs to determine whether API c or API d is extended from the API b understood by the client. To investigate API c the client sends a request to the network address c step III to fetch the API definition document from the host computer step IV . Here the API definition in the document does not list API b as a parent API. Therefore the client determines that API c is not extended from API b . Subsequently the client investigates API d by sending a request to the network address d step V to fetch the API definition document from the host computer step VI . In this embodiment the document lists the API identifier b as a parent API. Therefore the client determines that API d is extended from API b . Accordingly the client concludes that it may communicate with the server in accordance with API b since the server supports API d and API d is an extension to API b . The client may choose to store the documents and in the device for a period of time so that the client does not need to obtain them again when the definition of API c or d is needed later.

It should be noted that the definition document of an API and all its parent APIs may be reposited on different host computers controlled by different parties. In this embodiment API b and d are reposited on host computers and respectively and each computer may be controlled by a different party. Accordingly even though the party controlling the computer has the authority over the definition of API d the party has no authority over the definition of its parent API b . That is even though the party may modify the document to alter the definition of API d such as modifying communication actions pertaining to the API d or even removing the API identifier b from the list of its parent APIs in no way the document will affect the definition of API b which is defined in the document . This is a clear benefit of using the network address where an API definition document can be obtained to identify the API because the API s definition remains consistent throughout the distributed system regardless of where it is referenced.

In this embodiment the client also receives the network address of the server and intends to communicate with the server . The client sends an API inquiry request to the server step VII and the server returns a server specification document step VIII which contains the API identifier c . To determine whether API c is extended from API b the client may use the API definition document already reposited in the client device after detecting the APIs of server or fetch another copy of the document again from the network address c . Either way the client will know that the API identifier b is not listed as a parent API of API c in document . Since API c is the only API supported by the server the client concludes that it may not communicate with the server in accordance with API b .

In the first two embodiments of the present invention before communicating with a server device if a client lacks the information of the APIs supported by the server the client needs to send an API inquiry request to the server to detect the server s APIs. This may be time consuming if there are many servers the client needs to investigate. Therefore in the third embodiment of the present invention another method related to determining the support of an API on a server is broached.

The client device is built to communicate with any server that supports the API definition which is identified by the API identifier e . At runtime the client device receives the address information of the server and from sources such as user inputs configuration files or from communicating with another server. The client then intends to communicate with the servers. In this embodiment the address information received by the client are in a compound format wherein every compound address includes the network address of the server and a list of API identifiers of the APIs that the sever supports. In this embodiment address server encoded t address server encoded t and address server encoded t are three such compound addresses. In every compound address the portion before the symbol is the network address of the server and the portion after the symbol is an encoded string of the API identifiers that the server supports. It should be noted that different compound address formats may be used in the client device and the format selection is subject to the support of the client program as well as the network address format used in the system. For example in a system wherein the server address and the address t are all HTTP URLs the compound address may be constructed by concatenating the server s URL the symbol and an encoded string of URL t using the standard percent encoding mechanism defined in the URI specification.

In the event that the client device intends to communicate with the server identified by the compound address address server encoded t the client decodes the compound address into the network address of server and the API identifier t . Accordingly the client knows that the server supports API t . Since the client does not recognize the API identifier t the client sends an API inquiry request to the network address t step I to fetch the API definition document from the host computer step II . In this embodiment the document lists the API identifier e as a parent API of API t . The client therefore concludes that it may communicate with the server using API e since the server supports API t which is extended from API e .

Subsequently when the client decodes the compound address address server encoded t and address server encoded t the client knows that it may also communicate with server and server using API e since their compound addresses indicate that both servers support API t . With this method the client is able to resolve its API compatibility with the server and without obtaining the server definition document and from each server respectively therefore efficiency is enhanced.

The API identifiers in L are analyzed as follows. An API identifier w in L is chosen and removed from L step X . If the chosen identifier w equals a the procedure ends immediately and concludes that the server identified by n supports API a and the server may be communicated at network location r step XX . If the chosen identifier w is not equal to a w will first be added to the list V step XII and then examined whether the definition document of API w has been obtained before step XIII . If it has not been obtained before a network request will be sent to network location w step XIV and the definition document of API w will be received in the response message step XV . If the definition document contains a list of API identifiers representing the parent APIs from which API w is extended step XVI all these parent API identifiers are added to L step XVII . L is then examined to remove any API identifier in L that also exists in V step XVIII . The steps IX to XVIII are repeated until either one API identifier in L matches a or L becomes empty and still no identifier matches a . In the latter case the procedure ends with the conclusion that the server identified by address n may not support API a step XIX .

In the first three embodiments of the present invention the network address of a server is given to the client device through means not controlled by the client device such as user inputs or configuration files. In the forth embodiment of the present invention a method to automatically discover the network address of a server that supports an API is broached.

The client device is built to communicate with any server that supports the API f . To discover servers in the system that supports API f the client sends a broadcast request message to all servers in the network step I wherein the broadcast message contains the API identifier f and the network address of the client . The broadcast message requests all servers in the network that support API f to report their network addresses to the client . It should be noted that the mechanism to send out the broadcast message depends on the type of network used in the system .

A server device that allows its existence to be automatically discovered has program code constantly listening to broadcast messages in the network. In this embodiment server device and are all listening to broadcast messages. The server supports API f therefore upon receiving the broadcast request message sent from the client looking for servers that support API f the server sends a response message containing the network address of server to the client step II . The server supports API g which is an extended API of API f . Upon receiving the broadcast request message sent from the client the server knows that even though the server supports API g it can still be communicated with the requested API f from which API g is extended so the server sends a response message containing the network address of server to the client step III . The server supports API h which is not an extension to the API f . Accordingly the server makes no response upon receiving the broadcast message from the client . After receiving the response messages sent by the server and the client obtained the network addresses of server and and the discovery process is completed. The client may then communicate with server and in accordance with API f .

It should be noted that the broadcast request message sent by a client device may contain more than one API and Boolean conditions may be used to express the requirement of the request. For example the broadcast request message sent to the network of the system may request servers that support either API g or API h to respond or request servers that support both API g and API h to respond. In the former case both server and will respond while in the latter case no server will respond as none of them support both API b and API h .

It should also be noted that the network used for discovering servers does not need to be the same as that used for repositing API definitions. For example the client and the servers and may be interconnected by the IEEE 1394 bus whereas the host computers and are on the Internet reachable through the TCP IP protocol. In such case the steps I II and III discussed in this embodiment are performed within the IEEE 1394 bus whereas the client and the servers may each fetch API definition documents over the Internet.

By the methods and systems demonstrated in the embodiments of the present invention a client device can easily detect and resolve application programming interfaces of a server device based on the information obtained through the API detection process. More importantly the consensus of API definitions between the client and the server can be established because the identifier used to identify an API clearly points to the API s definition document. With the ability to establish the consensus on APIs the client device the server device and the API definitions can each be developed by a different party and yet the devices can still be incorporated into a system and communicate with each other correctly. As a result the method suits well to large scale distributed systems wherein many independent parties are involved.

