---

title: Secured execution of a web application
abstract: Methods and nodes for securing execution of a web application by determining that a call dependency from a first to a second function needs to be protected, adding a Partial Execution Stub (PES) function comprising code to establish a communication connection with a trusted module. Methods and nodes for secured execution of a web application by invoking a function of the web application, invoking a Partial Execution Stub (PES) function during execution of the function of the web application, sending, from the PES function, a message call with current execution information to a trusted module and receiving, a verification result from the trusted module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471776&OS=09471776&RS=09471776
owner: Irdeto B.V.
number: 09471776
owner_city: Hoofddorp
owner_country: NL
publication_date: 20120330
---
This application is the National Stage of International Patent Application No. PCT CA2012 000297 filed Mar. 30 2012 the disclosure of which is hereby incorporated by reference in its entirety.

Wireless interconnectivity and devices are dominant technologies being deployed and used in everyday life whether for business use or personal use. In addition cloud computing is changing information cultures and is part of an emerging business strategy for a new delivery model for Internet based computation services application software data access and storage. Security associated with untrusted environments becomes challenging. Traditional computer and network security schemes are inadequate to address vulnerabilities and attacks associated to these untrusted systems.

A web application is an application that is accessed over a network such as the Internet or an intranet by using web browsers and is coded in a browser supported language such as JavaScript combined with a browser rendered markup language like HTML . The web application relies on a common web browser to render the application executable. The ability to update and maintain web applications without distributing and installing software on potentially thousands of client computers is a key reason for their popularity as is the inherent support for cross platform compatibility. Compared to early HTML and JavaScript to the latest HTML5 latest web applications are becoming platform and browsers independent. Browsers are also providing application execution environments. When compared to native execution environments secured execution of a web application provides new challenges. Pressure is greater than before on mobile device manufacturers whether smart phones or tablets and network operators to maintain costs at the lowest possible level. Yet execution of the same web application should provide the same functionality no matter what device it is executed on. For lower end devices resources are usually more limited which creates additional pressure on the web applications.

For example KJava on Symbian platform is a scaled down Java Virtual Machine JVM designed for mobile platforms. KJava contains a subset of the Java 2 Standard Edition J2SE packages and implements restricted Mobile Information Device Profile MIDP and restricted Connected Limited Device Configuration CLDC profiles. For instance restrictions include 1 no support for Java Native Interface JNI 2 limited reflection capabilities e.g. limited ability to examine or modify runtime behavior 3 no custom class loaders e.g. no ability to fine tune behavior of the class loader .

Exemplary limitations related to execution resources or environment restrictions have been mentioned and are of particular relevance in the context securing web application execution which is generally addressed in the present application.

The present invention aims generally at providing protection techniques to secure execution of web applications within non native execution environments. In general a client device should support running applications on line internet connected or off line not internet connected . Securing the execution of such applications should be persistent no matter whether it runs on line or off line. The present invention provides a general framework that allows for secured execution of an application on line or off line although the protection techniques can leverage specific aspects of on line or off line execution.

A first aspect of the present invention is directed to a method for securing execution of a web application comprising. The method comprises on a processor of a client device invoking a function of the web application. The method follows with on the processor of the client device invoking a Partial Execution Stub PES function during execution of the function of the web application. The method then continues from the PES function with sending a message call with current execution information related to the web application. The message call is sent to a trusted module. A verification result is thereafter received by the PES function from the trusted module related to the message call.

Optionally the method may also comprise establishing by the PES function a communication connection with the trusted module. In this option the message call is sent via the socket connection and the verification result is received via the communication connection. The communication connection may be a local or remote socket connection or a websocket connection that can be used for both local and remote connections. The trusted module may be executed on a server node or locally in the client device.

In one option a second message call is sent to a second trusted module from the PES function with further current execution information related to the web application. For instance the second trusted module may provide at least one function not offered by the trusted module. The PES function may thereafter receive a second verification result from the second trusted module related to the second message call.

In another option the PES function may forward the message call with current execution information related to the web application to a second trusted module in response to the verification result. For instance the second trusted module may provide at least one function offered by the trusted module and the verification result may indicate that the required processing was not performed by the first trusted module or indicate that a timeout from the trusted module was received as the verification result. The PES function may thereafter receive a second verification result from the second trusted module related to the forwarded message call.

Optionally the verification result may indicate tampering of the web application in which case the method may further comprise from the PES function invoking a mitigation action. The mitigation action can vary and may involve e.g. returning incorrect next function information returning an invalid function definition or returning a standard error function or result causing the application behavior to fail immediately fail gradually or execute incorrectly.

The verification result may alternatively comprise a next function information to be invoked for the web application. In this latter case the method may follow with invoking the next function. The method may also follow with returning a function to the web application for injection into the web application and subsequent invocation.

A second aspect of the presented invention is directed to a method executed in a network node for converting a web application to a secured web application. The secured web application may be obtained by applying static and or dynamic processing techniques. The determination of what combination of processing techniques depends on implementation choice being the web application. In this second aspect the processor is exemplified as securing the web application in a static manner. For instance the processing is applied to the web application prior to deploying the web application.

The method comprises reading at the network node code of the web application from a memory unit. The code comprises more than one function. Thereafter the method continues with determining from a function call graph of the web application that at least a call dependency from a first function to a second function of the more than one function needs to be protected. The web application is thus modified into the secured web application code by adding to the code of the web application a at least one Partial Execution Stub PES function comprising code to establish a communication connection with a trusted module. The PES function requires interaction with the trusted module. The web application is further modified into the secured web application code by modifying code of the web application by replacing invocation of the second function from the first function with invocation of the PES function from the first function and generating a set of rules from the function call dependency graph to define the call dependency from the PES function to the second function. Thereafter the method follows with at the network node storing the secured web application into the memory unit and the set of rules into the memory unit. Once the secured web application is obtained it may be delivered to one or more client device.

Optionally a plurality of PES functions may be present and each one of those may be related to a call dependency.

Optionally generating the set of rules is performed by generating a symbolic Partial Execution Flow Map PEFM and storing the set of rules into the memory unit is performed by storing the symbolic PEFM into the memory unit. Generating the set of rules may further comprise taking security requirements related to security actions and mitigating actions into consideration.

As another option the first function and the second function may be present in the code of the web application as a single function. The method may thus further comprise splitting the single function into the first and second functions based on an asset being processed in the single function.

The set of rules or the symbolic PEFM may comprise a record comprising a current caller element identifying the first function as a current calling function requiring an inquiry before invoking the second function a current PES element identifying the PES function as invoking the trusted module to trigger the inquiry a next function element identifying the second function and providing information necessary for invocation of the second function an element of trusted functions identifying a set of functions that are linked with the trusted module and can be executed by an invoking mechanism within the trusted module and a security actions element identifying a set of security features that the trusted module is capable of executing prior to returning a result of the inquiry.

The method may also optionally comprise signing the secured web application prior to storing and encrypting set of rules prior to storing.

A third aspect of the present invention is directed to a trusted module for securing execution of a web application executing on a client device. The trusted module comprises a connection module a function call module and a verification module.

The connection module is for receiving a communication connection request from a Partial Execution Stub PES function of the web application. The function call module is for receiving a message call from the PES function via the communication connection. The message call comprises current execution information related to the web application. The verification module is for determining based on the current execution information a next function to be executed for the web application and sending a result of the determination to the PES function via the communication connection.

The trusted module may be executed on a server node remote from the client device executing the web application or on the client device. The trusted module may further comprise a security module comprising secured functions and pre defined mitigating actions.

Optionally the result of the determination may indicate tampering of the web application. Alternatively the result of the determination may comprise a next function information to be invoked for the web application.

The connection module may optionally further establish a connection with a second trusted module in order to obtain the verification result. The second trusted module may provide at least one function offered by the trusted module and or at least one function not offered by the trusted module.

A fourth aspect of the present invention is directed to a client device comprising a network interface module and a processor executing a web application. The network interface module opens a communication connection between a Partial Execution Stub PES function and a trusted module. The processor executes the web application by invoking a function of a web application invoking the PES function during execution of the function of the web application sending a message call from the PES function with current execution information related to the web application to the trusted module via the communication connection and receiving a verification result from the trusted module related to the message call.

The verification result may indicate tampering of the web application in which case the processor may further execute a mitigation action. Alternatively the verification result may also comprise a next function information to be invoked for the web application in which case the processor further invokes the next function.

A fifth aspect of the present invention is directed to a network node for converting a web application to a secured web application. The network node comprises a memory unit and a processor for securing the web application.

The processor is for securing the web application by determining from a function call graph of the web application comprising at least a call dependency from a first function to a second function of the more than one function that the call dependency from the first function to the second function needs to be protected and modifying the web application into the secured web application code. Modifying the web application into the secured web application code is performed by adding to the code of the web application a partial execution stub PES function comprising code to establish a communication connection with a trusted module. The PES function requires interaction with the trusted module. Modifying the web application into the secured web application code is further performed by modifying code of the web application by replacing invocation of the second function from the first function with invocation of the PES function from the first function and generating a set of rules from the function call dependency graph to define a call dependency from the PES function to the second function. The processor is further securing the web application by storing the secured web application and the set of rules into the memory unit. In the fifth aspect the processor is exemplified as securing the web application in a dynamic manner. For instance the processing is applied prior to sending the web application to the client device but after the web application is installed on a network node.

Optionally generating the set of rules may further comprise taking security requirements related to security actions and mitigating actions into consideration.

Optionally generating the set of rules is performed by generating a symbolic Partial Execution Flow Map PEFM and storing the set of rules into the memory unit is performed by storing the symbolic PEFM into the memory unit.

As another option the first function and the second function are present in the code of the web application as a single function. The processor is further splitting the single function into the first and second functions based on an asset being processed in the single function.

The processor may further sign the secured web application prior to storing and encrypt the set of rules prior to storing.

Computer programs are generally expressed in some abstract language. The language can be translated using a series of compilation and linking steps to a binary code that can be executed or interpreted by a computer or other processing devices . The programs can also be compiled into a virtual machine instruction set that can be executed on a virtual machine interpreter. Some programming languages do not require the compilation and linking steps but are interpreted by a language specific interpreter.

Protecting interpreted code is a difficult problem as the source code of the application is available at the client and the application has no direct access to the machine hardware.

A known attack technique is to analyze the control or logical flow of an application. In order to prevent an attacker to analyze the logical flow of the application it is possible to remove the control flow from the program and replace it with a runtime access to an address server that provides the application with the information required to continue execution. Such possibility is currently only available for native execution environments and not to non native languages and environments.

It is possible to perform some functions at a remote computer with special resources which cannot be easily and or efficiently be transferred to a client. The details of the remote functions cannot easily be observed by an attacker. Some examples of this technology are Remote Procedure Calls RPC Common Object Request Broker Architecture CORBA and Simple Object Access Protocol SOAP .

Trust modules are used in various applications and take the form of smart cards dongles and cryptographic modules. These are commonly used to perform some attack sensitive functions. Moving these functions to a more attack resistant environment increases the security of the application executing in a more open execution environment. Digital Rights Management DRM clients implement similar trust module functions using software. It is possible to have a software application implementing a standard decoder for compressed video streams where some data structures in the standard decoder need to be adapted by software executing in a more tamper resistant environment.

There are security problems in securing execution of non native applications. For instance non native execution environments such as web browsers JVM and other scripting environments are much less secured than native execution environments. Exemplary causes include 

1. In interpreted languages attackers can access a high level language description of the application and modify underlying code and execution logics including control flow and decision information.

2. Non native applications are shielded from the details of the underlying hardware or operating system. The non native applications do not directly access security resources provided by the computing platform and do not use strong protection enabled by and built up on the native computing platforms.

3. An application engine a virtual machine run time environment or scripting engine is not typically designed and implemented with necessary requirements for white box security and self protection. Although they may introduce certain security they typically only address certain man in the middle vulnerabilities. A fundamental security weakness is typically a good place to start for an attacker that wishes to hack an application.

4. Many well developed or commercialized software security and protection techniques designed to protect native code cannot be directly adapted to non native execution environments.

Another example of security problems related to securing execution of non native applications is that the execution of a non native application typically involves different pieces of software. The different pieces of software are usually provided in different forms and perform interactions at different execution stages. For instance it is typically easier to do snip and spoof attacks to non native execution logics compared to native executables. It is likely more difficult to maintain the integrity of the execution of a non native application.

Yet another example of security problems related to securing execution of non native applications is that many security features and protection mechanisms need to be triggered or involved from the protected execution of a non native application. If the security features are not tightly integrated and interwoven with the original functional execution logic of the non native application they can easily be skipped or removed from the protected execution leading to the overall security from such protections being compromised. Hence securing execution against any attack in the protected execution shall result into failure of the protected non native application to execute thereby preventing attacker to achieve the goals and access protected assets.

It is possible to use a trusted module to extend its security services to a non native application. The trusted module should be a well protected component and provide a set of protections. The trusted module may provide for a trusted zone as a root of trustiness extending to a non native application by an execution enabling mechanism between the non native application code and the trusted module.

The present invention aims at securing applications by moving control flow decisions and sensitive functions from the actual application to a trusted module generating an adapted application and protected data that needs to be processed by a trusted module. In general this objective is achieved by interlacing application code non native side and trusted module can be native side or non native or in other forms including implemented in hardware by using partial execution dependencies which are processed and generated statically or dynamically by a tool. After this processing the new adapted application code only contains incomplete execution logics. The remaining execution logics and certain sensitive functions are represented in partial execution dependencies that can be managed and accessed only by the trusted module and not directly from the protected non native application code.

For instance during execution an adapted e.g. secured application connects to the trusted module and transmits its current point of execution and some context information. The trusted module processes the context data based on the current point of execution and the protected data which may include code for the trusted module. With this mechanism the real execution of the protected application may be constructed dynamically by using partial execution dependencies by interacting with the trusted module. As a result the adapted application obtains modified context information and a new control point where the adapted application continues its execution.

There is no static view of execution logics presented fully by the protected application code. At any state of the execution only current partial execution becomes visible within the non native execution environment.

An original execution flow is protected by execution within the trusted module. The trusted module can be connected by using an execution enabling mechanism e.g. an Application Programming Interface API between the protected application and the trusted module e.g. JNI between Java and native code or communication channels such as sockets or remote connections to connect the protected application and the trusted module. In the example of HTML5 environment Websocket can provide a connection to serve both local and remote communications between an application and trusted modules. It is possible to use a WebSocket API to connect a HTML5 web application with a local or and remote trusted module or connect a local trusted module with a remote trusted module. Such a communication capability can empower simplify and standardize some implementation of this invention. Secured application that would be subjected to an attack e.g. to hacking such as trying to skip execution through the trusted module may thus cause wrong behavior or incomplete execution of the original application. This technique is thus able to improve trustworthiness of distributed application execution compared to current mechanism.

Connection methods to bridge execution between the protected application and the trusted module may require design and implementation of partial execution dependencies. If there is an execution extension interface between non native and native such as JNI partial execution dependencies can be represented directly in code form or through more advanced protections. If there is no such execution interface such as kJava environment or HTML5 Websockets in a web browser environment partial execution dependencies need to be represented as symbolic forms that can be passed by communication channels. In HTML5 protections can be further enhanced by providing function decryption during execution such that the function is unencrypted and dynamically loaded into the web browser page.

The present invention extends the function of an external trust module with root of trustiness and secured capabilities. The trusted module calculates a next execution point for the execution interpretation and processes context information that allows the trusted application to implement some security sensitive operations and return modified context information.

As the attacker can no longer easily observe the functional processing in both the adapted application and trusted module the application is more difficult to reverse engineer.

From a programming perspective a function routine is one of most basic and important functional constructs of software. In general a call dependency of an application code contains one of most important execution logics that layout structural relationship between different functions that are functional components. Executable code by nature self contains such a dependency. Therefore it is relatively easy to alter the execution by modifying call dependency to tamper original execution. From security requirements certain functions are critical because they involve valuable digital assets such as crypto keys IP algorithms bank account numbers login passwords proprietary business logics etc. that require necessary protection. From attacking purpose those functions become main targets for attacks. Securing the execution is to protect those functions and call dependencies between those functions to guarantee the integrity of the original execution of the application.

Reference is now made to the drawings in which shows an exemplary overview of securing execution via dynamic partial execution. shows a non native execution environment a trusted module a communication e.g. socket connection between the non native execution environment and the trusted module and a secured storage . Upon analysis of the call graph of a non application code it is possible to replace some call dependencies of specific functions e.g. that can be identified and specified by a user into symbolic Partial Execution Flow Map PEFM . The original calls are then replace with partial execution stubs PES . . . that can bridge invoking relationship between protected function codes via the trusted module . During run time of the protected application when executing a protected function F1 that intends to invoke next function F2 that is also protected F1 actually invokes a particular PES such that it holds the current execution and sends a message call with current execution information through the communication connection to the trusted module to inquire a next method to be executed. The trusted module will use the current execution information to search the next function to be executed from a secured PEFM . If the search is successful the trusted module can perform some security features for example integrity verification and anti debug before returning the next function information to be invoked as the result back to the PES via the communication connection . If the search failed it indicates that the current call dependency is tampered and an attack is detected. A designated mitigation action may thus be taken by the trusted module. After the PES receives the next function information the PES passes necessary parameters and invokes the particular function accordingly in order to continue the execution of this protected application .

The following list includes exemplary advantages which may be provided by different embodiments of the present invention 

For security requirements if a function contains a number of assets that are processed within some important code segments it is likely to be more secure to split the function into smaller functions in order to leverage interlacing capability using dynamic partial execution interlacing. Examples of assets that are likely to require protection include crypto keys IP algorithms bank account numbers login passwords and proprietary business logics.

1. Current caller specify the name of current calling function that requires an inquiry for next function to invoke.

2. Current PES stub specify the name of the current PES stub to invoke the trusted module to trigger the inquiry.

3. Next function specify necessary information of next function to be invoked by current caller. For different non execution environment the information can be different. For example in a JVM the information of next function may contain class name and method name whereas in HTML5 it may contain a page or document object model of the web page and the javaScript function name.

4. Trusted functions specify a set of functions that have been linked with the trusted module and can be executed by invoking mechanism within the trusted module. Normally these functions are some special functions offered by the trusted module or some original functions have been implemented in a way that can be loaded into the trusted module. Trusted functions can be deployed with the trusted module at installation time and or dynamically linked with the trusted module at runtime. The nature of types of trusted functions and how they are deployed can be dependent on the trusted module implementation. Exemplary trusted functions include cryptographic operations and integrity verification functions. In addition while processing a web application it may be possible to analyze a web page content and extract sensitive functions for trusted function invocation. These trusted functions can be delivered to the trusted module in encrypted form and loaded decrypted and executed by the trusted module.

5. Security actions specify a set of security features that the trusted module can do prior to returning search result. It is optional and up to user s requests during build time. Also it can be driven by security policy.

Reference is now made concurrently to which respectively show an exemplary original function dependency and an exemplary protected application code with incomplete partial. The example of is useful in illustrating partial execution flow in more details.

A processing tool can take the following steps to generate the protected application code only with partial execution and a symbolic PEFM 

Step 1 If necessary do function splitting based on some security requirements. This step is not required in the present example.

Step 2 Analyze the call graph and identify the important functions and their call dependencies for protection by requests from a user as input options and configuration to the tool. In the present example we would like to protect F1 and F2 and call dependencies of F1 calling F2 F1 calling F3 and F2 calling F3.

3. Step 3 For each of functions to be protected and for each calling dependency that requires to be protected

a. A PES function is created. The PES function can accept real parameters from caller function and pass them to the callee function that will be dynamically determined. Also the PES function needs to facilitate the communication with a communication e.g. socket connection with the trusted module. For example for F1 calling F2 we create F1pes2 stub function.

c. A record of PEFM is created with filling necessary information. For example on F1 calling F2 the record of PEFM can be set as follows 

Step 7 Perform the signing to protected code of the non native application and generate integrity verification IV voucher.

Step 8 Encrypt PEDM and IV voucher using white box cryptographic methods and pack them into a easy deploy package

After this exemplary processing a protected application code with protected partial execution dependencies as illustrated in and a record of the PEFM as illustrated in the following table 1 are generated.

The entire call relationship of an application does not need to be symbolized. Instead only certain call dependencies between most needed functions and require security features that can be enforced by the trusted module should be symbolized.

1. Deploy both of the protected application code trusted module and partial execution package into a client environment. The protected application code should look like normal application. It still can be applied by other protection techniques like normal applications. For example you can still apply secure loader protection. The partial execution package must be stored into local secured storage where the trusted module is able to access.

2. Deploy the protected application code and trusted module into a client environment and partial execution package into a remote trusted storage. The key difference between this model and above model is that partial execution package needs to be deployed into a remote storage server that can be accessed by the trusted module via remote access facility.

3. Deploy the protected application code into a client environment and a trusted module partial and execution package into a remote trusted storage. The key difference between this model and other models is that the trusted module and partial execution package can be deployed remotely and partial execution package can be stored in a remote storage server that can be accessed by protected application via remote access facility.

4. Combine 3 models above together to deploy the protected application code into a client environment with the following possible characteristics 

a. In the client environment there are one or more trusted modules and some partial execution package is stored in local secured storage.

b. In remote servers or cloud environments there are one or more trusted modules and some partial execution package is stored in remote trusted storage.

c. Dynamical execution dependency will be coordinated by correlations between different trusted modules locally and remotely.

d. Protection can be on line or off line or switch between locally or remotely making attacks difficult.

The present invention is not meant to be limited to any of the foregoing scenarios but can be very flexible and applied to achieve strong protection and flexible renewability.

After a protected application and its partial execution package are deployed the protection can take its effects when the protected application is running on a device. The example of is reused to discuss securing the execution by using the dynamic partial execution with reference to .

When executing a protected function F1p from a non native execution environment a particular PES function F1pes2 is first invoked with a set of real parameters which parameters are the ones the original F1 would use to invoke original F2. The F1pes2 function accepts inputs and then sends a down call message with current execution information in which F1p is identified as the current caller and F1pes2 is identified as the current PES. The down call message is sent to a trusted module through a communication e.g. socket connection to inquire a next method to be executed.

The trusted module will use this current execution information to search the next function to be executed from the secured PEFM located in a secured storage . A search component PE Handler within the trusted module can decrypt and access the PEFM securely by using white box crypto and search whether the current execution information can match a record of PEFM. If the search fails it indicates that the current call dependency is tampered and an attack is detected such that the current execution will be on hold and entry mitigating stage. Otherwise the search is successful and it indicates that the current execution can be continuing. Considering the matching the trusted module gets research results of next function and security actions. Next the security agent of the trusted module can perform those security actions for example integrity verification and anti debug. If those security features are successful the trusted module will send a response message to the F1pes2 via the communication connection with the next function information to be invoked as the result back. Otherwise other attacks will be detected by the trusted module through using those security features and the current execution should enter the mitigating stage.

After the F1pes2 receives the next function information from the trusted module the F1pes2 invokes the F2p and pass necessary parameters received while F1p called accordingly in order to continue the execution of this protected application.

Thereafter the current execution extends to a protected function F2p . When F2pes3 is invoked it acts similarly to the F1pes2 with a set of real parameters which are parameters that original F2 would use to invoke original F3. The F2pes3 function accepts these parameters and then sends message to the trusted module with current execution information in which F2p is identified as the current caller and F2pes3 is identified as the current PES to the trusted module through the communication connection to inquire a next method to be executed. Similarly the trusted module uses the new current execution information to search the next function for F2p to be executed from the secured PEFM. The process above is not repeated for sake of conciseness.

Suppose the trusted module returns F3 as the next function to the F2pes3 it then passes the received parameters to the F3 and invoke the F3.

After execution of F3 is completed the current execution returns back to the F2pes3 and then return back to the F2p and then return back to the F1pes2 and finally return back to F1p which is particularly illustrated on .

Afterwards the example continues with the F1p invoking F3 via F1pes3 as particularly illustrated in .

Here are some exemplary differences between HTML5 web application protection architecture via partial execution and KJava application solution architecture via partial execution 

There are some identified exemplary security advantages to using the optional HTML5 web applications are obvious 

Among other exemplary use cases the present invention is expected to be useful to secure applications implemented using scripted languages interpreted languages and virtual machines. The trusted module can be either a software module or a hardware module. Adoption of virtual machines e.g. BD VM in SetTop Boxes STB is also considered in order to improve updating of the CA client in the STB. In addition to processing the smart card could also implement the dynamic control flow functions as described in this invention. The present invention may also enable deployment of a trusted module solution to much wider non native execution environments with a better protection to secure the execution of a non native application.

The verification result may indicate tampering of the web application in which case the PES function may invoke a mitigation function not shown . The mitigation action can vary and may involve e.g. returning incorrect next function information returning an invalid function definition or returning a standard error function or result causing the application behavior to fail immediately gradually or execute incorrectly.

The verification result may alternatively comprise a next function information to be invoked for the web application. It may further comprise none or some parameter s required by the next function. In this latter case the method follows with invoking the next function not shown .

A second message call not shown may be sent to a second trusted module from the PES function with further current execution information related to the web application. For instance the second trusted module may provide at least one function not offered by the trusted module. The PES function may thereafter receive a second verification result not shown from the second trusted module related to the second message call. The PES function may also alternatively forward the message call not shown with current execution information related to the web application to the second trusted module in response to the verification result. For instance the second trusted module may provide at least one function offered by the trusted module and the verification result may indicate that the required processing was not performed by the first trusted module indicate that a timeout was received as the verification result from the trusted module etc. The PES function may thereafter receive a second verification result not shown from the second trusted module related to the forwarded message call.

Optionally generating the set of rules may be performed by generating a symbolic Partial Execution Flow Map PEFM and storing the set of rules into the memory unit is performed by storing the symbolic PEFM into the memory unit not shown . Generating the set of rules may further comprise taking security requirements related to security actions and mitigating actions into consideration not shown .

As another option the first function and the second function may be present in the code of the web application as a single function. It may be necessary to split the single function into the first and second functions not shown based on an asset being processed in the single function e.g. the single function may be read from the memory unit split and stored to the memory unit as the first and second functions which happens prior to reading the first and second functions therefrom .

The symbolic PEFM may comprise a record comprising a current caller element identifying the first function as a current calling function requiring an inquiry before invoking the second function a current PES element identifying the PES function as invoking the trusted module to trigger the inquiry a next function element identifying the second function and providing information necessary for invocation of the second function a trusted functions element identifying a set of functions that are linked with the trusted module and can be executed by an invoking mechanism within the trusted module and a security actions element identifying a set of security features that the trusted module is capable of executing prior to returning a result of the inquiry.

Optionally it is also possible to sign the secured web application prior to storing and encrypting the set of rules or symbolic PEFM prior to storing.

The network interface module is for receiving a communication e.g. socket connection request from a Partial Execution Stub PES function of the web application. The function call module is for receiving a message call from the PES function via the communication connection. The message call comprises current execution information related to the web application. The verification module is for determining based on the current execution information a next function to be executed for the web application and sending a result of the determination to the PES function via the communication connection.

The trusted module may be executed on a server node not shown remote from the client device executing the web application or on the client device not shown . The security module not shown may comprise secured functions and pre defined mitigating actions.

Optionally the result of the determination may indicate tampering of the web application. Alternatively the result of the determination may comprise a next function information to be invoked for the web application and may further comprise none or some parameter s required by the next function.

The processor is for securing the web application by determining from a function call graph of the web application that at least a call dependency from a first function to a second function of the web application needs to be protected. The processor is also for modifying the web application into the secured web application code. Modifying the web application into the secured web application code is performed by adding to the code of the web application a partial execution stub PES function comprising code to establish a communication e.g. socket connection with a trusted module not shown . The PES function requires interaction with the trusted module in order to perform the action originally taken by the second function. Modifying the web application into the secured web application code is further performed by modifying code of the web application by replacing invocation of the second function from the first function with invocation of the PES function from the first function and generating a set of rules to define a call dependency from the PES function to the second function. The processor is further for securing the web application by storing the secured web application and the set of rules into the memory unit .

Optionally generating the set of rules may be performed by generating a symbolic Partial Execution Flow Map PEFM and storing the set of rules into the memory unit may be performed by storing the symbolic PEFM into the memory unit. Generating the set of rules may further comprise taking security requirements related to security actions and mitigating actions into consideration not shown .

As another option the first function and the second function may be present in the code of the web application as a single function. The processor may then further split the single function into the first and second functions based on an asset being processed in the single function.

The processor may further sign the secured web application prior to storing and encrypt the set of rules or symbolic PEFM prior to storing.

The processor may represent a single processor with one or more processor cores or an array of processors each comprising one or more processor cores. The memory unit may comprise various types of memory different standardized or kinds of Random Access Memory RAM modules memory cards Read Only Memory ROM modules programmable ROM etc. . Storage devices module not shown may be further be present as one or more logical or physical as well as local or remote hard disk drive HDD or an array thereof . The storage devices module may further represent a local or remote database made accessible to the network node by a standardized or proprietary interface. The optional network interface module represents at least one physical interface that can be used to communicate with other network nodes. The optional network interface module may be made visible to the other modules of the network node through one or more logical interfaces. The actual stacks of protocols used by the physical network interface s and or logical network interface s of the optional network interface module do not affect the teachings of the present invention. The variants of processor memory unit network interface module and storage devices module usable in the context of the present invention will be readily apparent to persons skilled in the art. Likewise even though explicit mentions of the memory module and or the processor are not made throughout the description of the present examples persons skilled in the art will readily recognize that such modules are used in conjunction with other modules of the network node to perform routine as well as innovative steps related to the present invention.

The verification result may indicate tampering of the web application in which case the processor may further execute a mitigation action. Alternatively the verification result may also comprise a next function information to be invoked for the web application and may if applicable comprise one ore more parameter required by the next function. The processor further invokes the next function.

The processor may represent a single processor with one or more processor cores or an array of processors each comprising one or more processor cores. The optional memory unit may comprise various types of memory different standardized or kinds of Random Access Memory RAM modules memory cards Read Only Memory ROM modules programmable ROM etc. . Storage devices module not shown may be further be present as one or more logical or physical as well as local or remote hard disk drive HDD or an array thereof . The storage devices module may further represent a local or remote database made accessible to the client device by a standardized or proprietary interface. The network interface module represents at least one physical interface that can be used to communicate with other network nodes. The network interface module may be made visible to the other modules of the client device through one or more logical interfaces. The actual stacks of protocols used by the physical network interface s and or logical network interface s of the network interface module do not affect the teachings of the present invention. The variants of processor optional memory unit network interface module and storage devices module usable in the context of the present invention will be readily apparent to persons skilled in the art. Likewise even though explicit mentions of the optional memory module and or the processor are not made throughout the description of the present examples persons skilled in the art will readily recognize that such modules are used in conjunction with other modules of the client device to perform routine as well as innovative steps related to the present invention.

In accordance with the present invention in order to deploy one or more web applications multiple different deployment models may be used. The chosen deployment model may be affected by for instance by security requirements and the functional nature of the web applications. The following four exemplary deployment models among others are provided.

A first deployment model could be to deploy a secured web application with PES functions one or more trusted modules and the PEFM into a client environment. The PEFM may be stored into local secured storage accessible locally to the trusted module. This first example of deployment model can provide support for off line secured web application execution.

A second deployment model could be to deploy the secured web application with PES functions and one r more trusted modules into a client environment and the PEFM into a remote secured storage that can be accessed by the trusted module via remote connection and access facility.

A third deployment model could be to deploy the secured web application with PES functions into a client environment and one or more trusted modules and the PEFM into one or more remote network nodes. The secured storage that can be accessed by PES functions via remote connection and access facility.

A fourth deployment model could be to combine the first three models to deploy the secured web application with PES functions into a client environment different sets of characteristics. For instance in the client environment there could be one or more trusted modules and some PEFM stored in local secured storage while one or more trusted modules are stored in remote servers or cloud environments and some PEFM is stored in remote secured storage. In such an example dynamic execution dependency can be coordinated by correlating different trusted modules locally and remotely. Execution of protected function may occur on line or off line or a mix of both which likely renders attacks even more difficult.

A method is generally conceived to be a self consistent sequence of steps leading to a desired result. These steps require physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It is convenient at times principally for reasons of common usage to refer to these signals as bits values parameters items elements objects symbols characters terms numbers or the like. It should be noted however that all of these terms and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. The description of the present invention has been presented for purposes of illustration but is not intended to be exhaustive or limited to the disclosed embodiments. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiments were chosen to explain the principles of the invention and its practical applications and to enable others of ordinary skill in the art to understand the invention in order to implement various embodiments with various modifications as might be suited to other contemplated uses.

