---

title: Synchronizing a user interface area
abstract: A user interface (UI) area having multiple data sources is synchronized based upon changes made to UI elements associated with the UI area. To synchronize the changed UI elements, a processor of the computer determines UI controls and data objects associated with the UI area. Based upon a modification to a data object, a corresponding UI control that is affected by the modification is determined. A synchronization process is triggered to determine updated UI controls and updatable UI controls from the UI controls that are affected by the modification. The UI area is synchronized by updating the updatable UI controls based upon the modification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924848&OS=08924848&RS=08924848
owner: SAP SE
number: 08924848
owner_city: Walldorf
owner_country: DE
publication_date: 20120716
---
The field generally relates to computer systems and software and more particularly to software methods and systems to synchronize a user interface area.

User interface UI technologies focuses on interface technologies that support human computer interaction. UI technology research focuses on the enabling technologies that help computers hear see speak and to understand and combine these in multimodal ways. Rendering an entity on a UI includes generating a visual representation from a model by using computer programs. Updating the UI indicates that an already displayed visual representation is partially or completely refreshed.

Since the model associated with the UI includes enormous amount of information updating the UI partially or completely causes a significant information exchange between a server hosting the model and the processor processing the update. Due to the amount of information exchange there may be an overhead caused on the processor including excessive or indirect computing time memory bandwidth and the like. Hence reducing the amount of data transfer and the overhead while maintaining accuracy in updating the UI is useful.

Various embodiments of systems and methods to synchronize a computer generated user interface UI area are disclosed. The UI area having multiple data sources is synchronized based upon changes made to UI elements associated with the UI area. UI elements associated with the UI area include UI controls and data objects. To synchronize the changed UI elements a processor of the computer determines UI controls and data objects associated with the UI area to generate a conditional list. Generating the conditional list includes determining events based upon a correlation between the data objects the UI controls and the UI area. The conditional list represents a qualification of the UI controls and the data objects by verifying whether the UI controls and the data objects reflect any modification performed on the data objects.

Based upon a modification to a data object an optimized data binding structure is generated to determine a corresponding UI control that is affected by the modification. The optimized data binding structure is generated by distinguishing between data bindings associated with data instances and data bindings associated with iterative data objects. Upon triggering a synchronization process updated UI controls and updatable UI controls are determined from the UI controls which are affected by the modification. The computer generated UI area is synchronized by updating the updatable UI controls based upon the modification.

These and other benefits and features of embodiments will be apparent upon consideration of the following detailed description of the embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for systems and methods to synchronize a user interface area are disclosed herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In an embodiment synchronization of the UI area includes regeneration of the UI area. To regenerate the modified UI elements thereby reducing the CPU usage and the amount of data exchanged an optimized synchronization process may be employed. To regenerate the UI area with modified UI elements the UI controls and data objects associated with the UI area are determined to generate a conditional list. Generating the conditional list includes determining events based upon a correlation between the data objects the UI controls and the UI area. The conditional list represents a qualification of the UI controls and the data objects by verifying whether the UI controls and the data objects reflect any modification performed on the data objects. Based upon a modification to a data object an optimized data binding structure is generated to determine a corresponding UI control that is affected by the modification. Based upon the determined UI controls updated and updatable UI controls are determined. An updated UI controls list is computed to include the affected updatable UI controls. Based upon a trigger to synchronize the UI area the affected updatable UI controls are regenerated on the UI area by updating the affected UI controls based upon the modification.

Computer system comprises a user interface UI area including UI elements and and and and and . The UI elements may have UI components depending upon the type of UI elements. For instance if UI element is a radio button it includes field representing a name of the UI element. The radio button represents the editable entity of the UI element. Similarly UI element is a drop down menu editable entity which includes field . UI area is in communication with UI engine that represents a backend structure of UI area . UI engine includes UI control representing the UI controls associated with the UI elements e.g. and and data objects representing the data objects associated with editable entities e.g. and .

Database stores a relationship map of each of the UI elements corresponding fields and entities UI controls and data objects. The relationship map may be used to determine interdependencies between UI controls and data objects. Conditional list is generated by determining UI controls and data objects associated with a current instance of the UI area . Conditional list includes events which represent a qualification of the UI controls and the data objects. The qualification of each UI control and data object verifies whether the corresponding UI control or data object reflects any modifications performed on the data objects. The qualification verifies the status of the UI element by determining if the modification in the UI element reflects any modification performed on the data object. For example conditional list may include events which are triggered by each change in a UI element UI control and or data object . Conditional list is maintained in a manner to avoid duplication of event entries thereby not overloading the processor of the computer system. For instance if field is modified twice the latest modification is stored and is represented by a corresponding event.

The relationship between data objects and the UI area may include a complex mapping and determining a UI control corresponding to a modified data object may be compounded. Complex mapping may also include immutable UI controls and restrict modification to an associated data. To accommodate complex mapping optimized data binding structure is generated based upon a modification to a data object. Optimized data binding structure is interpreted by detecting the affected UI controls from the modified data objects. The interpretation is accomplished by organizing the bindings between UI controls and data objects in a bi directional central data structure where the mapping can be realized via the data objects and via the UI controls.

The interpretation may also be accomplished by building a separate optimized data binding structure containing binding paths of the corresponding UI controls and data objects and the identification of UI controls which are affected due to the modification performed on one or more data objects. Thus optimized data binding structure includes a list of UI controls which are affected by the modification of one or more data objects . Optimized data binding structure is stored until the bindings are changed and upon any changes to the bindings optimized data binding structure is updated. In an embodiment a relationship between the markup fragment of UI area and UI controls are also associated with optimized data binding structure .

In an embodiment the bindings may not specifically refer to a data object. For instance for a table with multiple rows each row may represent an instance of the data object and the corresponding binding path may represent the specific instance. For example the binding path may be represented as TABLE..FIELD and while rendering such a path the is replaced by an actual number of the row. For such cases optimized data binding structure includes a binding path of a corresponding instance of the UI control.

In another embodiment optimized data binding structure distinguishes between binding to a specific data instance of the data objects and binding to iterative data objects. For the specific data instance of the data object the data object can be used to trace the affected UI control. For iterative data objects the instances of the data object are traced to determine the affected UI control. This method of distinguishing between data bindings associated with data instance and data bindings associated with iterative data objects includes a lesser number of mappings when compared to the method of including a binding path for each instance.

Based upon a trigger to a synchronization process synchronization list is computed to include a list determination of updated UI controls and updatable UI controls from optimized data binding structure . An updated UI control may represent a UI control that synchronizes itself by instantaneously regenerating upon any modification of corresponding data object. For instance consider check box type of UI element . When a modification of checking the check box is received on UI area UI area is instantaneously regenerated to display the checked check box . Consider a radio button . When a modification of selecting the radio button is received on UI area UI area is instantaneously regenerated to display the selected radio button . The instantaneous regeneration may include a variation in a visual representation of the radio button . For instance the initial radio button may include a transparent circle and the selected radio button may include a shaded portion to show the selection made on radio button . The modification need not be communicated to a server or any other backend machine UI engine to determine one or more affected UI controls which are affected by the modification and further regenerated based upon the modification. This helps in reducing bandwidth utilization and turnaround time of the server machine.

An updatable UI control may represent a UI control that is affected by the modification and is synchronized upon a trigger to do so. For instance consider a text box type of UI element having a field and a value . When a modification of text present in value or a field is executed on the corresponding UI element this modification is communicated to UI engine which further communicates the modification to a delta handler to determine UI controls which are affected by the modification. An update interface engine determines the updatable UI controls and the updated UI controls from the UI controls which are affected by the modification and generates synchronization list .

An updated UI controls list is computed to include the affected updatable UI controls which are to be updated to regenerate on UI area . In an embodiment UI control specific business logic is included to notify one or more dependent UI controls based upon updating the affected UI controls. These dependencies may be represented as data bindings or evaluated by the business logic to determine the associated dependent UI controls and to compute updated UI controls list . Synchronization engine synchronizes UI area by updating the affected updatable UI controls from updated UI controls list based upon the modification. Synchronizing UI area includes regenerating UI area by updating contents of the affected UI controls.

In an embodiment synchronizing the UI area includes updating the updatable UI controls. To update the updatable UI controls UI controls and data objects associated with the corresponding UI area are determined. The modification performed on one or more UI controls associated with the UI area are received. The modification may be performed on a UI control representation of the UI control which constitutes an external representation of the corresponding UI control. For instance a UI control representation of a CHECK BOX present on the UI area constitutes an external representation of a UI control which allows a user to make selection of a YES or a NO by checking or unchecking the CHECK BOX . Upon receiving a modification of a CHECK to the UI control representation that was UNCHECKED the UI control representation responds to the modification by displaying the checkbox as CHECKED and sends a notification about the modification to a UI engine . The modified UI control is registered as updated UI control or as synchronized in the UI engine since the checkbox is already displayed as CHECKED . One or more data objects that are affected by the modification are determined and updated to reflect the modification. For e.g. data object bound to the value of the checkbox is determined and a value TRUE is set to indicate that the checkbox is now checked. The modified data object triggers a notification about the modification to determine one or more affected UI controls. Updated UI controls and updatable UI controls are determined from the group of affected UI controls. The updated UI controls that are registered need not be synchronized. However the updatable UI controls that are not registered are determined as to be synchronized . Upon synchronizing the updatable UI controls based on the modification the registrations as synchronized and to be synchronized are removed. In an embodiment the registration is removed prior to a second modification to make the updated UI controls and the updatable UI controls available for modification.

In an embodiment a complexity of the affected UI controls is computed to determine a degree of regenerating of the UI controls on the UI area . The complexity of the affected UI controls includes an amount of modification a number of cross references or interdependencies of UI controls a number of UI controls affected or the like. A degree of regenerating represents a measure of data that needs to be regenerated on UI area . For instance in a UI segment containing twenty UI controls if seventeen UI controls are affected the whole UI segment may be regenerated instead of determining conditional list optimized data binding structure and updated UI controls list .

In an embodiment computer system comprises a UI programming model including a user interface phase to receive the modification to data objects associated with UI area and to synchronize the affected UI controls based upon the modification an update interface phase to the updated UI controls and the updatable UI controls upon a trigger of the synchronization process and synchronization phase to synchronize the UI area by updating the affected updatable UI controls based upon the modification. In an embodiment the affected updated UI controls from updated UI controls list is regenerated by queuing the affected updatable UI controls and synchronizing them at the synchronization phase instead of regenerating each affected UI control upon modification.

In an embodiment the synchronization process includes synchronizing the UI area associated with a client system with a corresponding application program associated with a server system. For instance consider a UI area present on a client s system. Based upon a modification performed on the UI area depending upon the type of associated UI controls e.g. updated or updatable of the application program present on a server system UI area is synchronized. For example if the associated UI controls are updated any communication with the server system may be absent and the client system instantaneously regenerates the updated UI controls on UI area . If the associated UI controls are updatable a communication is established with the server system by generating an updated UI control list and based upon the affected updatable UI controls UI area is synchronized.

In an embodiment updated UI controls may not be associated with an ability to instantaneously regenerate. In such cases the updated UI controls are executed in a manner similar to the updatable UI controls. For instance consider a drop down menu type of UI element. When a selection of options in the drop down menu is modified the updated UI control associated with the drop down menu type may instantaneously regenerate the UI control on UI area . Even though the updated UI control is instantaneously regenerated on UI area since the option was changed there may be one or more updatable UI controls that reflect the modification. In such cases the updated UI control is executed in a manner similar to the updatable UI controls.

In an embodiment the synchronization process includes cancelling a regeneration of the updated UI control or the updatable UI control based upon a synchronization process triggered between a server side framework and a client side framework. Cancelling regeneration represents removing a regeneration notification that is associated with the updated UI control or the updatable UI control upon completing the process of synchronizing the computer generated UI area based upon the modification.

In an embodiment a data transformation is implemented when an internal representation of data associated is different from a corresponding external representation of data associated with the UI area. For instance consider an internal representation of a date as YYYYMMMDD and a corresponding external representation of the associated data as MONTH DD YYYY . When a user input received is Apr. 20 2012 to determine the updated UI controls and the updatable UI controls a data transformation of the received user input is executed. The data transformation is executed to synchronize the internal representation and the external representation and further determine the updated UI controls and the updatable UI controls.

At process block a modification to one or more data objects is received. The modification may be received from the UI or an application associated with the UI. At process block the UI controls which are affected by the modification are determined. In an embodiment the affected UI controls are determined based upon the conditional list of events. At process block a synchronization process is triggered to determine updated UI controls and updatable UI controls. In an embodiment an updated UI controls list is computed based upon the affected updatable UI controls. At process block the UI area is synchronized by updating the affected updatable UI controls based upon the modification.

A computer generated UI area interchangeably called a UI area throughout the specification in communication with UI engine displays one or more UI elements configured to be regenerated on the UI. In an embodiment to synchronize the UI area UI engine determines one or more UI controls and one or more data objects which are associated with the UI area. In an embodiment the data objects and the UI controls associated with the UI area are stored in database . In another embodiment an event handler generates a conditional list of one or more events representing a qualification of the corresponding UI controls and the data objects. These events represent a qualification of the corresponding UI controls and the data objects associated with the UI area. Processor recognizes one or more modification of one or more data objects. Based upon the modifications a data binder may generate an optimized data binding structure to determine corresponding one or more UI controls which are affected by the modification. In an embodiment the conditional list and the optimized data binding structure are stored in database . Based upon a modification associated with the data object the respective data is accessed from database to compute the updated UI controls list.

In an embodiment delta handler determines the UI controls which are affected by the modification. The modification of one or more data objects and the list of UI controls which are affected by the modification are sent to update interface engine . Update interface engine determines updated UI controls and updatable UI controls from the list of UI controls and the modification. An updated UI control may represent a UI control that synchronizes itself by instantaneously regenerates upon any modification of corresponding data object. An updatable UI control may represent a UI control that is affected by the modification and is synchronized upon a trigger to do so.

Update interface engine computes an updated UI controls list including the affected updatable UI controls based upon. Synchronization engine synchronizes the UI area by regenerating the affected updatable UI controls. In an embodiment regenerating the affected updatable UI control includes updating the affected updatable UI controls based upon the modification. Thus computer system is utilized to determine the UI controls which are affected by the modification and the UI area is updated to modify the affected updatable UI controls.

In an embodiment a server determines the UI controls and the data objects associated with the UI area. The server receives a modification of the one or more data objects to determine the UI controls affected by the modification and identifies the updated UI controls and the updatable UI controls. Based upon a trigger to synchronize the server receives the trigger and synchronizes with a client system by updating the updatable UI controls based upon the modification.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transaction hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transaction data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in detail.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the one or more embodiments are described herein for illustrative purposes various equivalent modifications are possible within the scope as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

