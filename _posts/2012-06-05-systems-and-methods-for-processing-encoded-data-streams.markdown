---

title: Systems and methods for processing encoded data streams
abstract: A method and system for efficient processing of encoded data streams communicated through a wireless network are disclosed. A system may include a receiver component, an iterator component, and a return component. The receiver component receives an encoded message including a plurality of objects. The message may be encoded according to a protocol. The iterator component traverses, without decoding the encoded message, the plurality of objects within the encoded message to locate a selected object of the plurality of objects. The selected object is selected by a client application. The return component returns data associated with the selected object to the client application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09432489&OS=09432489&RS=09432489
owner: INTEL CORPORATION
number: 09432489
owner_city: Santa Clara
owner_country: US
publication_date: 20120605
---
This disclosure relates to systems and methods for communication between devices over a network. Specifically this disclosure relates to systems and methods for efficient processing of encoded messages sent over a communications network.

Devices generally use encoded messages to communicate data streams over a network. The encoded messages may include compressed data intended for certain client applications. Upon receiving a message through a network a device may uncompress the data and store it in a separate data structure used by a client application. To extract and copy the data of interest into the data structure the device is configured to fully or partially comprehend the encoded message. Thus the device uses extra memory overhead to store the message contents during processing.

A detailed description of systems and methods consistent with embodiments of the present disclosure is provided below. While several embodiments are described it should be understood that disclosure is not limited to any one embodiment but instead encompasses numerous alternatives modifications and equivalents. In addition while numerous specific details are set forth in the following description in order to provide a thorough understanding of the embodiments disclosed herein some embodiments can be practiced without some or all of these details. Moreover for the purpose of clarity certain technical material that is known in the related art has not been described in detail in order to avoid unnecessarily obscuring the disclosure.

Systems and methods disclosed herein may perform zero copy processing of encoded data streams without the additional memory overhead of traditional processing schemes. In certain embodiments an iterator efficiently traverses encoded messages with reduced or minimal storage overhead and no memory allocation and or copy overhead. The iterator may return pointers associated with objects within an encoded message received through a network. For example when the iterator encounters predetermined e.g. well known within the communication protocol parameters or tokens in the message the iterator may return a pointer to local static and read only memory locations where data e.g. strings associated with the predetermined parameters or tokens are stored. When the iterator encounters an application specific value in the encoded message the iterator may return a pointer to a memory location at a corresponding offset in the received data stream.

For illustrative purposes certain embodiments disclosed herein use the wireless application protocol WAP and the wireless session protocol WSP . Those skilled in the art will recognize from the disclosure herein however that the disclosure is not so limited and that the disclosure may be applied to other protocols that allow the interoperability of communication devices. WAP is an open international standard used by many mobile devices for communication and is guided by the Open Mobile Alliance OMA organization. A technical description and specification of WAP and WSP is available through the OMA. The WAP standard describes a suite of protocols allowing the interoperability of WAP based applications and equipment with different network technologies such as IS 95 also known as code division multiple access CDMA worldwide interoperability for microwave access WiMAX Bluetooth global system for mobile communications GSM universal mobile telecommunications system UMTS long term evolution LTE and the like. The WSP standard in particular is used by a WAP browser and multimedia messaging service MMS . Many services including mobile device management MDM and digital rights management DRM rely on data push facilities provided by the WSP specification.

One method of communication between two WAP enabled applications includes sending a message encoded in WSP. The encoding process involves compression of certain portions of a message into a binary form which is accomplished by encoding well known objects such as headers header parameters or other values into shorter or compressed binary forms. Generally the messages are then sent and received by another device or application. Upon receipt the messages are decoded decompressed into a separate data structure representing the message that may then be interpreted by an application on the client device. Generally this requires a client application or client device to fully comprehend the message so as to extract and copy the information into a separate data structure.

Frequently the WSP decoding routines are part of the middle ware or core system level application programming interfaces APIs and are re used by most or all WSP enabled applications. Due to this nature the APIs are generally required to be complete implementations of the WSP protocol. This means that all message contents are processed and comprehended during the decoding phase and may be repeated each time a message is passed to a new application within a device. This requires extra memory overhead to store the message contents during processing. This can be detrimental to many mobile devices or embedded systems that have limited memory and or limited battery. Furthermore for services like MMS that are built on top of WSP to exchange audio and video content the additional memory overhead can be quite expensive because of the copying and storage of the large portions of data represented by the audio and video content. In addition there are often situations where full comprehension of the message is not required. For example some applications may only need a small portion of the data that is within a WSP encoded message. Thus the full comprehension and the associated CPU memory battery and power usage involved in the decoding process can lead to significant inefficiencies.

Thus the systems and methods disclosed herein provide efficient processing of encoded message. In one embodiment efficient processing includes performing zero copy processing of WSP data streams and encoded messages without the overhead of traditional schemes. In one embodiment a client device uses certain structural aspects of the WSP encoding standard to traverse an encoded message to locate a selected object that is of interest to the client device or to a client application. The client device may then return data associated with the selected object to a client program. The client program may use or process the data as needed. Traversal of the encoded message and only providing data that is of interest may allow processing of a message in an encoded state and can limit the need to create a decoded or decompressed version of the message. Furthermore portions of an encoded message that are irrelevant may be ignored and only portions relevant to a client program are comprehended copied and or processed. Corresponding CPU memory and battery savings may result.

In one embodiment the traversal is accomplished by using an iterator component that is able to efficiently traverse WSP encoded messages with minimal storage overhead little or no memory allocation copy overhead and little or no CPU overhead. For example the iterator component may traverse over individual objects such as headers and or header parameters of the WSP encoded message. In one embodiment the iterator component may locate a next object and an application or other component may determine whether that object is of interest to a client application. If the object is of interest associated data may be provided to the client application. In some situations a pointer to the data or to a separate library may be provided rather than copying data from the message. Usage of stack based memory locations enables support for compilation time compression and optimized lookups. This may allow WSP enabled clients such as client applications to use the iterator and only process information objects that are relevant to the particular application.

Using efficient traversal of an encoded message applications that do not need to process or comprehend everything in a message can skip over objects that are irrelevant. One example of a client application that may not need to process and or comprehend a full message may include a dispatcher application. As mentioned above WSP provides a mechanism for data push. A dispatcher application may receive all WAP push messages received by a client device. The dispatcher application may be responsible for dispatching the WAP push message to the intended client application on the system. For example WAP push messages may be intended for an OMA device management OMA DM or OMA client provisioning OMA CP based device management application an OMA DRM based digital rights management application a vCard contacts application or the like. Many applications may be intended recipients because many network operator specific applications and services also use WAP push.

In order to determine the recipient without efficient traversal the dispatcher application may parse the WSP encoded message to determine its multi purpose internet mail extension MIME type. With some methods this may require complete decoding and copying of the whole message. However based on embodiments disclosed herein an iterator component can efficiently traverse the message to locate an object that designates MIME type process that information and forward the message on to the intended recipient application. This can improve efficiency because the dispatcher application does not require and may not even be capable of using any information except for the MIME type. Because the dispatcher application only obtains needed information and ignores other information latency and overhead can be significantly reduced.

Using an iterator component also allows WSP encoded messages to be stored in an encoded format. This may limit the amount of copying required to decode or use the data within the encoded message. Furthermore because encoded messages are often smaller than decoded messages memory usage on the device may be decreased. In addition or in other embodiments multiple applications or components may access the encoded message concurrently. Thus one application may read images or other data from the message while another application reads audio or other data during the same time period. Similarly because an encoded message can be efficiently traversed messages that include data that is not currently understood by any client application can be stored until such an application is identified and installed. Furthermore when large amounts of payload or other data are included in an encoded message this data may be skipped leading to significant memory allocation and processor usage savings over other methods.

The server may include any type of hardware and or software known in the art. The server may provide data information or other content to the WAP gateway or client devices . In one embodiment the server may be a web server providing website content. For example web pages video audio multimedia text or the like may be provided by the server to one or more of the WAP gateway or the client devices . In another embodiment the server may be a communications server which forwards data received from another server or device to a component of the system . For example voice communications messages or other data may be forwarded by the server from another server device or component of the system to a component of the system .

The server may use any type of communication protocol known in the art. Example protocols include internet protocol IP hypertext transfer protocol HTTP file transfer protocol FTP internet message access protocol IMAP WAP or the like. Numerous other types of communication protocols are well known and well defined in the art.

One of skill in the art will recognize the variations and functionality of WAP gateways currently available in the art. In one embodiment the WAP gateway translates content from one protocol or format to one of the protocols or formats as defined by the WAP. For example the WAP gateway may take content encoded in HTTP and translate it into wireless markup language WML which can be interpreted and or processed by a mobile device or other WML capable device or software. In one embodiment the WAP gateway may be situated between the network and the client devices .

In one embodiment the WAP gateway may receive content from the server or other device encoded in a first language or protocol and translate the content into formats compatible with WAP. Thus devices that are capable of WAP communication may be able to access content that was initially designed or encoded for other devices or protocols. In one embodiment the WAP gateway formats a message or other data unit for a client device . The client device may then be able to receive the message and process the message or other data unit as intended. As will be understood by one skilled in the art other types of gateways may be used depending on a protocol or other communication requirements.

The network may include any type of communications network. Example communications networks include a cable network a mobile phone network a satellite network a computing network the internet or the like. In one embodiment the network may include a plurality of smaller networks. The network may be capable of wired and or wireless communications. In one embodiment the network may be implemented according to one or more of a wide variety of wireless communications standards including but not limited to CDMA WiMAX Bluetooth GSM UMTS LTE and the like. In one embodiment the network is capable of communicating with the client device using the antenna or other wireless transmission device or system.

The system depicted in includes a client device in wired communication with the network and a client device in wireless communication with the network through the antenna . Although not shown the antenna may represent other elements of a wireless network such as a base station or femtocell. The client devices may include any type of communication device or data processing device known in the art. Example client devices include but are not limited to a mobile phone such as a feature phone or a smart phone a personal digital assistant PDA a tablet computer a laptop computer a desktop computer or the like. According to one embodiment the client device may include a mobile information processing device running a mobile operating system such as MeeGo Android iOS Windows Phone or the like.

In one embodiment the client devices may be used to browse web content send messages and perform a variety of different types of communication or data processing. The client devices may include a number of applications for performing different functions for communication media consumption internet browsing or the like. In one embodiment the client devices may send to and or receive messages from another device. For example data received from the server WAP gateway or another client device may be received in the form of one or more messages. In one embodiment the client devices may be configured to efficiently process encoded messages received from another device.

In one embodiment the receiver component receives an encoded message. The receiver component may receive the encoded message over the network from another client device the WAP gateway the server or any other device. The encoded message may be encoded according to a protocol. In one embodiment the encoded message is encoded according to WAP standard. In one embodiment the encoded message is encoded according to WSP.

The encoded message may include a plurality of objects. For example the message may include one or more headers header parameters payloads or other objects. In one embodiment at least one object of the plurality of objects is encoded in a compact binary format. For example at least a portion of an object may be encoded such that it is smaller in an encoded state than in a non encoded state. In one embodiment the encoded message may include one or more protocol data units PDUs which may be units of data that are sent over a network . In one embodiment the encoded message may be a data push or a data pull message.

In one embodiment a protocol may define one or more objects as well known objects. For example well known objects may include headers header parameters or other data that is defined within a protocol or well known within a protocol. The protocol may also define a compact binary encoding for each of the well known objects. For example this may allow for a compact and or compressed encoding for the well known objects to limit the size of a message or increase the amount of payload data that may be included in a message. Devices or applications that operate according to the protocol may thus be able to understand or interpret the encoded or compressed binary encoding as a corresponding well known object. In one embodiment the encoded message may include a compact binary encoding of a well known object.

The encoded message includes a series of values represented as bytes or bits. According to one embodiment the encoded message includes objects that represent data for processing by the client device and or the client application shown in . Although only a small number of objects are illustrated in one of skill in the art will recognize that a large number of objects may be present in some embodiments.

According to certain embodiments an object within the message may be in a compressed or uncompressed format. The object indicated by the pointer is a header having an uncompressed value of X New Header . According to one embodiment the header object at the pointer is a custom object and thus is in an unencoded or uncompressed state even though the encoded message is in an encoded state. For example the value X New Header may not have a compact binary encoding defined by WSP. The object at pointer is followed by a parameter object at pointer having the uncompressed value of paramvalues . Once again the parameter object at pointer is uncompressed because it is a custom value. That is the value paramvalues may not have a compact binary encoding defined by WSP.

The pointer points to a header object having the value 0x80 hexadecimal 80 . The header object 0x80 may be a binary encoding for a well known header. For example the binary encoding 0x80 may be defined by WSP as a compact encoding for the uncompressed header Accept . The pointer is followed by the pointer pointing to a parameter object having the value 0x94 hexadecimal 94 . The parameter object 0x94 is a binary encoding for a well known parameter value. For example the binary encoding 0x94 may be defined by WSP as a compact encoding for the uncompressed parameter value application vnd.wap.wmlc .

The encoded message is provided by way of example only. For example other encoded messages in other embodiments may be encoded according to other protocols or standards. One of skill in the art will recognize encoded messages having considerable variation in structure length encoding and the like.

Returning to the memory component of the client device may store data for the client device . In one embodiment the memory component may include memory for storage of data. According to one embodiment the memory may include read only memory. In another embodiment the memory may include writable memory. In one embodiment the memory may include both read only and writable memory. In one embodiment the memory component may store an encoded message such as the encoded message of . The memory component may store other components of the client device such as code. For example the receiver component iterator component determination component return component and or client application s may reside within memory of the memory component . The components or portions thereof may also be implemented as hardware firmware or the like. The memory component may also store a library of decoded object values see .

In one embodiment the iterator component traverses an encoded message to locate objects within the encoded message. In one embodiment the iterator component may interact with the determination component discussed below to locate selected objects within the encoded message. In one embodiment the iterator component may traverse an encoded message to locate a selected object. The selected object may be an object selected by another application such as the client application .

In one embodiment the iterator component may traverse the encoded message to identify a next object within the encoded message. The iterator component may designate the identified next object as a current object. For example traversing the one or more objects within the encoded message may include locating a subsequent object following a current location tracked by the iterator component within the encoded message. The iterator component may identify objects within the encoded message based on the structure required by a protocol or other standard. For example the iterator component may traverse the encoded message of based on requirements imposed by the WSP standard. In one embodiment the iterator component may locate values within the encoded message that indicate the beginning of a new object or may look for specific headers parameters or encoded binary values.

According to one embodiment the iterator component traverses the encoded message without decoding the encoded message. In one embodiment the iterator component may traverse the encoded message without creating an unencoded version of the encoded message. In one embodiment the iterator component may reference a library of objects as defined by a protocol without creating an unencoded version of the message and or without creating an unencoded version of an object within the message. For example the iterator component may traverse the encoded message without creating a decoded copy of any portion of the message. In one embodiment decoding of binary encodings may not be necessary due to a library with decoded object values.

The determination component may determine whether an object identified by the iterator component is a selected object. According to one embodiment a selected object is an object that is selected by a client application . A selected object may be an object that is of interest to a client application for processing or controlling operation of the client application . For example some objects of an encoded message may not be relevant to the operation of the client application while other objects are relevant. According to one embodiment only those objects that are relevant are selected objects and the determination component determines whether an object identified by the iterator component is a selected object.

According to one embodiment the determination component compares an object with one or more selected objects that correspond to a client application . For example the client application may provide a list of selected objects which if found in an encoded message should be provided to the client application . In one embodiment the determination component compares an object with the list of selected objects. If the object corresponds to an object in the list of selected objects the determination component may determine that the object is a selected object.

According to one embodiment the determination component compares the value of an object with values within a list of selected objects. For example if the value of an object identified by the iterator component matches a value within a list of selected objects the determination component may determine that the object is a selected object. According to another embodiment the determination component may locate a value in a library that corresponds to an object identified by the iterator component . For example if the object identified by the iterator component is a compact binary encoding the determination component may locate a value in a library that corresponds to the compact binary encoding. The value in the library may then be compared with the values in a list of selected objects.

The return component returns data associated with a selected object. In one embodiment the return component may return the data to a client application . According to one embodiment the data may be returned in response to the iterator component and determination component locating a selected object. In one embodiment the return component may return data in response to the determination component determining that an object identified by the iterator component is a selected object.

In one embodiment the return component may return the value of an object. In another embodiment the return component may return a pointer to data associated with the object. In one embodiment a pointer may point to a location within an encoded message where an object is located. In another embodiment a pointer may point to a location within a library that has a value corresponding to an object within the message. For example a selected object may correspond to a well known object as defined by a protocol and a pointer may point to a predetermined memory location in a library where an un encoded version of the well known object is stored.

The one or more client applications may include any application that may run on the client device . According to one embodiment the client application may be an application that uses data received through network messages such as a web browser an audio player a video player an image viewer a messaging application or any other application. In one embodiment a client application may include a dispatcher application which processes incoming messages and notifies an intended recipient application of the receipt of the message. Other example applications include a text messaging application a multimedia messaging application and the like.

Turning to illustrate example interaction between components of the client device to process an encoded message. As stated previously illustrates a block diagram of an example encoded message. illustrates example pseudo code for processing an encoded message according to one embodiment. is a block diagram of an example library according to one embodiment. The library includes well known headers and well known parameters. Pointers and are illustrated pointing to values within the library. In one embodiment the library may include read only values which may not be modified by client applications. The library may be read only due to the type of memory in which the library is stored or may be read only memory as managed by an operating system or other memory management application or component. In one embodiment the library may be used as a look up table for interpreting encoded binary values.

The pseudo code of includes an iter init . . . instruction which may be used to initialize the iterator component . In one embodiment the iterator component may be initialized with a memory address of the encoded message of .

The iter next . . . instruction may cause the iterator component and determination component to work together to locate a next selected object within the encoded message . In this example the iter next . . . instruction may result in the iterator component locating an object at the location of the pointer within the encoded message . The iterator component may keep track of the memory location of the object by storing the pointer as a pointer to a current object. For example the iterator component may store a memory location value corresponding to a location pointed to by the pointer . In another embodiment the iter next . . . instruction may result in the iterator component skipping over the object at the pointer to the object at the pointer . For example if X New Header is not a selected object for a client application the iter next . . . instruction may skip over that object.

The return header instruction causes the return component to return a pointer to the header value at the location of the current pointer tracked by the iterator component . For example assuming that the object at the pointer is a selected object the pointer which points to X New Header is returned. The return param instruction returns a pointer to the parameter value following the header at the location of the current pointer tracked by the iterator component . For example the pointer which points to paramvalues is returned.

The iter next . . . instruction causes the iterator component to locate a next selected object within the encoded message . In this example the selected object is located at the pointer . According to one embodiment the return header and return param return pointers to locations within the encoded message. For example return header instruction may return the pointer and the return param may return pointer . According to another embodiment the return header and return param return pointers to memory locations within a library. For example return header instruction may return the pointer within the library and the return param may return the pointer within the library . For example the value 0x80 within the encoded message may be an encoded binary value that corresponds to Accept within WSP and the value 0x94 may be an encoded binary value that corresponds to application vnd.wap.wmlc in WSP.

In one embodiment the iter next . . . return header and return param instructions may be repeated until the encoded message has been traversed and all selected objects have been located. For example code to create a loop that causes the instructions to be executed until all selected objects have been located may be used in some embodiments.

The method begins and the receiver component receives an encoded message. The encoded message may be received from a network such as a wireless communications network or other network. The encoded message may be encoded according to a protocol. In one embodiment the encoded message is encoded according to WSP. In one embodiment the encoded message includes a plurality of objects. The plurality of objects may include headers parameters or other values.

The method includes an iterator component traversing the plurality of objects of the encoded message to locate a selected object. In one embodiment the encoded message is not decoded during traversal . The iterator component may locate the selected object based on structural requirements of a protocol. For example an encoded message encoded according to WSP may have specific structures required by WSP. In one embodiment the iterator component traverses the encoded message to locate objects or structures defined by WSP. The selected object may be an object selected by a client application. For example a client application may have an associated list of one or more objects to be located by the iterator component . Objects that are on the list may be selected objects.

The method includes a return component returning data associated with the selected object. In one embodiment the associated data is returned to a client application. The return component may return the associated data in response to the location of the selected object. In one embodiment the returned associated data may include a header value a parameter value or other value copied from the encoded message. In another embodiment the returned associated data may include a pointer to a location in memory. In one embodiment a pointer points to a location within the encoded message. In another embodiment a pointer points to a location within a library.

The method includes the determination component determining whether an object is a selected object. The determination component may compare an object identified by the iterator component with a list of selected objects. The list of selected objects may include one more objects which if located are provided to a client application. For example the list of selected objects may include objects that may be processed by a client application.

The method also includes determining whether there are additional selected objects. If there are additional objects Yes at then the method may repeat the traversing determining and returning discussed above. If there are no additional objects No at the method may end. This may allow the method to end prior to complete traversal of an encoded message. In some situations when very little information from an encoded message is required by a client program processing savings can be quite significant.

Some of the infrastructure that can be used with embodiments disclosed herein is already available such as general purpose computers mobile phones computer programming tools and techniques digital storage media and communications networks. A computing device may include a processor such as a microprocessor microcontroller logic circuitry or the like. The processor may include a special purpose processing device such as an ASIC PAL PLA PLD FPGA or other customized or programmable device. The computing device may also include a computer readable storage device such as non volatile memory static RAM dynamic RAM ROM CD ROM disk tape magnetic optical flash memory or other computer readable storage medium.

Various aspects of certain embodiments may be implemented using hardware software firmware or a combination thereof. A component or module may refer to be part of or include an application specific integrated circuit ASIC an electronic circuit a processor shared dedicated or group and or memory shared dedicated or group that execute one or more software or firmware programs a combinational logic circuit and or other suitable components that provide the described functionality. As used herein a software module or component may include any type of computer instruction or computer executable code located within or on a non transitory computer readable storage medium. A software module or component may for instance comprise one or more physical or logical blocks of computer instructions which may be organized as a routine program object component data structure etc. that performs one or more tasks or implements particular abstract data types.

In certain embodiments a particular software module or component may comprise disparate instructions stored in different locations of a computer readable storage medium which together implement the described functionality of the module or component. Indeed a module or component may comprise a single instruction or many instructions and may be distributed over several different code segments among different programs and across several computer readable storage media. Some embodiments may be practiced in a distributed computing environment where tasks are performed by a remote processing device linked through a communications network.

The systems and methods disclosed herein are not inherently related to any particular computer or other apparatus and may be implemented by a suitable combination of hardware software and or firmware. Software implementations may include one or more computer programs comprising executable code instructions that when executed by a processor may cause the processor to perform a method defined at least in part by the executable instructions. The computer program can be written in any form of programming language including compiled or interpreted languages and can be deployed in any form including as a standalone program or as a module or component component subroutine or other unit suitable for use in a computing environment. Further a computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network. Software embodiments may be implemented as a computer program product that comprises a non transitory storage medium configured to store computer programs and instructions that when executed by a processor are configured to cause the processor to perform a method according to the instructions. In certain embodiments the non transitory storage medium may take any form capable of storing processor readable instructions on a non transitory storage medium. A non transitory storage medium may be embodied by a compact disk digital video disk a magnetic tape a magnetic disk a punch card flash memory integrated circuits or any other non transitory digital processing apparatus memory device.

Although the foregoing has been described in some detail for purposes of clarity it will be apparent that certain changes and modifications may be made without departing from the principles thereof. It should be noted that there are many alternative ways of implementing both the processes and apparatuses described herein. Accordingly the present embodiments are to be considered illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

The foregoing specification has been described with reference to various embodiments. However one of ordinary skill in the art will appreciate that various modifications and changes can be made without departing from the scope of the present disclosure. For example various operational steps as well as components for carrying out operational steps may be implemented in alternate ways depending upon the particular application or in consideration of any number of cost functions associated with the operation of the system. Accordingly any one or more of the steps may be deleted modified or combined with other steps. Further this disclosure is to be regarded in an illustrative rather than a restrictive sense and all such modifications are intended to be included within the scope thereof. Likewise benefits other advantages and solutions to problems have been described above with regard to various embodiments. However benefits advantages solutions to problems and any element s that may cause any benefit advantage or solution to occur or become more pronounced are not to be construed as a critical a required or an essential feature or element. As used herein the terms comprises comprising and any other variation thereof are intended to cover a non exclusive inclusion such that a process a method an article or an apparatus that comprises a list of elements does not include only those elements but may include other elements not expressly listed or inherent to such process method system article or apparatus. Also as used herein the terms coupled coupling and any other variation thereof are intended to cover a physical connection an electrical connection a magnetic connection an optical connection a communicative connection a functional connection and or any other connection.

Those having skill in the art will appreciate that many changes may be made to the details of the above described embodiments without departing from the underlying principles of the invention. The scope of the present invention should therefore be determined only by the following claims.

