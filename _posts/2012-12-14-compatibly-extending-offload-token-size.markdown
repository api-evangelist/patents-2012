---

title: Compatibly extending offload token size
abstract: Aspects of the subject matter described herein relate to offload technology. In aspects, a mechanism is described that allows an offload provider to use larger tokens. The larger token may be physical or virtual. In response to an offload read command, a larger token may be created and data from the larger token may be split or injected into multiple tokens of a smaller size. In response to an offload write command, data from the multiple tokens may be combined into a larger token and/or extracted and used to obtain bulk data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09251201&OS=09251201&RS=09251201
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09251201
owner_city: Redmond
owner_country: US
publication_date: 20121214
---
One mechanism for transferring data is to read the data from a file of a source location into main memory and write the data from the main memory to a destination location. While in some environments this may work acceptably for relatively little data as the data increases the time it takes to read the data and transfer the data to another location increases. In addition if the data is accessed over a network the network may impose additional delays in transferring the data from the source location to the destination location. Furthermore security issues combined with the complexity of storage arrangements may complicate data transfer.

The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.

Briefly aspects of the subject matter described herein relate to offload technology. In aspects a mechanism is described that allows an offload provider to use larger tokens. The larger token may be physical or virtual. In response to an offload read command a larger token may be created and data from the larger token may be split or injected into multiple tokens of a smaller size. In response to an offload write command data from the multiple tokens may be combined into a larger token and or extracted and used to obtain bulk data.

This Summary is provided to briefly identify some aspects of the subject matter that is further described below in the Detailed Description. This Summary is not intended to identify key or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The phrase subject matter described herein refers to subject matter described in the Detailed Description unless the context clearly indicates otherwise. The term aspects should be read as at least one aspect. Identifying aspects of the subject matter described in the Detailed Description is not intended to identify key or essential features of the claimed subject matter.

The aspects described above and other aspects of the subject matter described herein are illustrated by way of example and not limited in the accompanying figures in which like reference numerals indicate similar elements and in which 

The phrase subject matter described herein refers to subject matter described in the Detailed Description unless the context clearly indicates otherwise. The term aspects should be read as at least one aspect. Identifying aspects of the subject matter described in the Detailed Description is not intended to identify key or essential features of the claimed subject matter.

As used herein the term includes and its variants are to be read as open ended terms that mean includes but is not limited to. The term or is to be read as and or unless the context clearly dictates otherwise. The term based on is to be read as based at least in part on. The terms one embodiment and an embodiment are to be read as at least one embodiment. The term another embodiment is to be read as at least one other embodiment. 

As used herein terms such as a an and the are inclusive of one or more of the indicated item or action. In particular in the claims a reference to an item generally means at least one such item is present and a reference to an action means at least one instance of the action is performed.

Sometimes herein the terms first second third and so forth may be used. Without additional context the use of these terms in the claims is not intended to imply an ordering but is rather used for identification purposes. For example the phrases first version and second version do not necessarily mean that the first version is the very first version or was created before the second version or even that the first version is requested or operated on before the second version. Rather these phrases are used to identify different versions.

Headings are for convenience only information on a given topic may be found outside the section whose heading indicates that topic.

Aspects of the subject matter described herein are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments or configurations that may be suitable for use with aspects of the subject matter described herein comprise personal computers server computers whether on bare metal or as virtual machines hand held or laptop devices multiprocessor systems microcontroller based systems set top boxes programmable and non programmable consumer electronics network PCs minicomputers mainframe computers personal digital assistants PDAs gaming devices printers appliances including set top media center or other appliances automobile embedded or attached computing devices other mobile devices phone devices including cell phones wireless phones and wired phones distributed computing environments that include any of the above systems or devices and the like.

Aspects of the subject matter described herein may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. Aspects of the subject matter described herein may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

Alternatively or in addition the functionality described herein may be performed at least in part by one or more hardware logic components. For example and without limitation illustrative types of hardware logic components that can be used include Field programmable Gate Arrays FPGAs Program specific Integrated Circuits ASICs Program specific Standard Products ASSPs System on a chip systems SOCs Complex Programmable Logic Devices CPLDs and the like.

With reference to an exemplary system for implementing aspects of the subject matter described herein includes a general purpose computing device in the form of a computer . A computer may include any electronic device that is capable of executing an instruction. Components of the computer may include a processing unit a system memory and one or more system buses represented by system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus Peripheral Component Interconnect PCI bus also known as Mezzanine bus Peripheral Component Interconnect Extended PCI X bus Advanced Graphics Port AGP and PCI express PCIe .

The processing unit may be connected to a hardware security device . The security device may store and be able to generate cryptographic keys that may be used to secure various aspects of the computer . In one embodiment the security device may comprise a Trusted Platform Module TPM chip TPM Security Device or the like.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media.

Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes RAM ROM EEPROM solid state storage flash memory or other memory technology CD ROM digital versatile discs DVDs or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer . Computer storage media does not include communication media.

Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disc drive that reads from or writes to a removable nonvolatile optical disc such as a CD ROM DVD or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include magnetic tape cassettes flash memory cards and other solid state storage devices digital versatile discs other optical discs digital video tape solid state RAM solid state ROM and the like. The hard disk drive may be connected to the system bus through the interface and magnetic disk drive and optical disc drive may be connected to the system bus by an interface for removable nonvolatile memory such as the interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone e.g. for inputting voice or other audio joystick game pad satellite dish scanner a touch sensitive screen a writing tablet a camera e.g. for inputting gestures or other visual input or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

Through the use of one or more of the above identified input devices a Natural User Interface NUI may be established. A NUI may rely on speech recognition touch and stylus recognition gesture recognition both on screen and adjacent to the screen air gestures head and eye tracking voice and speech vision touch gestures machine intelligence and the like. Some exemplary NUI technology that may be employed to interact with a user include touch sensitive displays voice and speech recognition intention and goal understanding motion gesture detection using depth cameras such as stereoscopic camera systems infrared camera systems RGB camera systems and combinations thereof motion gesture detection using accelerometers gyroscopes facial recognition 3D displays head eye and gaze tracking immersive augmented reality and virtual reality systems as well as technologies for sensing brain activity using electric field sensing electrodes EEG and related methods .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include phone networks near field networks and other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer may include a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

As mentioned previously some traditional data transfer operations may not be efficient or even work in today s storage environments.

Turning to the system may include an initiator data access components token provider s a store and other components not shown . The system may be implemented via one or more computing devices. Such devices may include for example personal computers server computers hand held or laptop devices multiprocessor systems microcontroller based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers cell phones personal digital assistants PDAs gaming devices printers appliances including set top media center or other appliances automobile embedded or attached computing devices other mobile devices distributed computing environments that include any of the above systems or devices and the like.

Where the system comprises a single device an exemplary device that may be configured to act as the system comprises the computer of . Where the system comprises multiple devices one or more of the multiple devices may comprise the computer of where the multiple devices may be configured similarly or differently.

The data access components may be used to transmit data to and from the store . The data access components may include for example one or more of I O managers filters drivers file server components components on a storage area network SAN or other storage device and other components not shown . As used herein a SAN may be implemented for example as a device that exposes logical storage targets as a communication network that includes such devices or the like.

In one embodiment a data access component may comprise any component that is given an opportunity to examine I O between the initiator and the store and that is capable of changing completing or failing the I O or performing other or no actions based thereon. For example where the system resides on a single device the data access components may include any object in an I O stack between the initiator and the store . Where the system is implemented by multiple devices the data access components may include components on a device that hosts the initiator components on a device that provides access to the store and or components on other devices and the like. In another embodiment the data access components may include any components e.g. such as a service database or the like used by a component through which the I O passes even if the data does not flow through the used components.

As used herein the term component is to be read to include hardware such as all or a portion of a device a collection of one or more software modules or portions thereof some combination of one or more software modules or portions thereof and one or more devices or portions thereof and the like. A component may include or be represented by code.

As used herein the term computer code is to be read to include instructions that dictate actions a computer is to take. These instructions may be included in any computer readable media volatile or nonvolatile.

In one embodiment the store is any storage media capable of storing data. The store may include volatile memory e.g. a cache and nonvolatile memory e.g. a persistent storage . The term data is to be read broadly to include anything that may be represented by one or more computer storage elements. Logically data may be represented as a series of 1 s and 0 s in volatile or nonvolatile memory. In computers that have a non binary storage medium data may be represented according to the capabilities of the storage medium. Data may be organized into different types of data structures including simple data types such as numbers letters and the like hierarchical linked or other related data types data structures that include multiple other data structures or simple data types and the like. Some examples of data include information program code program state program data commands other data or the like.

The store may comprise hard disk storage solid state or other nonvolatile storage volatile memory such as RAM other storage some combination of the above and the like and may be distributed across multiple devices e.g. multiple SANs multiple file servers a combination of heterogeneous devices and the like . The devices used to implement the store may be located physically together e.g. on a single device at a datacenter or the like or distributed geographically. The store may be arranged in a tiered storage arrangement or a non tiered storage arrangement. The store may be external internal or include components that are both internal and external to one or more devices that implement the system . The store may be formatted e.g. with a file system or non formatted e.g. raw .

In another embodiment the store may be implemented as a storage container rather than as direct physical storage. A storage container may include for example a file volume disk virtual disk logical unit logical disk writable clone volume snapshot logical disk snapshot physical disk solid state storage SSD hard disk data stream alternate data stream metadata stream or the like. For example the store may be implemented by a server having multiple physical storage devices. In this example the server may present an interface that allows a data access component to access data of a store that is implemented using one or more of the physical storage devices or portions thereof of the server.

The level of abstraction may be repeated to any arbitrary depth. For example the server providing a storage container to the data access components may also rely on a storage container to access data.

In another embodiment the store may include a component that provides a view into data that may be persisted in nonvolatile storage or not persisted in nonvolatile storage.

One or more of the data access components may reside on an apparatus that hosts the initiator while one or more other of the data access components may reside on an apparatus that hosts or provides access to the store . For example if the initiator is an application that executes on a personal computer one or more of the data access components may reside in an operating system hosted on the personal computer. An example of this is illustrated in .

As another example if the store is implemented by a storage area network SAN one or more of the data access components may implement a storage operating system that manages and or provides access to the store . When the initiator and the store are hosted in a single apparatus all or many of the data access components may also reside on the apparatus.

An offload read allows an initiator to obtain a token that represents data of a store. Using this token the initiator or another initiator may request an offload write. An offload write allows an initiator to cause an offload provider to write some or all of the data represented by the token.

In one embodiment a token includes a cryptographically secure number that is obtained via a successful offload read. At the present time one example of a cryptographically secure number is a 256 bit number generated in an appropriate way e.g. via creating a random number by sampling some random physical phenomena . Some exemplary procedures for generating cryptographically secure numbers are described in Request for Comments RFC 1750. With advances in technology both the length of the secure number and the procedure used to generate a cryptographically secure number may change without departing from the spirit or scope of aspects of the subject matter described herein.

A token represents data that is immutable as long as the token is valid. The data a token represents is sometimes referred to as bulk data.

An offload provider is an entity possibly including multiple components spread across multiple devices that provides indirect access to data associated with a token. Logically an offload provider is capable of performing an offload read and or offload write. Physically an offload provider may be implemented by one or more of the data access components and a token provider.

In servicing an offload read or offload write an offload provider may logically perform operations on the data of the store and or on tokens associated with a token provider. For example for an offload read an offload provider may logically copy data from a logical storage container backed by data of a store into a token which may also be backed by data of the store while for an offload write the offload provider may logically copy data from a token to a logical storage container backed by data of the store.

An offload provider may transfer data from a source store write data to a destination store and maintain data to be provided upon receipt of a token associated with the data. In some implementations an offload provider may indicate that an offload write command is completed after the data has been logically written to the destination store. In addition an offload provider may indicate that an offload write command is completed but defer physically writing data associated with the offload write until convenient.

In some implementations an offload provider may share data between a first logical storage container and a second logical storage container and may share data between a token and a storage container. The offload provider may stop sharing data as part of performing a write to physical storage locations of the store which would otherwise cause more than one storage container to be modified or would otherwise cause the data represented by a token to change.

In some implementations an offload provider may perform a logical copy from a storage container to a token or a logical copy from a token to a storage container by initiating sharing of data between a token and a storage container. For example the offload provider may perform an offload read by logically copying the data from the source storage container to the token by initiating sharing of data between the source storage container and the token. In another example the offload provider may perform an offload write by logically copying the data from the token to the destination storage container by initiating sharing of data between the token and the destination storage container.

In some implementations an offload provider may invalidate a token to for example avoid sharing data and or avoid physically copying data. For example the offload provider may perform an offload write by logically copying data from the token to the destination storage container by updating the data structures of the destination storage container to refer to the physical storage locations of the store referenced by the token and in conjunction therewith logically invalidate at least a portion of the token. Note that this may still result in the source and destination storage containers sharing data.

In some implementations an offload provider may initiate sharing of data storage locations among all tokens and storage containers already sharing the data and in addition another storage container or token. For example to service an offload read an offload provider may initiate sharing between a source storage container and a token. Then to service an offload write using the token the offload provider may initiate sharing among the source storage container the token and the destination storage container. If the token is later invalidated sharing with the token is stopped but the sharing between source and destination storage containers may continue e.g. until a write is received that is directed at that data .

As used herein in one implementation a token provider is part of an offload provider. In this implementation where a token provider is described as performing actions it is to be understood that the offload provider that includes the token provider is performing those actions. In another implementation a token provider may be separate from the offload provider.

To initiate an offload read of data of the store the initiator may send a request to obtain a token representing the data using a predefined command e.g. via an API . In response one or more of the data access components may respond to the initiator by providing one or more tokens that represents the data or a subset thereof. A token may be represented by a sequence of bytes which are used to represent immutable data. The size of the immutable data may be larger smaller or the same size as the token.

With a token the initiator may request that all or portions of the data represented by the token be logically written. Sometimes herein this operation is called an offload write. The initiator may do this by sending the token together with one or more offsets and lengths to the data access components .

The data access components may be implemented as a storage stack where each layer of the stack may perform a different function. For example the data access components may partition data split offload read or write requests cache data verify data snapshot data and the like.

One or more layers of the stack may be associated with a token provider. A token provider may include one or more components that may generate or obtain tokens that represent portions of the data of the store and provide these tokens to an initiator.

For a portion of an offload write for a token involved a token relative offset may be indicated as well as a destination relative offset. Either or both offsets may be implicit or explicit. A token relative offset may represent a number of bytes or other units from the beginning of data represented by the token for example. A destination relative offset may represent the number of bytes or other units from the beginning of data on the destination. A length may indicate a number of bytes or other units starting at the offset.

If a data access component fails an offload read or write an error code may be returned that allows another data access component or the initiator to attempt another mechanism for reading or writing the data.

The device may be considered to be one example of an offload provider as this device includes components for performing offload reads and writes and managing tokens.

The token provider may generate validate and invalidate tokens. For example when the initiator asks for a token for data on the store the token provider may generate a token that represents the data. This token may then be sent back to the initiator via the data access components and .

In conjunction with generating a token the token provider may create an entry in the token store . This entry may associate the token with data that indicates where on the store the data represented by the token may be found. The entry may also include other data used in managing the token such as when to invalidate the token a time to live for the token other data and the like.

When the initiator or any other entity provides the token to the token provider the token provider may perform a lookup in the token store to determine whether the token exists. If the token exists and is valid the token provider may provide location information to the data access components so that these components may logically read or write or logically perform other operations with the data as requested.

In another exemplary arrangement similar to the token provider and token store may be included in the device and the data access components connected to token provider . For example an operating system OS of the device may include the token provider and the token store . In this example the initiator may assume the existence of a token provider and token store for all copying performed by the initiator . With this assumption the initiator may be implemented to omit code that falls back to normal read and write.

In the example above the OS may implement offload read by logically reading the requested data from the data access components and storing the data in storage volatile or non volatile of device creating a new token value and associating the newly created token value with the read data. The OS may implement offload write by copying e.g. logically writing the data associated with the token to the destination specified by initiator . In this example the initiator may need to re attempt a copy at the offload read step in some scenarios but this re attempt may be less burdensome for the initiator than falling back to normal read and write.

The source initiator and the destination initiator may be implemented similarly to the initiator of . The source initiator and the destination initiator may be two separate entities or a single entity.

If the source storage container and the destination storage container are implemented by a single system the offload provider may be implemented as one or more components of the system implementing the storage containers. If the source storage container and the destination storage container are implemented by different systems the offload provider may be implemented as one or more components that are distributed across the systems implementing the storage containers.

Furthermore there may be more than two instances of storage containers and physical stores. For example for a given token obtained from a source there may be more than one destination specified. For example multiple offload writes may be issued which refer to a single token and each offload write may successfully target any destination known to the offload provider .

The source physical store and the destination physical store may be the same store or different stores. These physical stores store physical data that backs the source and destination storage containers and may also back the data represented by the tokens.

Although illustrated as only having one storage container between the initiator and the physical store as mentioned previously in other embodiments there may be multiple layers of storage containers between the initiator and the physical store.

The source initiator may obtain a token by issuing an offload read. In response the offload provider may generate a token and provide it to the source initiator .

If the source initiator and the destination initiator are separate entities the source initiator may provide the token to the destination initiator . The destination initiator may then use the token to issue an offload write to the destination storage container .

In receiving the offload write request the offload provider may validate the token and logically write data to the destination storage container as indicated by the offload write request.

With offload technology a standard or industry may dictate a certain fixed size of the token. For various reasons some implementers may desire a size that is larger than the standardized fixed size.

To accommodate larger sized tokens the standard may be modified to allow multiple tokens. A token larger than the fixed size may then be represented by multiple smaller subtokens of the fixed size. For example one standard requires a token to be 512 bytes. In an implementation for this standard the subtokens may each be exactly 512 bytes while the larger token may be larger than 512 bytes e.g. 995 2000 4096 or some other number of bytes .

The standard required field H may include any fields required or otherwise specified by a standard. For example the standard required fields H may include one or more of data that indicates when a token was generated data that indicates when the token is supposed to expire data that indicates where a token came from or other data specified by a standard.

The provider ID P may indicate an instance of an offload provider that generated the token. The provider ID P may be used in a threshold test to determine whether the token is to be ignored or not. If the provider ID P is not a provider ID that would have been provided by the offload provider the offload provider may reject the token altogether. Otherwise the offload provider may take additional actions to validate the token.

The vendor data V may include any data that a vendor implementing an offload provider may desire. As one example a vendor may include addressing information that indicates an address of an offload provider that provided the token . As other examples the vendor data V may include a hash key a digest a lookup key metadata data related to the bulk data data the helps identify or locate portions of the bulk data other data or the like.

The subtokens may be transmitted via virtually any protocol. For example in one example the subtokens may be transmitted via a Small Computer System Interface SCSI protocol. In another example the subtokens may be transmitted via a file sharing protocol that transfers file data via server message blocks. One exemplary file sharing protocol includes the Server Message Block SMB protocol. In another example the subtokens may be transmitted via a distributed file system protocol that is based on remote procedure calls to access files. One example protocol based on remote procedure calls includes the Network File System NFS protocol.

The examples above are not intended to be all inclusive or exhaustive of protocols that may be used. Indeed based on the teachings herein those skilled in the art may recognize many other protocols that may be used without departing from the spirit or scope of aspects of the subject matter described herein.

The subtokens may be tokens of a fixed size e.g. dictated by standard that represent the token . The subtokens may include various fields. For example a subtoken may include fields H H H . . . required by a standard a provider ID field P a token ID T sequence data S S S . . . a number that indicates how many subtokens represent the token and data corresponding to the data of the token . This other data is represented by H Rto R Vto V and Xto X where H corresponds to the standard required fields H in the token Rto Rcorrespond to the random data R in the token Vto Vcorrespond to the vendor data V in the token and Xto Xcorrespond to the other data X in the token .

The fields H H H . . . may include any data required or otherwise specified by a standard. This may include for example header or other fields specified by any version of the SCSI protocol. The fields H H H . . . may occur prior to and or after any other fields indicated in .

Where the SCSI protocol is used the fields H H H . . . may include for example header or other fields specified by any version of the SCSI protocol. Some exemplary fields include timestamp of token creation token type e.g. point in time copy address of source data identifying a representation of data token type data that identifies each of the subtokens as a token for transferring bulk data without requiring the bulk data to pass through an initiator of a command that requested the transferring other fields specified by the SCSI protocol or the like.

Where other protocols are used the fields H H H . . . may include for example fields required or allowed by those protocols. In one implementation the fields H H H . . . may be omitted altogether.

In some implementations the fields H H H . . . may also include for example types of data indicated above with respect to the standard required fields H of the token .

The provider ID P may indicate an instance of an offload provider that generated the token and may be used in the same manner as indicated above.

The token ID T may be data that identifies a subtoken as belonging to a group of subtokens that represent a larger token. For example a token ID of ABCD in each of the T fields of the subtokens may identify the subtokens as belonging to a group of subtokens that represent the token . If a subtoken has a different token ID the offload provider may determine that the subtoken is not part of the group of subtokens that represent the token .

The sequence data S S S . . . may include data that indicates an ordering of the subtokens. For example the sequence data may include an increasing number e.g. 1 2 3 4 etc. that indicates an order of the subtokens. The order may be used to combine the subtokens to reconstruct the token or portions thereof.

In one implementation data from the fields of the subtokens may be combined to construct all the data included in the token . For example in this implementation the combined data of the subtokens may include at least the data included in the token .

In another implementation the subtokens do not include all the data that is included in the token . For example the subtokens may include enough data to identify e.g. through a lookup table or other data structure data in the token . For example the subtokens may be combined to obtain R and address information. R and the address information may then be used by an offload provider to look up the other information included in the token .

In another example one or more of the subtokens may include data that may be used to map to the random data R. In this example the random data R cannot be reconstructed from the data found solely in the subtokens but the random data R may be found e.g. in a lookup table from the random data included in one or more of the subtokens . In this example other data e.g. the address data of the token may be included in one or more of the subtokens . The address data may then be used to locate a mapping table for example that may be used to locate the other data included the token .

A similar mechanism may also be used to find other omitted data that is not physically found in the subtokens but that may be found using data that maps to the omitted data.

In one example one of the subtokens sometimes referred to herein as the master subtoken may include all of the random data R while the other subtokens may not include any data that corresponds to the random data R. In another example the subtokens may each include data that corresponds to the random data R.

Various mechanisms may be used to validate the token . In one example after the token is reconstructed from the subtokens a bitwise comparison is performed to determine whether the token is exactly a token generated by the offload provider. If the bits in the token equal the bits found for a token having R in the token store the token may be determined to be valid.

In another example a digest of the token may be computed and the digest may be compared to digests of tokens generated by the offload provider. In this example a digest may be selected that has a low or no possibility of colliding with other digests. In this example if the digest is equal to a digest of a token generated by the offload provider the token may be determined to be valid.

In another example the token may be determined to be valid if R is equal to an R of a token stored by the offload provider.

In one implementation the larger token is a token that is provided and actually exists and is implemented as one or more data structures. The larger token may be physically divided into the multiple subtokens which may also be recombined to form the larger token .

In another implementation the larger token comprises a virtual offload token that logically includes the fields illustrated for the token but where all the fields may not actually be in the same data structure. In this implementation the token does not go through a period where a single chunk of data includes all the fields of the token . Instead the subtokens include data corresponding to the token or data usable to find the data of the token but the subtokens are not actually combined to form a monolithic chunk of data that includes the fields of the token . Likewise in this implementation the token is not first created and then divided into the subtokens . The larger token is referred to as a virtual offload token because it does not exist physically and independently of the subtokens but exists virtually in the data of the subtokens . It is to be understood that when the token is described herein that both implementations are contemplated.

The offload provider as illustrated is separated into a source offload provider and a destination offload provider to indicate that components of the offload provider may be on different machines that communicate with each other to perform the functions of the offload provider . In another example however the source offload provider and the destination offload provider may be merged and placed on a single computer. In one implementation the source offload provider and the destination offload provider are different offload providers altogether that may negotiate the transmission of offload data in response to an offload write command.

The initiator initiates an offload read or write. In one example the initiator may be separated into a source initiator and destination initiator as illustrated in where the source initiator initiates an offload read and obtains multiple subtokens in response thereto and then provides the subtokens to the destination initiator which later initiates an offload write. In another example the initiator may directly initiate both the offload read and the offload write.

It is to be understood that an offload write is an offload write regardless of form. For example forwarding a token to a different machine that in turn issues an offload write is really just a different way for an offload read initiator to initiate on offload write.

The source storage stack and the destination storage stack may each be implemented by one or more components arranged in layers where each layer may perform a different function.

The spittler injector may include one or more components. The spittler injector may receive an offload read command from the source storage stack . In response the spittler injector may send an offload read command to the source offload provider . In response to the offload read command the source offload provider may provide a large token. After receiving the large token the spittler injector may split the token into a plurality of smaller tokens and provide these smaller tokens to the source storage stack . The subtokens may for example be of a fixed standardized size as mentioned previously.

In one implementation an offload read command may include a number that indicates how many subtokens may be provided in response to the offload read. This number may originate from the initiator or a component of the source storage stack .

If the spittler injector determines that the number is large enough the spittler injector may provide the subtokens as requested by the source storage stack . Otherwise in one example the spittler injector may return a message that indicates how many subtokens are needed to respond to the offload read request. In another example the spittler injector may return an error that indicates that the number is not large enough and may allow the initiator to try a larger number s if the initiator determines to do so.

In another implementation an offload read command may omit a number that indicates how many subtokens may be provided in response to the offload read. In this implementation the component sending the offload read command may request subtokens until the spittler injector indicates that all subtokens for the offload read command have been provided.

In another implementation the spittler injector may indicate a number of subtokens that were generated in response to the offload read command. The component that sent the offload read command may then be responsible for obtaining the subtokens from the spittler injector .

In an offload write command with multiple subtokens the initiator may send the subtokens to the destination storage stack which may send the subtokens to the combiner extractor . The combiner extractor may then combine the subtokens into a single large token and provide the single large token to the destination offload provider .

The subtokens may be provided in a single message or in multiple messages depending on implementation.

In one implementation the spittler injector may be combined with the source offload provider and the combiner extractor may be combined with the destination offload provider . In at least this implementation the spittler injector may inject data of a virtual offload token into the subtokens while the combiner extractor may extract the data from the subtokens without the larger token ever existing as a physical data structure.

At block a message is received that indicates that two or more subtokens represent a larger token. The subtokens are each of a fixed size e.g. a size specified by a standard . The larger token has a size larger than the fixed size. This means that the data included in the larger token is more than can fit into one of the subtokens. The data corresponding to the larger token is maintained by an offload provider. The data may be maintained in a single data structure corresponding to the larger token or in multiple data structures e.g. that are not combined . The larger token represents data that is immutable as long as the data is larger token is valid.

For example referring to the combiner extractor may receive subtokens from the destination storage stack . The subtokens may be provided by the initiator in conjunction with an offload write directed to the destination storage stack .

At block data is extracted from the subtokens. Extracting data may include for example combining the subtokens into a larger token prior to obtaining the data or obtaining the data from the subtokens without combining the subtokens into the larger token. For example referring to the combiner extractor may combine extract data from the subtokens. For example some of the data extracted may include a number that associates the token with the data the token represents. This number is sometimes referred to as a key.

At block the key is obtained from one or more of the subtokens. For example referring to after the combiner extractor combines the subtokens to form a larger token the destination offload provider may obtain the key from the larger token. As another example without physically combining the data of the subtokens the combiner extractor may extract the key from a virtual token e.g. one or more of the subtokens without physically combining all the data of the subtokens.

At block evidence of the key is provided to a component of the offload provider. Using the evidence the key may be validated as part of the actions of block or as a separate set of actions. Providing evidence of the key may include for example 

At block an offload read request is received. For example referring to the source offload provider receives an offload read request initiated by the initiator .

At block in response to the offload read message a key is generated to return in response to the offload read message. The key in placed in a token physical or virtual the data of which will be placed into subtokens to return in response to the offload read message. For example referring to the source offload provider may generate a token that includes the key.

At block the data of the token is divided injected into subtokens. For example referring to the splitter injector takes the data from the token generated at block and splits injects the data into subtokens that are provided to the source storage stack for delivery to the initiator .

At block evidence of the key is received. For example referring to a component of the source offload provider receives evidence of the key. In one example this evidence may be received as the offload provider obtains the key from the subtokens received from the combiner extractor . In another example a component of the offload provider at a destination of an offload write e.g. the destination offload provider may obtain the key included in the subtokens read an address contained therein use the address to contact a component e.g. the source offload provider of the offload provider that generated the key and provide the key to the component. In another example a destination offload provider that is a different offload provider from the source offload provider may receive the key and addressing information contact the source offload provider and provide the key. Using the evidence the key may be validated as part of the actions of block or as a separate set of actions.

At block bulk data corresponding to the token is provided. For example referring to the source offload provider may provide a portion or all of the bulk data corresponding to the token to the destination offload provider .

At block an offload read request is initiated by communicating with a component of a source storage stack. For example referring to the initiator may send an offload read request to the source storage stack . In conjunction with the offload read request a number may be send that indicates a maximum number of subtokens that are allowed to be returned in response to the offload read request.

At block in response to the message subtokens are received. The subtokens represent a token physical or virtual that is larger than any of the subtokens individually. The larger token represents data that is immutable as long as the larger token is valid. For example referring to in response to the offload read request the initiator receives multiple subtokens. In conjunction with receiving the subtokens a number may be received that indicates how many subtokens were generated in response to the offload read request.

At block the initiator provides the subtokens to a component of a destination storage stack. For example referring to the initiator provides the subtokens to a component of the destination storage stack .

As can be seen from the foregoing detailed description aspects have been described related to offload technology. While aspects of the subject matter described herein are susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit aspects of the claimed subject matter to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of various aspects of the subject matter described herein.

