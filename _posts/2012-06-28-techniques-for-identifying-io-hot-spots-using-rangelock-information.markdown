---

title: Techniques for identifying IO hot spots using range-lock information
abstract: A technique of identifying IO hot spots is performed in a data storage apparatus (e.g., a file server). The technique involves updating, in response to host IO operations which lock ranges of extents prior to accessing the ranges of extents, contents of a lock history database based on the ranges of extents which were locked by the host IO operations. The technique further involves receiving a lock history request. The technique further involves providing, in response to the lock history request, the contents of the lock history database to identify, as the IO hot spots, extents which were locked by the host IO operations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954699&OS=08954699&RS=08954699
owner: EMC Corporation
number: 08954699
owner_city: Hopkinton
owner_country: US
publication_date: 20120628
---
In general data storage systems perform host IO input output operations on behalf host devices. Along these lines such data storage systems typically store host data within logical units LUNs .

Some data storage systems collect access activity data on 1 Gigabyte GB LUN sections i.e. LUN slices. These data storage systems then use such collected data to control the operation of various advanced data services. Data placement is an example of an advanced service which conventionally operates based on access activity collected at LUN slice granularity.

Unfortunately there are deficiencies to the above described conventional approach to controlling advanced data services based on data collected at the LUN slice granular level. For example in connection with data placement which places data among different storage tiers based on LUN slice activity due to the coarse 1 GB granularity of a LUN slice the conventional approach cannot distinguish between i one LUN slice which is accessed in an evenly distributed manner and ii another LUN slice having a few data blocks which are very active and large areas which are very inactive. Rather both LUN slices would be treated in the same manner by the conventional approach even though it might be preferable to promote one of the LUN slices to a higher storage tier.

One might consider simply changing the level of granularity from a LUN slice to a data block e.g. 8 KB 4 KB 512 bytes etc. . Unfortunately individually counting host IO operations at the data block level would be extremely costly in terms of overhead. That is the processing time and the amount of memory required to track the number of host IO operations to each data block makes this alternative prohibitively expensive. Furthermore this approach may cause fragmentation of the file system since each block would be counted individually without considering spatial locality of reference.

In contrast the above described conventional approach to moving LUN slices among storage tiers based on the counted number of host IO operations for each LUN slice an improved technique identifies IO hot spots based on ranges of extents of host IO operations. In particular as host IO operations access ranges of extents on a data storage apparatus locks on these ranges which are used to synchronize access to data e.g. between a host IO operation and other system activities can be tracked by a lock history database. IO hot spots i.e. active extents can then be identified from the information in the lock history database and data storage services can be configured to smartly operate based on the identified IO hot spots such as an automated data placement service which places data among storage tiers. Such monitoring of range locks provides better precision than LUN slice granularity e.g. the ability to identify one or more IO hot spots within a LUN slice . Additionally such monitoring of range locks does not require a prohibitive amount of system resources. Rather such monitoring provides a practical means to identify IO hot spots even when such IO hot spots are sprinkled in large areas of cold data.

One embodiment is directed to a method of identifying IO hot spots which is performed in a data storage apparatus e.g. a file server . The method includes updating in response to host IO operations which lock ranges of extents prior to accessing the ranges of extents contents of a lock history database based on the ranges of extents which were locked by the host IO operations. The method further includes receiving a lock history request. The method further includes providing in response to the lock history request the contents of the lock history database to identify as the IO hot spots extents which were locked by the host IO operations.

In some arrangements the lock history database includes range lock entries each range lock entry identifying a respective host IO operation and a respective range of extents which was locked by the respective host IO operation. In these arrangements updating the contents of the lock history database includes receiving an IO event message indicating a particular host IO operation and a particular range of extents which was accessed by the particular host IO operation and adding a new range lock entry to the lock history database. The new range lock entry identifies the particular host IO operation and the particular range of extents which was locked by the particular host IO operation.

In some arrangements each range lock entry includes a lock type field a storage object identifier field a time stamp field and a set of range fields. In these arrangements adding the new range lock entry to the lock history database includes 

One should appreciate that among the deficiencies for a thin LUN TLU a range of the LUN could be spread out on multiple slices and in this situation the overall level of measured activity i.e. temperature of the LUN may increase. However with IO hot spots identified based on locked ranges of extents such IO hot spots are more precisely identified by LUN range.

Other embodiments are directed to systems apparatus processing circuits computer program products and so on. Some embodiments are directed to various methods devices electronic components and circuitry which are involved in identifying IO hot spots.

Improved techniques identify IO hot spots based on ranges of extents which are locked while servicing host IO operations. In particular as host IO operations access ranges of extents on a data storage apparatus the locks on these ranges can be tracked by a lock history database. IO hot spots can then be identified from the information in the lock history database and data storage services can be configured to smartly operate based on the identified IO hot spots. Such monitoring of range locks provides good spatial and temporal locality of reference information of IO access patterns. Furthermore such monitoring of range locks does not require a prohibitive amount of system resources. Rather such monitoring provides a practical means to identify IO hot spots even when such IO hot spots are sprinkled in large areas of cold data.

The host devices are constructed and arranged to store host data into and load host data from the data storage system . Along these lines each host device provides host IOs e.g. read commands to read host data write commands to write host data etc. to the data storage system for processing.

The data storage system is constructed and arranged to process the host IOs from the host devices by performing host IO operations e.g. read IOs write IOs etc. in response to the host IOs on a set of LUNs . Each LUN 34 is partitioned into 1 GB slices and each 1 GB slice is partitioned into extents e.g. 8 KB data blocks . Such extents are addressable e.g. via logical block addressing or LBAs and are mappable e.g. to file system block numbers or FSBNs .

Additionally the data storage system is constructed and arranged to manage a lock history database which stores range lock information gathered while imposing range locks on ranges of extents which are accessed by the host IO operations performed on behalf of the host devices . As will be explained in further detail shortly the data storage system is able to identify active extents i.e. hot spots or frequently accessed extents from the range lock information stored in the lock history database and adjust its operation based on such information.

The communications medium connects the various components of the data storage environment together to enable these components to exchange electronic signals e.g. see the double arrow . At least a portion of the communications medium is illustrated as a cloud to indicate that the communications medium is capable of having a variety of different topologies including backbone hub and spoke loop irregular combinations thereof and so on. Along these lines the communications medium may include copper based data communications devices and cabling fiber optic devices and cabling wireless devices combinations thereof etc. Furthermore the communications medium is capable of supporting LAN based communications SAN based communications or combinations thereof.

During operation the data storage system receives host IOs from the host devices . In order to maintain data consistency the data storage system imposes locks on the extents when processing the host IOs . For example the data storage system applies read or shared locks on ranges of extents when the host devices read host data from these ranges of extents . Furthermore the data storage system applies write or exclusive locks on ranges of extents when the host devices write host data to these ranges of extents .

As the data storage system imposes range locks on the ranges of extents the data storage system updates the contents of the lock history database based on these range locks. Accordingly the data storage system is then able to identify which extents are active or inactive based on the contents of the lock history database . Further details will now be provided with reference to .

The host interface is constructed and arranged to connect the data storage system to the communications medium . Accordingly the host interface enables the data storage system to communicate with the other components of the data storage environment such as the host devices .

The memory is intended to represent both volatile memory e.g. DRAM SRAM etc. and non volatile memory e.g. flash storage units magnetic disk drives etc. . The data storage applications represent the operating system drivers utilities and tools user level applications GUIs and so on. The storage represents memory which contains the host data. The other memory constructs include additional memory based items such as a buffer cache metadata for locks and so on.

In some arrangements the storage is tiered based on access speed. For example the storage may include a first tier of flash memory a second tier of SAS memory and a third tier of near line SAS memory.

The processing circuitry is constructed and arranged to perform load and store operations i.e. to process host IOs on behalf of the host devices . Additionally the processing circuitry is constructed and arranged to manage the contents of the lock history database and to identify which extents are active or inactive based on the contents of the lock history database .

It should be understood that the processing circuitry can be implemented in a variety of ways including via one or more processors running specialized software application specific ICs ASICs field programmable gate arrays FPGAs and associated programs discrete components analog circuits other hardware circuitry combinations thereof and so on. In the context of one or more processors running specialized software a computer program product is capable of delivering all or portions of the software to the data storage system . The computer program product has a non transitory or non volatile computer readable medium which stores a set of instructions which controls one or more operations of the data storage system . Examples of suitable computer readable storage media include tangible articles of manufacture and apparatus which store instructions in a non volatile manner such as CD ROM flash memory disk memory tape memory and the like.

During operation the data storage system performs host IO operations in response to the host IOs received from the host devices also see . As the data storage system imposes locks on ranges of extents prior to accessing the ranges of extents the data storage system updates the contents of the lock history database based on the ranges of extents which were locked by the host IO operations .

With the contents of the lock history database now available for analysis the contents of the lock history database are able to identify particular extents which are active and inactive. As a result the data storage system is able to adjust its operation relying on precision which is better than a conventional approach which simply counts host IO operations for each LUN slice. Furthermore the data storage system is not overburdened with exhaustively counting host IO operations at the data block level which could be too costly to be practical. Further details will now be provided with reference to .

The range lock module is constructed and arranged to impose range locks on ranges of extents as the data storage system performs the host IO operations and thus preserve data coherency and consistency. By way of example the range lock module is shown as responding to a host IO to read host data from extents A . . . B by providing while a host IO operation is being serviced a read lock i.e. a shared lock on extents A . . . B . Additionally the range lock module is shown as responding to another host IO to write host data to extents X . . . Y by providing a write lock i.e. an exclusive lock on extents X . . . Y .

The lock history module is constructed and arranged to manage the lock history database . In particular the lock history module receives IO event messages from the range lock module which informs the lock history module of the range locks imposed by the range lock module . For example when the range lock module imposes the read lock on extents A . . . B the range lock module provides an IO event message informing the range lock module that a read lock was imposed on the range of extents A . . . B and the lock history module responds by adding an appropriate entry into the lock history database . Likewise when the range lock module imposes the write lock on extents X . . . Y the range lock module provides an IO event message informing the range lock module that a write lock was imposed on the range of extents X . . . Y and the lock history module responds by adding another appropriate entry into the lock history database .

As further shown by the set of service modules are able to communicate with the lock history module . For example a service module such as a data placement module may send a request signal to the lock history module to obtain the contents of the lock history database e.g. recorded range lock information. In response to the request signal the lock history module provides a response signal containing the contents of the lock history database thus enabling the data placement module to operate based on the contents of the lock history database .

In some arrangements the range lock module and the set of service modules communicate with the lock history module through an application programming interface API . That is each module is able to call a predefined routine or issue a predefined instruction to the lock history module . Similarly the lock history module is able to call a predefined routine or issue a predefined instruction to the other modules . Further details will now be provided with reference to .

As shown in the lock history database includes a set of range lock entries . Each time the lock history module receives an event message informing the lock history module of a new lock imposed on a range of extents from the range lock module the lock history module adds a new range lock entry in the lock history database to record that lock also see .

Each range lock entry includes a lock type field a storage object identifier field a time stamp field and a set of range fields . The fields of each range lock entry hold range lock information corresponding to a range lock imposed by the range lock module during a particular host IO operation thus recording the details of that range lock . In particular the lock type field holds a value indicating the type of lock e.g. a read lock a write lock a new allocation lock a de allocation lock etc. for that range lock . The storage object identifier field holds a storage object identifier to identify a storage object for that range lock e.g. a particular logical unit or file among multiple storage objects maintained for reading and writing by the data storage system . The time stamp field holds a time stamp indicating a particular time in which a particular host IO operation locked the range of extents . The set of range fields holds range data identifying the particular range of extents which was locked by the particular host IO operation .

In some arrangements the set of range fields includes a starting offset field and a range length field . The starting offset field of a range lock entry holds a starting offset of a particular range lock and the range length field holds the length of that particular range lock .

In other arrangements the set of range fields define range locks differently. For example in some arrangements the set of range fields simply includes a start offset field and an end offset field to hold the starting and ending offsets of a particular range lock .

Once a set of range lock entries has been processed to produce aggregated lock data the aggregated lock data indicates the extents that had been identified by the set of range locks . Accordingly the aggregated lock data identifies extents which have been recently accessed and which are thus considered active or hot . Once the aggregated lock data has been formed future processing of a new set of range lock entries i.e. range lock entries which have been added to the lock history database since the last consolidation process involves adjusting or updating the existing aggregated lock data based on the new set of range lock entries .

In some arrangements when the lock history module receives a request signal for the contents of the lock history database the lock history module performs the consolidation process on any existing range lock entries to update the aggregated lock data . The lock history module then provides as a response signal only the aggregated lock data . For example the response signal may include a file or a pointer to a file containing just the aggregated lock data or a copy of the aggregated lock data .

In some arrangements the aggregated lock data persists until it is cleared e.g. in response to a user command to reset the values of the lock history database . In some arrangements the lock history database resides in non volatile storage so that the lock history database persists even during a reboot of the data storage system .

In some arrangements the aggregated lock data includes a mapping table which maps tallied access counts to each extent . In other arrangements the aggregated lock data includes nodes corresponding to time intervals e.g. one hour ago two hours ago etc. where each node identifies ranges of extents which have been accessed within a particular time interval. Accordingly the particular structure for the range lock information in the aggregated lock data may take a variety of forms e.g. trees linked lists counters combinations thereof and so on.

One will appreciate that a variety of criteria may be used as a determining factor as to whether each extent is active or inactive. In some arrangements if the lock history database indicates that an extent was accessed within a predefined amount of time e.g. an hour six hours etc. the extent is considered active. In other arrangements if the lock history database indicates that an extent was accessed at least a certain predefined amount of times within a particular amount of time e.g. at least 3 times within the last 24 hours etc. the extent is considered active. Similarly an extent may be considered inactive if the extent fails to satisfy the active criteria. Further details will now be provided with reference to .

In step the lock history module receives a lock history request. For example a service module may provide a request signal to the lock history module requesting the contents of the lock history database .

In step the lock history module providing the contents of the lock history database to identify as the IO hot spots extents which were locked by the host IO operations . In particular the lock history module outputs a response signal back to the requesting service module .

As described above an improved technique identifies IO hot spots based on ranges of extents which are locked by host IO operations . In particular as host IO operations access ranges of extents on a data storage system the locks on these ranges can be tracked by a lock history database . IO hot spots i.e. active extents can then be identified from the information in the lock history database and data storage services can be configured to smartly operate based on the identified IO hot spots. Such monitoring of range locks provides better precision than LUN slice granularity e.g. the ability to identify one or more IO hot spots within a LUN slice . Additionally such monitoring of range locks does not require a prohibitive amount of system resources. Rather such monitoring provides a practical means to identify IO hot spots even when such IO hot spots are sprinkled in large areas of cold data.

While various embodiments of the present disclosure have been particularly shown and described it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the present disclosure as defined by the appended claims.

For example it should be understood that the lock history database may be updated with range lock information just before during or after the range of extents is accessed. Accordingly for implementations in which it is crucial to have range lock information which is as accurate as possible the lock history database may be update just before or during each host IO operation . Alternatively for implementations in which accuracy is not as critical the lock history database may be updated after each host IO operation .

Additionally it should be understood that there is no restriction to the size of an extent . By definition an extent is simply part of a slice. Accordingly an extent may be relatively large e.g. several Megabytes in size or relatively small e.g. the size of a standard data block . Regardless the above described improved techniques enable effective and efficient identification of IO hot spots at a finer level of granularity than a 1 GB LUN slice. Moreover the above described improved techniques consume significantly less resources than an alternative of simply counting accesses of each block of a data storage system. Such modifications and enhancements are intended to belong to various embodiments of this disclosure.

