---

title: Virtual machine stage detection
abstract: A computer implemented method for categorizing a virtual machine stage. A data processing system starts a virtual machine. It sets factor-stage ranges, wherein for each combination factor and stage, a corresponding range is present, and wherein each range is as broad as a reset range. It sets a frequency for sampling virtual machine metrics and samples virtual machine metrics to form a plurality of virtual machine metrics for each factor. It applies a value to each range satisfied by each virtual machine metric, to form a plurality of stage-qualifying values corresponding to a range, and sums all stage-qualifying values for each stage, to form a stage likelihood. The data processing system further selects a stage corresponding a highest stage likelihood. The data processing system determines if the current range is different from a former range. The system expands each range corresponding to the current stage.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08756603&OS=08756603&RS=08756603
owner: International Business Machines Corporation
number: 08756603
owner_city: Armonk
owner_country: US
publication_date: 20120702
---
This application is related to commonly assigned U.S. Pat. No. 8 533 712 entitled VIRTUAL MACHINE STAGE DETECTION.

The present invention relates generally to a computer implemented method for determining status of a virtual machine. More specifically the present invention relates to adapting algorithms strategies or heuristics in a data processing system in response to the level and type of activity performed in a virtual machine hosted therein.

A computer especially one that hosts compartmentalized virtual machines can evolve the status of its execution from the moment of powering on to the moment that it is powered off. In a data processing system that hosts multiple virtual machines each virtual machine can be assigned a client where an organization relies on the virtual machine to support data processing functions of the organization.

As is common a data processing system can be split among several clients. Each client contracts with the owner of the data processing system. Accordingly for each client in order to achieve its business objectives one or more virtual machines are started. Before long each virtual machine may achieve a steady state of processing client tasks. Eventually each virtual machine may reach an idle state where activity is minimized for example because a business day is concluded.

Recognizing when a virtual machine has transitioned among stages can be beneficial since each stage brings new problems and opportunities.

The present invention provides a computer implemented method for categorizing a virtual machine stage based on a set of virtual machine metrics that are easy to obtain. A data processing system starts a virtual machine. It sets factor stage ranges wherein for each combination factor and stage a corresponding range is present and wherein each range is at least as broad as a reset range. It sets a frequency for sampling virtual machine metrics and samples virtual machine metrics consistent at a frequency to form a plurality of virtual machine metrics for each factor. It applies a value to each range satisfied by each virtual machine metric to form a plurality of stage qualifying values corresponding to a range and a stage . It also sums all stage qualifying values corresponding to each stage to form a stage likelihood for each of the stages. The data processing system further selects a stage corresponding having a highest stage likelihood among the plurality of stage likelihoods as the current stage. The data processing system determines if the current range is different from a former range. The data processing system expands each range corresponding to the current stage and may adapt its internal algorithms responsive to a determination that the current range is different.

With reference now to the figures and in particular with reference to a block diagram of a data processing system is shown in which aspects of an illustrative embodiment may be implemented. Data processing system is an example of a computer in which code or instructions implementing the processes of the present invention may be located. In the depicted example data processing system employs a hub architecture including a north bridge and memory controller hub NB MCH and a south bridge and input output I O controller hub SB ICH . Processor main memory and graphics processor connect to north bridge and memory controller hub . Graphics processor may connect to the NB MCH through an accelerated graphics port AGP for example. Main memory may be formed of dynamic random access memory or other forms of volatile memory. Volatile memory is memory that relies on resupplies of charge or other energy carriers in order to record and make accessible data.

In the depicted example local area network LAN adapter connects to south bridge and I O controller hub and audio adapter keyboard and mouse adapter modem read only memory ROM hard disk drive HDD CD ROM drive universal serial bus USB ports and other communications ports and PCI PCIe devices connect to south bridge and I O controller hub through bus and bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS . Hard disk drive and CD ROM drive may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. A super I O SIO device may be connected to south bridge and I O controller hub .

An operating system runs on processor and coordinates and provides control of various components within data processing system in . The operating system may be a commercially available operating system such as Microsoft Windows XP. Microsoft and Windows are trademarks of Microsoft Corporation in the United States other countries or both. An object oriented programming system such as the Java programming system may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . Java is a trademark of Oracle Corp. Inc. in the United States other countries or both.

Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor . The processes of the present invention can be performed by processor using computer implemented instructions which may be located in a memory such as for example main memory read only memory or in one or more peripheral devices.

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory and the like may be used in addition to or in place of the hardware depicted in . In addition the processes of the illustrative embodiments may be applied to a multiprocessor data processing system.

In some illustrative examples data processing system may be a personal digital assistant PDA which is configured with flash memory to provide non volatile memory for storing operating system files and or user generated data. A bus system may be comprised of one or more buses such as a system bus an I O bus and a PCI bus. Of course the bus system may be implemented using any type of communications fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communication unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. A memory may be for example main memory or a cache such as found in north bridge and memory controller hub . A processing unit may include one or more processors or CPUs. The depicted example in is not meant to imply architectural limitations. For example data processing system also may be a tablet computer laptop computer or telephone device in addition to taking the form of a PDA.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

A virtual machine is one or more data structures that emulate physical hardware and are organized by executing computer instructions on a data processing system such as for example data processing system . A virtual machine may rely on portions of physical hardware to provide features such as volatile memory storage registers and processing cycles. Occasionally the underpinning hardware may vary from the virtual machine instantiation. For example volatile memory as a physical data processing system resource can be substituted for and support a virtual machine implementation of disk storage. A data processing system resource is a physical circuit storage device or communication facility that can be used in support of a virtual machine. A virtual machine may be for example a Java Virtual Machine JVM . JVM is a trademark of Oracle Corp.

An internal JVM profiler like profiler is a JVM component that detects Java methods that may consume a significant amount of CPU resources while executing. In one possible implementation the internal JVM profiler is based on a sampling mechanism which periodically inspects the Java stacks of running threads. At each sampling point the methods found at the top of the stack receive one more tally. Methods with more tallies are considered to be statistically more active than methods with fewer tallies and may be considered for just in time jit compilation in order to improve the JVM s performance. Data collected at a sampling point is called a sample . A sample that falls on a method which runs as interpreted is called an interpreted sample . Similarly a sample that is attributed to a Java method which already has been just in time compiled is called a compiled sample . During the incipient stage of a Java application most of the Java methods are running as interpreted and the expectation is that interpreted samples will predominate. As time goes by more and more Java methods are jit compiled which can result in a majority of samples being compiled samples.

A class is a description or template for creating instances of objects. The class may include variables methods or both. An object is a dynamically created class instance or an array. The allocation of memory and accessing of variables for the object is called instantiation. The manner in which an object is instantiated in written Java code is to state new . An object can be a class in which case the class defines the manner of making an object. Accordingly the class is a pattern for creating an object of that type. The class can further define the variables that an instantiated object will contain as well as the methods of the instantiated object. Every object of that type can use variables and methods declared or described in the class.

A garbage collector GC is a JVM component that allows memory occupied by dead objects to be made free for future allocation of objects. The garbage collector such as garbage collector may consolidate live objects in memory such that free memory is available in at least one larger contiguous block.

At the center of a Java run time environment is the JVM which supports many aspects of Java s environment including its architecture security features mobility across networks and platform independence. The JVM is a virtual computer that is a computer that is specified abstractly. The specification defines certain features that every JVM must implement with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.

The JVM is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format. The compiled code is executable on many processors given the presence of the Java run time system. The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Bytecodes may be translated into native code by a just in time compiler or JIT.

A JVM loads class files and executes the bytecodes within them. The class files are loaded by a class loader in the JVM. The class loader loads class files from an application and the class files from the Java application programming interfaces APIs which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.

One type of software based execution engine is a just in time JIT compiler. With this type of execution the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. A just in time completion or jit is the conversion of bytecodes of the method to native machine code at runtime. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively.

A method is compiled in response to the data processing system receiving a request to compile. A request to compile may occur because another method required the functionality of the method to be compiled or because an internal JVM profiling component detected the method to be critical to performance. The number of compilation requests that a JVM receives can be relevant to the stage in which the JVM currently exists. In addition the type of compilation is also relevant. Accordingly the JVM may make a distinction between a first compilation request made for a method and a second compilation request recompile request for the method.

When an application is executed on a JVM that is implemented in software on a platform specific operating system a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language compiled to bytecodes and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.

Runtime data areas contain native method stacks Java stacks Program Counter PC registers method area and heap . These different data areas represent the organization of memory needed by JVM to execute a program.

Java stacks are used to store the state of Java method invocations. When a new thread is launched the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks it pushes and pops frames. A thread s Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method the JVM pushes a new frame onto the Java stack of the thread. When the method completes the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the Java instruction set is well defined for a variety of platform architectures.

Program counter PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java stack. If the thread is executing a method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined.

Native method stacks stores the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some JVM implementations native method stacks and Java stacks are combined.

Method area contains class data while heap contains all instantiated objects. The constant pool is located in method area in these examples. The JVM specification strictly defines data types and operations. Most JVMs have one method area and one heap each of which is shared by all threads running inside the JVM such as JVM . When JVM loads a class file it parses information about a type from the binary data contained in the class file. JVM places this type of information into method area . Each time a class instance or array is created the memory for the new object is allocated from heap . JVM includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space. The memory space is within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

The following definitions will be used in the description of the steps used by illustrative embodiments.

A Class is a combination of methods and data that are encapsulated in a file that defines how data are stored and accessed. A class may form a template from which instances of running code may be created or instantiated.

A client is an executing program that relies on other entities or executing software to access or process data for the client. In some cases the data to be processed may be a fully qualified class name and the result returned may be an instance.

A code object or object is code that may be interpreted JVM compiled i.e. bytecodes or machine language. It may be an example of a class once instantiated for a specific purpose.

Object Instantiator or ObjectInstantiator is a program or class that creates an instance of an object when executed by a processor. The object created by the Object Instantiator conforms to the concept of an object as defined by Object Oriented Programming OOP but in general will be an encapsulated representation of actions and data which may or may not inherit from or allow its action and data to be inherited by other objects. The concept of ObjectInstantiator includes object creator or ObjectCreator.

The illustrative embodiments can include a data processing system to determine for virtual machine metrics associated with virtual machine which among criteria for a hypothetical virtual machine stage is met by the one or more virtual machine metrics. Further the data processing system may determine a count of the criteria met for each among the possible virtual machine stages. Further the data processing system may determine which virtual machine stage has the most criteria met and accordingly select that virtual machine stage. Consequently the data processing system may change an allocation of data processing system resources in response to selecting the selected virtual machine stage. As a result the data processing system may optimize processing for the virtual machine or more efficiently allocate data processing system resources among several virtual machines that may simultaneously compete for such resources.

Next the data processing system may set a wake up frequency step . The wake up frequency may be used to periodically trigger the collection or sampling of virtual machine metrics by the virtual machine task which is typically performed on a dedicated thread called the sampling thread . Further processing may determine if such virtual machine metrics signal a new stage to which the virtual machine has transitioned.

Next the sampling thread sleeps. In response to the sleep period expiring step further action may be taken. The sleep period corresponds to the wake up frequency set earlier. When the sleep time expires the virtual machine may collect non direct central processing unit or non direct CPU metrics step . A non direct CPU metric is a virtual machine metric that is not based on hardware performance counters available in modern CPUs. Accordingly the non direct CPU metric is a metric obtainable without resorting to use of a kernel device driver. While most virtual machine metrics can be directly obtained from the internal data structures of the virtual machine itself and thus can be inquired very cheaply some need operating system support. An example of such a virtual machine metric requiring operating system support is the CPU utilization.

Next the virtual machine may select a stage based on the virtual machine metrics such as the non direct CPU metrics step . This step may be performed as three substeps. First the virtual machine may apply a value to each range satisfied by each virtual machine metric to form a plurality of stage qualifying values corresponding to a factor stage range. For example a factor stage range that is satisfied may be assigned a value of 1 while any such factor stage range that is unsatisfied may be assigned a value of 0. A higher value may be used when a factor stage range is preferred to be weighted heavier relative to other factor stage ranges. A smaller value may be used if the factor stage range is intended to be de emphasized relative to other factor stage ranges.

Second the virtual machine may sum all stage qualifying values corresponding to each stage or hypothetical stage to form a stage likelihood for each of the stages. In other words the stage likelihood is the sum of all stage qualifying values applicable to a hypothetical stage. Third the virtual machine may select a stage corresponding to a highest stage likelihood among a plurality of stage likelihoods as the current stage. In other words the virtual machine having obtained a stage likelihood for all hypothetical stages for example startup idle ramp up steady and deep steady may select the stage having the highest stage likelihood. Further actions can be taken to optimize the virtual machine s performance for the selected stage or alternatively cost reducing the operation of the virtual machine if the stage suggests that some real time performance is better sacrificed in order to avoid costs.

Next the virtual machine may determine whether the current stage is changed step . If the virtual machine determines that there is no change to the current stage the virtual machine may return to sampling the virtual machine metrics on a frequency in step . However a positive result at step may result in the virtual machine expanding each range corresponding to the current stage step . As such future comparisons to a factor stage range may be more likely to be met for the current range. This feature can provide a degree of hysteresis and prevent unwanted frequent switching between stages.

Hysteresis can be further enhanced. Next the virtual machine may reset each factor stage range corresponding to the former stage with respect to the virtual machine step . Resetting involves placing each factor stage range applicable to the former stage to values or criteria existing prior to performing step . Accordingly the virtual machine metrics may become more remote from the edge cases of each factor stage range. The combined effect of steps and may cause the virtual machine metrics to be further embedded within factor stage ranges of the current stage while the former factor stage ranges recede from the currently measured virtual machine metrics. The expansion of the factor stage range can be to an upper limit a lower limit or to both provided multiple limits exist in the factor stage range. In addition where there is no upper limit or no range is applicable to the factor stage range that specific factor stage range is not expanded.

The arrival rate for the first time compilations is a number of first time compilations received by the JIT compiler from the previous sampling period divided by the period of sampling. Similarly the arrival rate of recompilation requests is the number of such recompilation requests divided by the period of sampling.

A class loading rate can be obtained from class loader . The number of classes loaded during the period is divided by the period to obtain this rate. When determining if the factor stage range corresponding to class loading rate and idle stage is satisfied the virtual machine may determine whether any classes were loaded during the period. Accordingly a single test is performed rather than determining if the virtual machine metric falls between two values.

Samples in compiled code is the number of profiling samples since the last inspection that the internal JVM profiler mechanism attributes to methods that are already jit compiled.

Samples in interpreted code is the number of profiling samples since the last inspection that the internal JVM profiler mechanism attributes to methods that are still running as interpreted.

The number of active threads is the number of application threads created by the virtual machine that are actively performing some useful tasks and contributing to the application s progress. In contrast non active threads are just waiting for work without consuming CPU cycles. Similarly the CPU utilization of executing process is the percentage of CPU cycles among the CPUs or cores in the data processing system that are allocated to the virtual machine.

The virtual machine metric duration in steady stage is the number of minutes that the virtual machine has persistently been in the steady stage or deep steady stage.

Accordingly stage qualifying values can be determined. For example the stage qualifying value of 1 for meeting criteria of the factor stage range corresponding to number of pending JIT compilation requests and startup stage is 1 since the virtual machine metric satisfies the range 0 2000 of . In addition the table provides a sum of the stage qualifying values for each hypothetical stage as a set of stage likelihoods . For the virtual machine metrics corresponding stage likelihoods have a highest stage likelihood corresponding to the ramp up stage. Accordingly the virtual machine may select ramp up as the current stage.

Various responses are possible once a current stage is selected. For example the virtual machine may reduce the frequency of its background housekeeping activity in response to selecting the idle stage. The reduction in frequency is in comparison to the housekeeping activity occurring in non idle stages. This response can save a customer or other owner of the virtual machine from having to pay for CPU cycles during idle periods. Moreover this may allow the operating system to remove the image of the virtual machine from volatile memory and replace it with other active applications.

A response to determining the virtual machine to be in startup stage may include inhibiting profiling of a Java virtual machine JVM . Another response could be to postpone the jit compilation or to lower the optimization effort during just in time compilations in order to provide a better startup experience to the customer or reduce the downtime after a scheduled event like a software upgrade or an unforeseen event like a hardware or software malfunction.

Yet another example of responsive optimization can include a response to the following situation. Initially the virtual machine may be in the startup stage as selected by for example the steps of flowchart . In such a startup stage the virtual machine should refrain from allocating a relatively large amount of memory. The virtual machine may further sample apply values or set of stage likelihoods to each range satisfied by virtual machine metrics sum such values in a manner to select the current stage to be the steady stage. In response to such a transition the virtual machine may choose the use internal algorithms that favor execution speed over memory footprint.

Still another responsive optimization can include a response to determining steady stage or deep steady stage. As an initial step to reaching deep steady stage the virtual machine may determine if continuous execution in the steady stage has reached a predetermined time. Accordingly in response to determining that the predetermined time condition is met the virtual machine may inhibit just in time JIT compilation or method profiling. Method profiling is the activity of collecting information about the behavior of a method at runtime. Examples of information collected include which paths inside the method are more frequently executed which targets are more likely referenced by an interface call etc.

Accordingly by the methods and apparatus disclosed above a data processing system hosting one or more virtual machines can characterize each virtual machine to a specific stage. Once a stage is known additional optimizations may be performed consistent with a client s preferences or alternatively the preferences of an owner or operator of the data processing system. Thus the optimizations may be adjusted dynamically to suit the varying goals that may be assigned to each stage during a virtual machine s life cycle.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

