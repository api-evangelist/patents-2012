---

title: Performant runtime pause with no CPU utilization
abstract: Some computing devices have limited resources such as, for example, battery power. When a user ceases to interact with an application, execution of the application can be moved to background and the application can be paused. During the time period in which the application is paused, the application consumes no CPU cycles because executing managed threads of the paused application are stopped, and native threads are prevented from running using asynchronous procedure calls.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09286115&OS=09286115&RS=09286115
owner: Microsoft Technology Licensing, LLC
number: 09286115
owner_city: Redmond
owner_country: US
publication_date: 20120621
---
When a user executes applications on a desktop computer multiple applications can typically execute simultaneously without adversely affecting performance. In a device that has limited resources multiple applications running at the same time can quickly deplete resources such as battery power. Often output from multiple applications cannot be displayed simultaneously because of a small display area. Consequently on these types of devices sometimes a first application is paused ended or is run in the background when the user switches to a second application. However if the user switches back to the first application prompt resumption of the first application is often expected.

A paused application utilizes minimal resources but when the application is resumed it becomes responsive quickly because the application is still loaded in memory. It resumes at the point at which it was paused because application state at the time of pausing is saved. In response to lack of user interaction an application may be transferred from foreground. to background and paused. When an application is paused the application code stops executing and the application consumes no zero CPU central processing unit cycles. When the application is paused functions such as sleep and wait do not timeout and cause a context switch that changes the CPU from a low power state to a high power state. When the application is not paused there is no overhead caused by the 0 CPU usage pause feature. That is no additional resources are consumed if the application is never paused. When the paused application is resumed it starts up quickly in foreground at the point at which it was paused.

After a pause is signaled the application state can be saved to a permanent store e.g. in isolated storage . After the paused state is reached no managed code for the application executes either in foreground or in background. All executing managed threads of the application are stopped essentially simultaneously. All threads belonging to the application that are in a wait or sleep state are prevented from starting up again.

The program execution manager does not have to selectively pause threads or differentiate between types of threads e.g. foreground and background threads . It does not have to be aware of and implement execution policies associated with the threads. Deadlocks caused by for example a foreground thread waiting for a lock acquired by the paused background thread are avoided. Each code module does not have to audit code and handle every wait or sleep function on a case by case basis.

None of the waits or handles employed by the user code pay any additional cost to pause and resume an application. That is there is no additional overhead to support an application pause. If an application is never paused no cost in terms of CPU usage or other resources is accrued. No CPU cycles are consumed by a paused application because operating system level asynchronous procedure calls are used so that waits and sleep functions in the application threads do not activate until the application is resumed e.g. a user switches back to the application that was paused .

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Some known solutions for handling the running of multiple applications on limited resource devices provide 0 CPU usage when an application is paused but consume additional resources to implement the feature. For example one way to deliver 0 CPU usage when an application is paused is to create a global flag to indicate that the runtime is requesting a pause. If the flag is set the code branches to a central function that handles the pause operation and later handles the resume operation . Operating system primitives can be used to support calls to wait functions including but not limited to sleep functions functions that wait on a handle timeouts and timers with specified durations. However the actual wait is not under the control of the runtime. For example suppose an application calls a sleep function and requests a sleep for 7 seconds. The program execution manager can forward that call to an application programming interface. Suppose after 4 seconds the application is paused causing all the managed threads to be paused. After another 3 seconds the OS sleep function expires and the associated thread returns utilizing the CPU and causing a CPU usage spike until the native code to managed code transition is blocked by the program execution manager.

To avoid a CPU spike a global pausing event can be created at device startup. A timeout implemented by calling a sleep function can be replaced by a timeout that is implemented by waiting for a pausing event handle. When a pausing event is signaled all the waits can be ended and can be made to wait on a resume event which is only signaled at a resuming stage. A consequence of this approach is that all waits have the overhead described above. This can use extra resources all the time even though the pause and resume condition is typically relatively rare.

In accordance with aspects of the subject matter described herein when a pausing operation is commenced a global resume event that acts on all the threads of the paused application can be created in an unsignaled state. During pausing the program execution manager stops all executing managed threads i.e. threads of the paused application which are not in a wait state . In accordance with some aspects of the subject matter described herein the executing managed threads can be stopped at safe points by using redirection or hijacking. Garbage collection information can be used to find safe points in the managed code to stop execution. The program execution manager can suspend threads and determine which instruction is executing. If the current execution instruction is at a safe point the thread can remain suspended. If the thread is not currently at a safe point then the thread can be hijacked by overwriting the return address of the thread so that when the method completes a definite safe point instead of returning to the caller the method calls into a holding function.

In accordance with some aspects of the subject matter disclosed herein all of managed timers can be supported by a single multiplexed central native OS timer. The pause can be implemented by releasing or stopping the central timer ensuring that after the pausing of the application none of the managed timers that rely on the central timer fire. When the application is resumed the central timer can be re created. Whenever a wait or sleep function is requested by a thread of an unpaused application running in foreground a flag can be set in that thread s state indicating that the application is in a wait or sleep state placing the thread in an alertable state. When the application is paused the program execution manager can iterate through all the currently stopped threads looking for the flag. For all threads for which the flag is set an asynchronous procedure call e.g. PauseAPC or the like can be queued to the waiting thread. In response the operating system wakes the waiting thread and makes the thread call into the queued APC function. The APC function can be blocked until the application is resumed.

When the application is resumed e.g. triggered by a user switching back to the paused application a global resume event can be set to a signaled state causing managed threads of the paused application to be restalled. Consequently waiting threads return to waiting for their associated handles. Timer timeouts can be adjusted. A central timer object can be created so that the managed timers are able to fire. Results of the above approach can include the following 

If an application is not paused during a given wait or sleep no additional resources CPU cycles or handles are ever utilized.

There is no change in application semantics. For example a sleep function remains a sleep function it is not converted into a wait function. Similarly wait functions are not converted into different types of wait functions.

Using this approach a function that returns when all the associated handles have been signaled e.g. WaitAll is natively supported.

System can include a computer or computing device such as computing device . Computing device can be any computer or computing device including a mobile device a mobile communication device a smartphone a tablet a desktop computer a game box or any other kind of computing device. Computing device may have limited resources such as but not limited to limited battery power small form factor and or small screen size. Computing device can include one or more processors such as processor etc. a memory such as memory a program execution manager such as program execution manager e.g. Common Language Runtime or CLR or other virtual machine environment and an operating system that supports asynchronous procedure calls such as operating system .

A foreground process such as foreground process running a first application such as application can be running on computing device . A background process such as background process can be running on computing device . One or more threads not shown can be running in the foreground process . One or more threads such as thread thread etc can be running in the background process . Thread thread etc. can be executing or can be in a wait or sleep state. User input can initiate an application such as application . Application and application can be the same application. In response to a lack of user interaction with the application execution of an application such as application or application can be transferred from the foreground to the background. Examples of when an application running in foreground is sent to the background include but are not limited to when the device is not being used and locks when a user explicitly launches a second application using the device s hardware button or user interface controls when a notification is received by the device e.g. receiving a call or when a file is uploaded and so on.

During the time period that extends before a point in time at which user interaction with the foreground process stops and a point in time at which the application is paused managed code can execute e.g. threads of the application can run . During the time period that extends between the point at which an application is paused in response to execution of a pausing handler pausing and the point at which the background threads are frozen freeze the program execution manager may guarantee that actions that are waiting for timers to expire are not performed. During the time period between when a pausing handler is executed and the application is frozen each time a handle times out it checks to see the state of a flag that indicates that the application is paused and if the flag is set the application stays paused until a resume event is signaled. The resume event can be implemented using a wait function that waits for a single handle and has an infinite timeout duration. Thus any timeout that occurs after the pause stage and before the resuming stage does not return to user code.

During the time period that extends between the point at which the threads are frozen freeze and a point at which a thaw occurs no CPU utilization occurs. All managed execution is stopped. Currently running managed threads can be brought to a safe point and stopped. All native code that tries to return to managed code can be blocked. However wait functions and sleep functions called by the application can timeout during this time period. Once the native handle times out and tries to return to the managed code that started the function the function can be blocked so that until the application is resumed user code is not executed.

The stages of a resume application operation can include thaw resuming and resumed . At thaw managed code can start executing and all background threads that were not blocked start to execute again. All threads that called wait functions that timed out in between a pausing event and freeze can continue to be blocked. All timeouts that would have occurred after freeze have been brought to a wait state using the queued APC function e.g. PauseAPC or the like and are blocked. When the resume event is signaled or set in resuming these waits can be restarted with their remaining times adjusted to account for the Pause duration. The domain specific application specific native timer that drives all the managed timers can be re started.

Native handles corresponding to the manage code handles can timeout during the time period if native events are not explicitly stopped. This context switch uses CPU cycles although the utilization can be low if the code is immediately blocked. Using Asynchronous Procedure Calls APCs prevents this CPU usage. An asynchronous procedure call APC is a function that executes asynchronously in the context of a particular thread. When APC is queued to a thread the operating system issues a software interrupt. The next time the thread is scheduled the thread will run the APC function. An APC generated by the system is called a kernel mode APC. An APC generated by an application is called a user mode PC. A thread has to be in an alertable state to run a user mode APC.

Each thread has its own APC queue. An application queues an APC to a thread by calling an APC queueing function. The calling thread specifies the address of an APC function in the call. The queuing of an APC is a request for the thread to call the APC function. When a user mode APC is queued the thread to which it is queued is not directed to call the APC function unless the thread is in an alertable state. If the wait is satisfied before the APC is queued the thread is no longer in an alertable wait state so the APC function will not be executed. However the APC is still queued so the APC function will be executed when the thread calls another alertable wait function. It will be appreciated that different operating systems such as Linux Android etc. may employ mechanisms similar to the APC function described herein. It will be appreciated that use of any function analogous to the APC function described herein is contemplated.

As the program execution manager loops through managed threads to pause the threads the program execution manager also can check to see if the thread is alertable. If so the program execution manager can queue an APC to the thread. The thread can come out of its wait state and can start executing the APC function in the context of that thread. The APC function blocks on the global resuming event . That is handles do not fire during freeze and all threads waiting on handles and sleep functions do not activate until the resuming stage when the resuming event is signaled.

In accordance with some aspects of the subject matter disclosed herein all the managed timers can use a single central native timer to drive the timers. When the application is paused the central timer object can be deleted so that waiting threads cannot start to run again. The single central native timer can be re created in resumed thus using no CPU cycles during the period of time in which the application is paused. When the single central native timer is re created threads in a wait state that come out of the wait i.e. the wait finishes can start to run again.

At a global flag can be set to indicate that the application has been paused. This flag is used later to ensure that no waiting threads start to run. At all executing managed threads of the paused application can be stopped at a safe place essentially simultaneously. Threads that are in a wait state can be prevented from starting to run again at . Native code that attempts to return to managed code is blocked. The time at which the pause occurred can be recorded so that timers can be recalculated after the application resumes. All the threads are iterated through. For each thread that is in a wait state indicated by the having the alertable wait state flag set an APC call is queued to the thread. The OS wakes up the thread and executes the APC call which is blocked until a resume event occurs.

At in response to resuming the application all the managed threads can be restarted. At timers can be made operational again e.g. by creating a new central native timer . At timers can be restarted enabling native threads to resume execution.

In order to provide context for various aspects of the subject matter disclosed herein and the following discussion are intended to provide a brief general description of a suitable computing environment in which various embodiments of the subject matter disclosed herein may be implemented. While the subject matter disclosed herein is described in the general context of computer executable instructions such as program modules executed by one or more computers or other computing devices those skilled in the art will recognize that portions of the subject matter disclosed herein can also be implemented in combination with other program modules and or a combination of hardware and software. Generally program modules include routines programs objects physical artifacts data structures etc. that perform particular tasks or implement particular data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. The computing environment is only one example of a suitable operating environment and is not intended to limit the scope of use or functionality of the subject matter disclosed herein.

With reference to a computing device in the form of a computer is described. Computer may include at least one processing unit a system memory and a system bus . The at least one processing unit can execute instructions that are stored in a memory such as but not limited to system memory . The processing unit can be any of various available processors. For example the processing unit can be a graphics processing unit GPU . The instructions can be instructions for implementing functionality carried out by one or more components or modules discussed above or instructions for implementing one or more of the methods described above. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit . The computer may be used in a system that supports rendering graphics on a display screen. another example at least a portion of the computing device can be used in a system that comprises a graphical processing unit. The system memory may include volatile memory and nonvolatile memory . Nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM or flash memory Volatile memory may include random access memory RAM which may act as external cache memory. The system bus couples system physical artifacts including the system memory to the processing unit . The system bus can be any of several types including a memory bus memory controller peripheral bus external bus or local bus and may use any variety of available bus architectures. Computer may include a data store accessible by the processing unit by way of the system bus . The data store may include executable instructions 3D models materials textures and so on for graphics rendering.

Computer typically includes a variety of computer readable media such as volatile and nonvolatile media removable and non removable media. Computer readable media may be implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer readable media include computer readable storage media also referred to as computer storage media and communications media. Computer storage media includes physical tangible media such as but not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices that can store the desired data and which can be accessed by computer . Communications media include transitory media such as but not limited to communications signals modulated carrier waves or any other transitory media which can be used to communicate the desired information and which can be accessed by computer .

It will be appreciated that describes software that can act as an intermediary between users and computer resources. This software may include an operating system which can be stored on disk storage and which can allocate resources of the computer . Disk storage may be a hard disk drive connected to the system bus through a non removable memory interface such as interface . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It will be appreciated that computers can be implemented with various operating systems or combinations of operating systems.

A user can enter commands or information into the computer through an input device s . Input device s include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone voice recognition and gesture recognition systems and the like. These and other input devices connect to the processing unit through the system bus via interface port s . An interface port s may represent a serial port parallel port universal serial bus USB and the like. Output devices s may use the same type of ports as do the input devices. Output adapter s is provided to illustrate that there are some output device s like monitors speakers and printers that require particular adapters. Output adapter s include but are not limited to video and sound cards that provide a connection between the output device s and the system bus . Other devices and or systems or devices such as remote computer s may provide both input and output capabilities.

Computer can operate in a networked environment using logical connections to one or more remote computers such as a remote computer s . The remote computer s can be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . Remote computer s can be logically connected via communication connection s . Network interface encompasses communication networks such as local area networks LANs and wide area networks WANs but may also include other networks. Communication connection s refers to the hardware software employed to connect the network interface to the bus . Communication connection s may be internal to or external to computer and include internal and external technologies such as modems telephone cable DSL and wireless and ISDN adapters Ethernet cards and so on.

It will be appreciated that the network connections shown are examples only and other means of establishing a communications link between the computers may be used. One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard the subject matter disclosed herein may pertain to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. Aspects of the subject matter disclosed herein may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. Aspects of the subject matter disclosed herein may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

A user can create and or edit the source code component according to known software programming techniques and the specific logical and syntactical rules associated with a particular source language via a user interface and a source code editor in the IDE . Thereafter the source code component can be compiled via a source compiler whereby an intermediate language representation of the program may be created such as assembly . The assembly may comprise the intermediate language component and metadata . Application designs may be able to be validated before deployment.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus described herein or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing aspects of the subject matter disclosed herein. As used herein the term machine readable storage medium shall be taken to exclude any mechanism that provides i.e. stores and or transmits any form of propagated signals. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects e.g. through the use of a data processing API or the like may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

