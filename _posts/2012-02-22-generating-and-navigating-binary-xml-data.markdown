---

title: Generating and navigating binary XML data
abstract: According to exemplary embodiments, a method and system for generating binary Extensible Markup Language (XML) data is provided. The generating includes acquiring an XML data source and generating a first child distance (FCD) token and a next sibling distance (NSD) token of an element node in the XML data source. The generating also includes generating binary XML data of the XML data source by using the FCD token and the NSD token, where the binary XML data includes the FCD token and the NSD token.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08838642&OS=08838642&RS=08838642
owner: International Business Machines Corporation
number: 08838642
owner_city: Armonk
owner_country: US
publication_date: 20120222
---
This application claims priority to Chinese Patent Application No. 201110045815.8 filed 25 Feb. 2011 and all the benefits accruing therefrom under 35 U.S.C. 119 the contents of which in its entirety are herein incorporated by reference.

The present invention relates to the Extensible Markup Language XML data processing technical field and more specifically to a technique for improving generation and query of binary XML data.

XML is a data description language with a powerful data describing capability and a self description feature so that an XML data source is readable by both humans and machines. The features of XML techniques and standardization of related techniques make XML widely used in fields such as web or internet applications. XML is a general format for data exchange between different systems and automated systems with XML as an interface. However XML techniques may be very complex causing a considerable workload to be introduced to the system by processing XML. Further network overhead between the systems is also increased by the redundancy of XML data. When XML is used as a data transmission format XML compression techniques may be viable options for reducing data redundancy in order to improve bandwidth utilization but may further increase the operating load of a local machine. An alternative in a resource limited computing system is to use binary XML.

Binary XML is a compact binary expression form of XML data and thus notably reduces redundancy of the XML data such that parsing of XML data becomes easier the operating load of system for processing XML data is alleviated and bandwidth occupied by XML data transmission is reduced. Binary XML was initially proposed and used in the wireless application field and may have different specifications such as WBXML wireless application protocol binary XML Fast Infoset X.891 and EXI Efficient XML Interchange . Along with its use in systems with limited resources many systems requiring high performance e.g. databases also use binary XML to transmit the XML data and to perform XML data processing.

Although binary XML may reduce redundancy of the XML data its use may result in an increase in processing time. When processing a query request for binary XML to navigate to a node or an element therein each of the nodes including element nodes and non element nodes in the binary XML data source needs to be traversed one by one. This may greatly reduce the efficiency of navigating to the node and may prolong the time for a corresponding query request when the XML data source has a large number of nodes and a complex tree relation.

According to exemplary embodiments a method and system for generating binary Extensible Markup Language XML data is provided. The generating includes acquiring an XML data source and generating a first child distance FCD token and a next sibling distance NSD token of an element node in the XML data source. The generating also includes generating binary XML data of the XML data source by using the FCD token and the NSD token. The binary XML data includes the FCD token and the NSD token.

According to other exemplary embodiments a method and system for navigating to a node in binary XML data that includes a token and a NSD token is provided. The navigating includes receiving a request to query a node in the binary XML data and acquiring a query path of the request. The navigating also includes navigating to the node using the query path the FCD token and the NSD token.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

Embodiments of the present invention are directed to methods and systems for generating binary Extensible Markup Language XML data and for navigating to nodes in the generated binary XML data.

The method shown in starts at block . At block an XML data source is acquired. Here the acquired XML data source refers to an XML data source that has not been subjected to a compaction process and exists in a tree structure. The XML data source can be information existing in any form and expressing XML semantics including but not limited to an XML document an XML information stream a simple application programming interface for XML SAX event stream and a hierarchical or tree storage structure.

The tree structure is an important feature of the XML data resource and it means that the XML data source represents hierarchical relationships between multiple element nodes having a hierarchy structure where the top element node is called a root node and the bottom element node is called a leaf node . A root node has no parent node and no sibling node but may have child node . A leaf node has no child node but may have parent node or sibling node . A relationship between a node and its parent node or child node is similar to a relationship between a superior and its subordinate and a node and its sibling node are at the same level. It should be noted that an element node differs from a node in meaning. Node as used herein may include various nodes such as an element node a text node and an attribute node whereas an element node specially refers to a node composed of elements in an XML data source. In addition the terms root node parent node child node sibling node or leaf node are used herein are short for root element node parent element node child element node sibling element node and leaf element node respectively.

Next the method of advances to block . At block with respect to an element node in the XML data source a FCD first child distance token and a NSD next sibling distance token of the element node are generated. According to an embodiment of the present invention the FCD token of the element node represents a distance from an end point of the FCD token to a start point of the first child node of the element node. If the element node is a leaf node the FCD token is zero and the NSD token of the element node represents a distance from an end point of the NSD token to a start point of a next sibling node of the element node. Such definitions are based on the fact that XML is essentially an expression of a tree relation so element b can be nested in element a and element b certainly has ended when element a ends that is an end navigation of element a outer element or parent element is certainly behind an end navigation of element b inner element or child element . According to another embodiment of the present invention if the element has no sibling node the NSD token of the element node represents a distance from the end point of the NSD token to the end point of the parent node of the element node. In this case if the element node has neither a next sibling node nor a parent node the NSD token of the element node is zero. It should be noted that many ways can be adopted to define the FCD and NSD tokens for example the NSD of an element node is zero if the element node has no next sibling node. For example the value of the FCD token may be an offset with respect to start navigation of the first child node of the node and FCD is zero if the node is a leaf node. The value of the NSD token may be an offset with respect to start navigation of the next sibling node of the node and NSD is zero if the node has no next sibling node. Generally the FCD and NSD can be defined in any way as long as information of a distance between a node and its first child node or between a node and its next sibling node can be obtained directly or calculated indirectly which all fall into the protection scopes of the present invention. As for a specific process of calculating the FCD and NSD it may be different according to the different binary XML format to be generated as will be described in detail below in combination with .

Next at block binary XML data of the XML data source are generated by using the FCD token and the NSD token the binary XML data including the FCD token and the NSD token. A same source XML data source can generate different binary XML data sources based on different formats of binary XML data sources to be generated. However no matter what format or standard of binary XML is used no FCD token or NSD token are included in the binary XML data source generated. At block the FCD and NSD tokens are added to the nodes in the binary XML in the process of converting source XML to binary XML. Therefore the binary XML generated by the method shown in includes the FCD token and the NSD token. According to an embodiment of the present invention the FCD token and the NSD token of each node in the binary XML are included behind the node and the arranging order of the FCD token and the NSD token of each node can be arbitrary. According to an embodiment of the present invention the FCD token and the NSD token have a fixed length for each element node in the binary XML that is to say no matter what value the FCD and the NSD have for each element node these two tokens both occupy certain character length. According to another embodiment of the present invention the FCD token and the NSD token are length variable that is to say specific values of the FCD token and the NSD token will affect byte length occupied by the FCD token and the NSD token of an element node. Because the FCD and NSD tokens are included in binary XML a number of nodes can be skipped over by using the included FCD token and NSD token when querying or navigating to node in the binary XML without the need of scanning the nodes in the binary XML one by one thereby improving the efficiency of navigating to the node. A specific example in which the FCD token and the NSD token are included will be described in detail below. It should be further emphasized that in the above illustrative definitions of FCD and NSD an end point in a FCD token of the node represents a distance from an end point of the node to a start point of its first child node and is no longer simply an original end navigation of the node in the case that the FCD token and the NSD token are added and the byte length occupied by the FCD and NSD tokens must be taken into account. The end point may be understood as current navigation and in the case that the FCD token and the NSD token are added the current navigation takes the byte length occupied by the two tokens into account. Likewise an end point in a NSD token of the node represents a distance from the end point of the node to a start point of its next sibling node. Specific meanings of the distances represented by the FCD and NSD will be presented in more detail below.

At block FCD and NSD tokens whose initial values are zero are added behind each element node of the XML data source. At block in the process of processing the nodes of the XML data source sequentially for the value of FCD of a non leaf node when a first child node of the non leaf node is encountered a distance from an end point of the non leaf node to a start point of the first child node is calculated thereby obtaining the value of FCD and updating the initial value of the FCD token. At block in the process of processing the nodes of the XML data source sequentially for the value of NSD of a non root node when a next sibling node of the non root node is encountered a distance from an end point of the non root node to a start point of the sibling node is calculated thereby obtaining the value of NSD of the non root node and updating the initial value of the NSD token. If the NSD is defined as follows when an element node has no next sibling node the NSD is a distance from the element node to an end point of its parent node then when the end point of the parent node of the non root node is encountered a distance from the end point of the non root node to the end point of the parent node can be calculated as well thereby obtaining the value of NSD of the non root node and updating the initial value of the NSD token. Those of ordinary skill in the art should appreciate that the specific method for calculating the FCD and NSD may be related to the specific assignment rule for the FCD and NSD in special cases for example a node does not have a next sibling node does not have a child node or does not have a parent node however regardless of what assignment rule for the FCD and NSD is in special cases is basic meanings of the FCD and NSD tokens are consistent the FCD token represents a distance from an end point of the node to a start point of its first child node and the NSD token represents a distance from the end point of the node to a start point of its next sibling node. Moreover those of ordinary skill in the art could extend the algorithm to different definitions of the FCD and NSD on the basis of the principle and spirit of the algorithm described above.

The above has described a summarized algorithm for generating FCD and NSD tokens and a more detailed operating flow namely a more detailed FCD NSD calculating step includes the following a initializing an auxiliary global data structure b checking an auxiliary data status at the start of processing each element node startElement and if FCD of its parent node is needed and can be got through calculation then calculating FCD of the parent element according to a corresponding formula and updating FCD value of the parent element c generating binary XML contents of the element node being currently processed and updating auxiliary data information and d checking an auxiliary data status at the end of processing each element node endElement and if NSD of the current element is needed and can be got through calculation then calculating NSD of the current element according to a corresponding formula and updating NSD value of the current element and generating subsequent XML contents.

Next a process which is microcosmically operable to generate FCD and NSD tokens includes the following steps based on the above described method for generating FCD and NSD tokens a initializing a stack storing integer values and recording a start storage navigation m nsd of NSD value of each element b checking the stack at the start of each element node startElement and if the stack is not empty and FCD of the parent node is zero then reading the top value m nsd of the stack and calculating FCD of the parent node according to the formula FCD cursor m nsd 2 where cursor is the current cursor at which the generated binary XML is stored and updating FCD value of the parent node stored at the navigation m nsd 5 c popping the top value of the stack if the parent node is a root node d generating binary XML contents of the current node adding a FCD NSD label whose initial value is zero behind an element node label unit and putting the start navigation m nsd of NSD value of the present element node to the top of the stack e checking the stack at the end of each element node endElement and if the stack is not empty then popping the top value m nsd of the stack and calculating NSD of the present element node according to the formula NSD cursor  nsd 2 and updating NSD value stored at the navigation  nsd and generating subsequent binary XML contents.

It may be determined from the above detailed process of generating FCD and NSD tokens that the definitions for FCD and NSD on which the above calculating method is based are as follows FCD represents a distance from the current navigation to the first child node of the present element node and if the present element node is a leaf node i.e. without child node FCD is zero NSD represents a distance from the current navigation to the next sibling node of the present element node and if there has no next sibling node NSD represents a distance from the current navigation to the end navigation of the parent node and if there has neither a next sibling node nor a parent node NSD is zero. Those of ordinary skill in the art could extend the algorithm to all definitions of FCD and NSD after understanding the principle of the stack algorithm described above and only need to change the specific formula according to the specific definition.

At block a query path Xpath of the query request is acquired. Xpath uses a path expression to select a node or a set of nodes in an XML document. Since the XML data source has a tree structure the query path also has a tree structure. Take the following XML data source as an example 

The above XML data source includes three elements dep root node proj leaf node and emp leaf node where node dep has two child nodes proj and emp proj and emp are sibling nodes to each other but only emp is a next sibling node of proj on the basis of sequencing in the XML document. The binary XML data based on an improved IBM binary XML format i.e. including FCD and NSD tokens of the XML data source is as follows X3dep1v0018 0000Y3mgr25peterX4proj3v0000 0007T3WebzX3emp4v0000 0008T4JohnzzZ

The underlined parts are FCD and NSD tokens of each node in particular v0018 is an embodiment of the FCD token where symbol v labels FCD and the value following symbol v is an exact value of the FCD token similarly symbol labels NSD and the value following symbol is an exact value of the NSD token. Specific processes of generating the binary XML data source including the FCD and NSD tokens have been described in detail in and and corresponding descriptions thereof. The way of generating other parts of the binary XML data source other than the FCD and NSD tokens may be implemented by referring to currently published multiple format specifications of binary XML data source.

It can be seen that the binary XML data source after being subjected to a compaction process still retains the tree structure of the source XML. The specific method for generating binary XML from the source XML can be described by referring to format definitions of related binary XML standards. The examples of binary XML listed here are not the binary XML to which the FCD and NSD tokens are added according to the present invention but belong to the binary XML generated according to existing format definitions of binary XML.

In this XML data source and are all element nodes also called elements wherein is a root node and has two child nodes and and are sibling nodes to each other. If the value of node is queried now the query path expression is dep emp .

Next at block the queried node is navigated to by using the query path and the FCD and NSD tokens. If the node query is performed with respect to a binary XML data source excluding FCD and NSD tokens each node including element nodes e.g. dep starting with X attribute nodes e.g. mgr starting with Y and text nodes e.g. Web starting with T has to be scanned one by one until the element node exp to be queried is finally scanned. However now if the binary XML data source includes FCD and NSD tokens of each node then some of the nodes can be skipped over by using the FCD and NSD tokens to directly navigate to the element node exp. and are schematic diagrams respectively showing node query based on binary XML excluding FCD and NSD tokens and node query based on binary XML including FCD and NSD tokens. As shown in the cursor needs skipping six times before navigating to the element node emp to be queried. While as shown in the cursor only needs skipping three times before navigating to the element node emp to be queried since the attribute nodes mgr the element node proj and the text node peter are directly skipped over the efficiency of navigating to the node in the binary XML data source is improved greatly.

Further assume that the query request SQL or XQuery submitted by the user is to query contents of element node emp then the query path Xpath is dep emp the concrete SQL statement or XQuery statement is omitted here .

At block a first node namely the root node of the binary XML data is navigated to. Since binary XML is similar to XML data source it also has a sequential tree structure so a sequential scanning starting from the root node is made when querying the node in the binary XML data.

At block it is judged whether the name of the first node root node of the binary XML data navigated to is consistent with that of the first element in the query path. If yes the flow advances to block and if No the flow advances to block . Reasons for inconsistency include wrong inputs of the query request. At block the flow ends because no match is found. In the above example the first element in the query path dep emp is dep which is consistent with the name of the first node of the binary XML data so the flow advances to block .

At block the flow skips to the first child node of the first node according to the FCD token of the first node. In the above example FCD and NSD tokens v0018 0000 are included behind the first node dep wherein the FCD token is on the left of and the NSD token is on the right of . In this example the value of the FCD token is 0018 which represents that counting backwards 18 bytes from the last byte 8 of the FCD token one reaches the start of the first child node proj of the node dep. Therefore at block the flow skips backwards 18 bytes according to the FCD token 0018 of the node dep and navigates directly to the start X of the first child node proj of dep. The attribute node mgr is skipped over through this skip.

Next at block it is judged whether the name of the first child node of the first node is consistent with that of the second element in the query path. If Yes the flow advances to block and if No the flow advances to block . In the above example since the name of the second element in the query path dep emp is emp which isn t consistent with the name of the first child node proj of the first node dep to which the flow skips in the block the flow advances to block .

The operation of block will be explained before describing block . At block it is judged whether the query path has been traversed. Being traversed means that the last element in the query path is the node skipped to currently. If the judgment result of block is Yes this shows that the query path has been processed and a matched result has been found and thus the flow ends at block . If the judgment result of block is No this shows that there are still other nodes which have not been processed in the query path therefore the flow returns to block . It should be noted that the flow should skip to the first child node of the current node at block when returning from block to block rather than skipping to a first child node of the first node as recited in the literal description of . For all the other steps of the returning loop to block shown in the flow chart of they are all performed with respect to the node currently skipped to. The description in is only provided for describing operations in the first processing cycle and those of ordinary skill in the art would know this from the literal description of the present paragraph.

At the block the flow skips to the next sibling node of the first child node by using the NSD token of the first child node. In the above example the first child node is proj and its next sibling node is emp. In the above binary XML data the NSD token of the first child node proj is 0007 which represents that counting backwards 7 bytes from the last byte 7 of the NSD token one reaches the start X of the next sibling node emp of the node proj. The text node Web is skipped over through this skip.

Next at block it is judged whether the name of the sibling node skipped to is consistent with that of the second element in the query path just before at the block it is known that the name of the second element in the query path is not consistent with that of the first child node of the root node . According to the above example the name emp of the second element in the query path dep emp is consistent with that of the next sibling node emp of the first child node proj to which the flow skips in the block so the flow advances to block .

At block it is judged whether the query path has been traversed. As described above the last element emp in the query path dep emp is the node currently skipped to so the query path has been traversed and a match is found thus the flow ends at block .

If the judgment result of the block is No the flow returns to block to skip to the next sibling node of the current node namely the next sibling node of the node emp until the judgment result of block is Yes.

If the judgment result of block is No the flow returns to block to skip to the first child node of the current node namely the first child node of the node emp .

It should be further noted that for the sake of brevity some steps are not shown in the flowchart of . For example a step of judging whether the end of the parent node of the current node is reached can be included between the block and the block . If it is specified at the time of defining the meaning of the NSD token that if a node has no next sibling node the NSD token represents a distance from the end point of the node to the end point of its parent node then the sibling node to which the flow skips in block may be in fact the end navigation of its parent node. In this case the flow directly advances to the end block that is to say no match is found. According to the above example the node emp has no next sibling node emp is the next sibling node of proj but proj isn t the next sibling node of emp this is decided on the basis of sequentiality of XML data then a value of the distance from the end point of the node emp to the end point of its parent node dep is assigned to the NSD token i.e. 0008 of node emp. Assuming that the query path is dep abc then at block the flow skips seven bytes to the end point z of the parent node of emp so it can be learned through judgment that the current node is the end point of its parent node thus the flow directly advances to block to end and no match is found. Those of ordinary skill in the art should appreciate that the above judgment about whether the end point of the parent node is reached is related to the definition to the NSD token and usage of a different definition to the NSD token may influence specific steps of navigating to nodes. Further those of ordinary skill in the art could apply the principles and methods revealed in the above examples on the basis of the IBM binary XML standard format to multiple other definitions to the FCD and NSD tokens and to multiple other binary XML formats such as wireless application protocol WAP binary XML WBXML and Microsoft Server Binary XML MS BINXML .

In the above descriptions of the characters z X etc. belong to characters having special meanings specified in the specifications of the IBM binary XML standard format and should not be construed as any limitations to embodiments of the present invention.

It can be seen by comparing the different binary XML data standard formats shown in and that no matter what specific binary XML data format specifications are they all process the element nodes in the XML data source sequentially in order according to the sequentially arranged XML data source with a tree structure thereby converting the XML data source into corresponding binary XML data. Although the resulting binary XML data obtained according to each binary XML standard has a different form the FCD token and the NSD token can be added to the binary XML data while generating the binary XML data by using their common feature of structured data and node skipping can be performed when querying the improved binary XML data by using the FCD and NSD tokens added thereby improving the efficiency of node navigation and query.

It should be emphasized that in the above various standard binary XML examples and binary XML examples including the FCD and NSD tokens shown in the description and accompanying drawings for the convenience of understanding relevant values are represented directly in a form of decimal digits. However in fact the above examples do not necessarily represent original formats of storage of the binary XML data in the computer.

As will be appreciated by one skilled in the art the above system apparatus and method can be implemented by using computer executable instructions and or control codes included in a processor for example such codes are provided on a carrier medium such as disk CD or DVD ROM a programmable memory such as read only memory firmware or a data carrier such as optical or electronic signal carrier. The apparatus server and units thereof according to the embodiments may be implemented by hardware circuits such as a large scale integrated circuit or gate array a semiconductor such as logic chip and transistor or a programmable hardware device such as field programmable gate array and programmable logic device or may be implemented by various kinds of software executed by the processor or may be implemented by a combination of the hardware circuit and software.

In an embodiment unnecessary nodes can be skipped over in the process of navigating to the binary XML data thereby saving time for navigating to node avoiding scanning or reading the unnecessary nodes and improving the efficiency of querying node and navigating to node.

Although the system and method of the present invention for processing the local file by using the remote application have been described in details as above in combination of exemplary embodiments the invention is not limited to the embodiments. Those skilled in the art could make various variations replacements and modifications under the teaching of the specification without departing from the scope and spirit of the invention. It should be appreciated that all these variations replacements and modifications still fall into the protection scopes of the present invention. The protection scopes of the present invention are only defined by the attached claims.

