---

title: Scheduled and quarantined software deployment based on dependency analysis
abstract: A request to deploy a next version of a software component in a cloud environment is received. An analysis of a number of dependencies among software components of the cloud environment is received. Deployment of the next version of the component is scheduled based on the analysis. The next version of the software component is deployed in the cloud environment in accordance with the scheduled deployment. The next version of the software component is quarantined until a predefined criteria is satisfied. In one aspect, the predefined criteria is defined based on error rate of the next version of the software component. In a further aspect, the predefined criteria is defined based on received analysis among the components. Upon satisfying the predefined criteria, the next version of the software component is released from the quarantine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256412&OS=09256412&RS=09256412
owner: SAP SE
number: 09256412
owner_city: Walldorf
owner_country: DE
publication_date: 20120704
---
Quality management procedures for software components are typically due before their deployment. The software components may be tested and validated for example to ensure a standard level of their quality. In a classical on premise computer system environment software components part of that environment and the components to be deployed are assembled and tested altogether. In an on premise environment the software components and the hardware systems used to run these components are typically operated by a single entity or single owner for example a customer of the software provider. Thus when software updates new features security enhancements and so on are offered by the software provider the respective owner or customer has the flexibility to plan and implement unilaterally the deployment process of these updates or features. For example the owner may create a test replica that resembles and corresponds to the on premise computer system environment in which test replica the offered software components are deployed tested and validated. After the components have been successfully tested and validated in the test environment the owner may deploy them to the production system environment which operates with actual business data. Therefore the deployment process is planned managed and organized by a single entity.

Unlike the on premise environment software components in a cloud computing environment are owned developed and operated by various entities or owners. Also it is common that components developed by one entity may be reused by others forming a network of interdependent components. Consequently various components that are interconnected and dependent on each other may be managed by different entities. Furthermore it is common that the number of dependencies among the components grows with significant rate with the number of components available in the cloud environment. Accordingly in a cloud environment it is unfeasible to organize a deployment process as in an on premise environment where new versions of software components are received tested validated and rolled out at once and unilaterally by the respective owner. In the cloud environment components are deployed ad hoc as dictated by the deployment requests of the different entities.

Embodiments of techniques for scheduled and quarantined software deployment based on dependency analysis are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In one embodiment runtime platform may be a Platform as a Service PaaS . As such runtime platform may exhibit typical properties of a cloud infrastructure such as resource pooling where the computing resources of the cloud infrastructure provider are pooled to serve multiple consumers using a multi tenant model. Another characteristic that runtime platform may exhibit is elasticity that refers to the capability of the platform to elastically provision and release computing resources to scale commensurate with demand. Runtime platform may also expose a metering characteristic. Metering may refer to the capability of the cloud infrastructure to automatically control monitor report and optimize resource usage at some level of abstraction appropriate to the type of service. Such level of abstraction may be for example storage processing bandwidth and active user accounts etc. Further capabilities of the runtime platform are available over the network and accessible through standard mechanisms by heterogeneous thin or thick client platforms e.g. mobile phones tablets laptops and workstations . Other capabilities of runtime platform may include Hypertext Transfer Protocol HTTP load balancing clustering Domain Name System DNS as a cloud service etc.

Runtime platform may be developed operated and maintained by a runtime platform provider . There are a number of vendors that provide commercial runtime platforms. Just as an example SAP AG provides SAP NetWeaver Cloud a Java based Platform as a Service offering that makes it possible for partners and customers of SAP AG to deploy and use Java applications in a cloud environment. Examples of other vendors of runtime platforms for applications in a cloud environment include but are not limited to Google Inc. that provides Google App Engine platform Salesforce.com that provides Heroku platform VMware Inc. that provides Cloud Foundry platform Microsoft Corporation that provides Windows Azure platform. In one embodiment runtime platform may include application server as a core part for building runtime environment based on the runtime platform . For example the application server may be a Java application server for executing Java based applications. In another example the application server may be a webserver to provide environment for execution of web based applications. Further runtime platform may also include an operating system and a database.

Customers partners or other consumers of runtime platform may create develop and customize applications or other software components based on runtime platform . As illustrated in applications X of customer 1 applications Y of customer 2 applications Q of customer 3 and applications Z of customer N are built based on runtime platform . In one embodiment runtime platform provider may also create one or more applications built on runtime platform and offer the applications in addition to the runtime platform to customers. For example applications are developed managed and owned by runtime platform provider .

Typically in cloud environment applications or other software components are provided and delivered for deployment and the cloud infrastructure automatically performs the deployment of the applications. Once deployed the applications are available for use and can be consumed. For example applications X applications Y applications Q applications Z and applications of runtime platform provider are deployed and installed on cloud and may be accessed and consumed for example via the Internet.

The availability of various applications in cloud may support software reusability among providers and consumers of the software. Thus in cloud various connections relationships and dependencies may be formed between the applications. For example software components deployed on cloud are dependent on runtime platform that is managed by the runtime platform provider . Also as illustrated in one or more of applications X may depend on or refer to one or more applications such as application 1 and application K . Further one or more of applications Y depend on application 2 and one or more of applications X . Also one or more of applications Z depend on application K . Just as an example application K of runtime platform provider may be a customer relationship management CRM system. Runtime platform provider may install and operate the CRM system in cloud where various customers may procure the CRM system and offer the system to their associated consumers. For example customer 1 and customer N may access and use the CRM system in exchange for a subscription fee such as a monthly fee or an annual fee or other form of billing such as billing based on business transactions or volume of usage. In turn customer 1 may offer and deliver another application that depends on application K for example an application from applications X for credit cards validation. Similarly customer 2 may also offer an application from applications Y that depends on or refers to an application from applications X .

On one hand dependencies relationships and connections may be formed among applications and other software components deployed on cloud . On the other hand the software components are owned developed and operated by various entities or owners e.g. customer 1 customer 2 customer 3 and customer N and runtime platform provider . In case an update or another change of one or more applications is deployed and introduced by one or more owners other software components in cloud may be affected. It is possible that a major change of an application is delivered for example a new release of a CRM system. Such major change may significantly impact components that depend on the updated application. Thus it may be desirable that the deployment of such major change can be planned and organized by the affected parties.

On the other hand it may also be common that the various owners and providers of software components in cloud frequently deliver and release updates bug fixes minor improvements or other changes of the respective software components. In such case an automatic deployment may be desirable for numerous minor improvements that are backward compatible.

It is possible that software deployment requests are received randomly as determined by the numerous entities. Furthermore the number of dependencies among the software components in cloud may grow with significant rate with the number of components available and introduced in cloud . Therefore software deployment process in cloud can be unorganized unplanned and difficult to track. It is also possible that defective components and components that produce correct results are deployed to cloud simultaneously and at the same time. Components in cloud that depend on the defective components may be negatively impacted by affecting their proper working as well. It may be inefficient cumbersome or unfeasible to determine and isolate the source of the errors. In one embodiment an automatic software deployment process is implemented where deployment of software components is scheduled or planned. Further components are kept under quarantine until a predefined criteria is satisfied. For the period of the quarantine components may be monitored and tested.

At an analysis of a number of dependencies among the number of software components of the cloud environment is received. In one embodiment a graph that represents the dependencies among the software components is constructed where one software component references depends on or is otherwise associated with another software component. In one embodiment the dependencies among the software components in the cloud environment may be explicitly declared. Just as an example the dependencies may be explicitly declared through import or export statements. In another embodiment the dependencies may also be determined based on data related to requests or other form of communication between the software components. To illustrate it is typical that software components in the cloud environment communicate by standard means such as HTTP requests and responses that may be inspected monitored and detected by the cloud infrastructure. If component A sends a request to component B this may be evidence that component A depends on component B . The infrastructure to intercept monitor and gather data related to the communication between the software components is typically part of standard cloud infrastructures e.g. for the purposes of security resource metering etc. Based on the gathered communication data dependencies among the software components are analyzed. An example process to construct an analysis of a number of dependencies among a number of software components of a cloud environment is illustrated in relation to .

At deployment of the next version of the software component is scheduled based on the received analysis. In one embodiment deployment requests may be frequently and concurrently sent. Thus numerous deployment requests may be processed at the same time. To schedule the deployment of the next version of the software component it is determined if there are deployment requests that are currently processed. And also it is determined if the request to deploy the next version of the software component may overlap with the currently processed requests. Overlapping deployment requests are such requests where once the respective deployments are completed a common set of components may be affected. Based on the dependency analysis it is determined whether the currently processed deployment requests overlap with the deployment request of the next version. If there are overlapping requests the deployment of the next version of the software component is postponed until such requests are processed. Thus the deployment process is automatically scheduled planned and organized. In one embodiment scheduling and separating the deployment processes of software components may facilitate identification of those software components that may produce errors. For example when comparing the behavior of the software component before and after the next version is deployed it is possible to exclude other deployed and updated components as the sources or originators of the errors. An example process to schedule the deployment of the next version of the software component is illustrated in relation to .

At the next version of the software component is deployed in the cloud environment in accordance with the scheduled deployment. Based on the determined order of deployment in the schedule the next version of the software component is deployed so that it can be invoked accessed used and is generally available in the cloud environment. Once deployed the next version of the software component is quarantined until a predefined criteria is satisfied at . Although the next version of the component is deployed and available to be used and accessed it may be kept in isolation and not fully utilized e.g. for a predefined period of time or until predefined conditions are satisfied. During the period of the quarantine the next version of the software component and the set of components affected by the deployment of the next version may be monitored tested and evaluated.

In one embodiment the current version of the component and the next version of the component may be running and available for use in the cloud environment concurrently for the period of the quarantine. Thus during the quarantine the next version of the software component does not fully replace the current version of the component. For example a portion of requests sent to the software component may be routed through the next version of the software component and another portion of the incoming requests may be routed through the current version of the software component. Thus during the period of the quarantine the behavior of the next version of the component may be compared to the behavior of the current version of the software component. Scheduling and quarantining help to analyze whether the deployment operation of the next version of the software component may be related to errors occurring in the cloud environment.

At the next version of the software component is released from the quarantine upon satisfying the predefined criteria. In one embodiment the next version of the software component replaces the current version of the component if during the quarantine it is determined that the next version works properly and as expected. Thus all incoming requests directed to the software component are routed through and processed by the next version of the component.

There are various criteria that may be defined to automatically release a component from quarantine or alternatively to withdraw and terminate the component from the cloud environment. In one embodiment if the error rate of the next version of the software component is above a predefined threshold the next version may not be released from the quarantine. In such a case the next version may remain inactive may be rolled back or removed from the cloud environment. In another embodiment the error rate of the current version of the software component may be compared with the error rate of the next version of the component. For example if the error of the next version of the software component is no greater than the error rate of the current version of the component then the next version may be released from the quarantine. Alternatively upon determining that the difference between the error rate of the next version of the software component and the error rate of the current version of the software component is above a predefined threshold the next version may not be released from the quarantine. In one embodiment the criteria may be defined based on the received analysis related to the number of dependencies among the number of software components of the cloud environment. In yet another embodiment a component may be manually released from quarantine or may be manually forced and kept under quarantine.

The difference in error rates between the current version and the next version of the software component may be only one of the factors based on which the criteria may be defined. Another factor may be repetition of errors related to a customer or a software component itself. For example if the next version of the software component generates errors related to a single customer or significantly small number of customers then the software component may work properly and the customer may be the source of the failures.

The deployment history related to a software component may be a factor in defining the criteria. For example the number of failed deployment requests related to the same software component the ratio between the error rate of the current version now i.e. during the quarantine and the current version in the past etc. In one embodiment if errors are related to significantly small number of customers then the next version of software component may still be released from the quarantine. The business impact may be another factor that could be used to define the criteria.

In one embodiment another factor in defining the criteria based on which the next version of the software component is released from the quarantine may be related to the type and content of the errors. For example repetition of the same one or more errors expectancy or probability of occurring errors e.g. if produced errors are expected to be generated or not generation of new unseen or distinct type of errors by the deployment of the next version of the software component are generated etc. Such factors may be used to identify and analyze the source of the generated errors.

In one embodiment the analysis of the dependencies between the components of the cloud environment may be represented with a graph structure. At a number of vertices in a graph of dependencies are created corresponding to the number of software components of the cloud environment. For example for component X a vertex X is added to the graph of dependencies and for component Y a vertex Y is added respectively.

At based on the data related to the usage of the cloud environment the requests are categorized into a number of request categories based on types of resources requested by the corresponding requests. For example an HTTP request to http www.sap.netweavercloud.com customers may access resources of type customers hence the request may be identified and categorized as a request of customers category. Similarly request to access http www.sap.netweavercloud.com products may be categorized as a request of category products .

A resource may be data that may be identified referenced and accessed for example by a Uniform Resource Locator URL or Uniform Resource Identifier URI . There are various methods that may be used to categorize requests for example depending on the protocol used for communication between the software components. Examples of protocols that may be used for communication between the software components include but are not limited to Remote Procedure Call RPC protocol Common Object Request Broker Architecture CORBA protocol Remote Method Invocation RMI HTTP Simple Object Access Protocol SOAP . To illustrate a method that may be used to categorize requests for web services based on SOAP various Web Services Description Language WSDL operations may represent different request categories. In one embodiment pattern recognition algorithms may be used to categorize requests e.g. unsupervised machine learning algorithms may be applied to automatically discover the relevant categories. Thus categorization may be based not only on the basis of single requests but also on the basis of group of requests.

In one embodiment a factor in defining the criteria based on which the next version of the software component is released from the quarantine may be related to categories of the requests. If errors are generated in relation to certain categories of the requests this may facilitate the identification of the source of the errors. For example identifying the type of resource that when requested produces errors.

At a number of edges are created in the graph of dependencies that correspond to the number of request categories. In relation to the above mentioned example if component X requests from component Y resources of type customers then a directed edge from X to Y is created corresponding to request category customers . Similarly if component X requests from component Y resources of type products then another directed edge from X to Y is created request category products .

At based on the received usage data a number of weights are calculated. The weights may be calculated based on a frequency of requests in the request categories. For example if requests of category customers are sent once a minute and requests of category products are sent once a month then respective weights may be proportionate to the frequency of requests. At the weights are associated with corresponding edges. Thus for example edges from component X to component Y represent how intensively and frequently component X requests respective resources from component Y e.g. products or customers . In one embodiment the dependencies may be specified and weighted manually for example by providers of the software components.

In one embodiment the graph may be constructed in response to received requests to deploy a software component in the cloud environment. In yet another embodiment the graph may be constructed stored in a memory location and updated periodically for example in accordance with predefined time intervals or depending on the received usage data. The graph may represent an analysis of dependencies between the software components. Based on such analysis the impact of deployment operations that possibly introduce errors in the cloud environment may be forecasted and calculated.

If it is determined that there are deployment requests for other components that are in process a set of software components affected by the deployment of the next version of the software component is determined at . In one embodiment components affected by the deployment of one component are components whose work may change as a result of the deployment of this one component. To illustrate with reference to if a request to deploy a next version of application K is received the set of components affected by the deployment of application K include application K itself one or more of applications X and one or more of applications Z that may directly depend on application K and one or more applications Y that may indirectly depend on application K . Applications Y are indirectly dependent on application K if for example requests sent by applications Y to applications other than application K e.g. applications X in turn generate requests to application K .

At sets of components affected by deployment of the other components whose deployment requests are currently processed are determined. At it is determined if the set of components affected by the deployment of the next version of the component and one or more sets of components affected by the currently processed deployment of the other components overlap. In mathematical terms a first set of components affected by the deployment of a first component overlap with a second set of components affected by the deployment of a second component if the intersection of the first and the second set is not empty. To illustrate with reference to a set of components affected by deployment of a next version of component B includes component B itself and components A and C i.e. set A B C since components A and C depend on component B . On the other hand a set of components affected by deployment of a next version of component D includes component D itself and component C that depends on component D i.e. set C D . The intersection of set A B C and set C D is the set C which is not empty hence the set of components affected by deployment of a next version of component B and the set of components affected by deployment of a next version of component D overlap. In such a case it is desirable that concurrent requests to deploy new versions of components B and D are not processed simultaneously. Otherwise it may be more difficult to distinguish which component that is changed may have produced possible failures or errors. For example if components B and D are simultaneously deployed and if an error occurs in component C it may be more difficult to analyze if the deployment of B or D may have caused the error compared to deploying components B and D one after the other.

If it is determined that the set of components affected by the deployment of the next version of the component and the one or more sets of components affected by the currently processed deployment of the other components does not overlap at the next version of the software component is deployed in the cloud environment.

Alternatively if it is determined that the set of components affected by the deployment of the next version of the component and the one or more sets of components affected by the currently processed deployment of the other components overlap at deployment of the next version of the software component is postponed until the deployment of the another component is processed. Thus the deployment of the next version of the software component may be postponed until overlapping requests are processed. To illustrate with reference to if a deployment of component B is currently processed a request to deploy component D is postponed until component B is deployed and released from the quarantine. Similarly concurrent requests to deploy component A and component B component C and component B and component C and D are processed one after the other since such concurrent requests are with overlapping sets of affected components. Alternatively deployment of component A and component C may be processed at the same time since the set of affected components of component A does not overlap with the set of affected components of component C . Also requests to deploy component A and component D may be processed simultaneously.

In one embodiment two queues may be created in which queues software components are kept in the order of their processing. One may be a scheduler queue that stores or refers to components to be deployed where the components are kept in the order of arrival of the respective deployment request. Another queue may be a quarantine queue that keeps or refers to components under quarantine. To illustrate with reference to if a request to deploy component B is received component B is added to the scheduler queue and components A B and C are added to the quarantine queue since components A B and C constitute the set of components affected by the deployment of component B . If a request to deploy component D is received next component D is next added to the scheduler queue and components C and D are added to the quarantine queue since components C and D constitute the set of components affected by the deployment of component D . In accordance with process the deployment of component D is postponed until component B is deployed and components A B and C are released from the quarantine. At process ends with deploying the next version of the software component in the cloud environment. The deployment is automatically scheduled planned and organized.

At the next version of the software component is deployed on a subset of cluster nodes of the cloud environment. Thus on the subset of cluster nodes a current version of the software component is replaced with the next version of the software component. On the remaining subset of cluster nodes the current version is still running.

At a portion of a number of requests to the software component is processed by the next version of the component. The portion of requests processed by the next version of the component are routed through and directed to the subset of cluster nodes on which the next version is deployed and installed. At a remainder of the number of requests to the software component is processed by the current version of the component.

In one embodiment incoming requests of a subset of users customers or tenants of the software component may be directed to the subset of cluster nodes with the next version of the software component while the rest of the users may be still served by the current version of the software component. For example users whose requests are directed to the next version may be the ones with lowest service level agreement. In case the next version is defective only a limited number of users may be affected. In one embodiment splitting and routing incoming requests may be applied transitionally. To illustrate with reference to if a version of application K is under a quarantine and a user U related to customer 2 is selected to be served by the version of application K that is under quarantine. If user U sends a request R1 to an application from applications X which request R1 in turn results in a request R2 application K under the quarantine. Then as illustrated in since the application from applications X depends on application K R2 may be transitionally directed to and processed by the version of application K that is under quarantine.

At an error rate of the portion of requests processed by the next version of the software component is compared with an error rate of the remainder of requests processed by the current version of the component. At it is determined whether the difference between the error rate of the portion of requests processed by the next version of the software component and the error rate of the remainder of requests processed by the current version of the component exceeds a predefined threshold.

At the next version of the software component may be deactivated if the difference between the error rate of the next version of the component and the error rate of the current version of the component exceeds the predefined threshold. The next version may be rolled back and removed from the cloud. If the difference between the error rate of the next version of the component and the error rate of the current version of the component does not exceed the predefined threshold the current version of the software component is replaced on the cluster nodes with the next version at . The current version of the software component is phased out and the incoming requests are processed by the next version of the software component.

In one embodiment error rate of the set of components affected by the deployment of the next version of the software component before the quarantine of the next version may be compared to the error rate during the quarantine. Thus not only the behavior of the updated software component but also the behavior of the components affected by the update may be observed and analyzed.

Error rates or failures of the software component may be identified using various methods. On example is to identify and detect explicit error responses e.g. HTTP error code 404 or 503. In another embodiment content of responses to requests may be analyzed. Another possible approach to identify failures is based on users feedback. For example issue tracking system may be implemented in the cloud environment where users explicitly report problems complaints errors etc. Thus it is possible to look for issues reported for a software component in the set of components affected by deployment of the software component under quarantine where the reporter is served by the next version of the software component.

Keeping a software component under quarantine for a long period of time may be undesirable because for example other pending deployment requests may also be delayed. Further customers and users may not be able to take advantage from the software component until the component is released from the quarantine. In one embodiment the predefined criteria under which a component is released from or respectively kept under the quarantine may be defined based on the received analysis of the existing dependencies between the software components. For example in one embodiment upon successfully processing requests from the number of identified request categories by the next version of the software component the next version of the software component may be released from the quarantine. Thus if at least one request is processed from the identified request categories by the next version without detecting errors or anomalies then the next version may be released from the quarantine.

In one embodiment the next version of the software component may be released from quarantine upon successfully processing at least one request from each request category that is associated with the software component. In a further embodiment the next version of the software component may be released from the quarantine upon successfully processing a predefined number of requests per request category by the next version. Thus software components that process a higher number of requests may be released faster from the quarantine compared to component that process a lower number of requests. Highly loaded software component may quickly process required number of requests from the required request categories.

In one embodiment request categories that occur rarely for example once a month may be disregarded and excluded from the criteria. For example edges representing such categories may be removed from the graph of dependencies. Thus keeping software components under the quarantine for an undesirable period of time may be avoided.

Quarantining software components affected by deployment of a next version of a software component may facilitate the process of identifying errors that occur in relation to or are caused by the deployed next version. It may be compared if errors occur in the set of affected components before and after the deployment of the next version.

Based on the monitored and received usage data dependency analyzer generates a statistical analysis of a number of dependencies among the software components of the cloud environment. In one embodiment dependency analyzer generates a graph of dependency in accordance with process illustrated in .

In one embodiment upon receiving a request to deploy a next version of a software component deployment scheduler schedules the deployment of the next version of the software component based on the generated dependency analysis among components in the cloud environment. Deployment scheduler may plan deployment operations in accordance with process illustrated in . The next version of the software component is deployed in the cloud environment in accordance with the scheduled deployment.

Request dispatching infrastructure dispatches incoming requests. In one embodiment request dispatching infrastructure may include a load balancer that is part of standard cloud infrastructures. The load balancer may manage workload by dispatching requests to cluster nodes with lower workload. Request dispatching infrastructure may also include inbound and outbound request dispatcher that may direct HTTP request inside and outside the cloud environment respectively.

In one embodiment during the quarantine of the next version of the software component a portion of incoming requests e.g. 10 to the software component is dispatched to the next version of the software component by request dispatching infrastructure . Another portion of incoming requests to the component e.g. 90 is dispatched to the current version of the software component by request dispatching infrastructure .

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components may be implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

