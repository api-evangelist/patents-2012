---

title: Techniques for debugging computer programs involving multiple computing machines
abstract: Techniques for debugging a computer program that includes multiple modules executing on multiple machines include receiving, at a unifying component, first data from a first machine. The first data indicates debugging information generated by the first machine. Second data is also received at the unifying component from a second machine. The second data indicates debugging information generated by the second machine. Based on the first data and the second data, third data is formed indicating a single integrated representation of debugging information for the computer program. The unifying component allows debugging information from several machines to be integrated and then presented to a user through a single debugger client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08799863&OS=08799863&RS=08799863
owner: Oracle International Corporation
number: 08799863
owner_city: Redwood Shores
owner_country: US
publication_date: 20120331
---
This application claims the benefit of priority under 35 U.S.C. .sctn.120 as a continuation of U.S. patent application Ser. No. 12 022 076 now U.S. Pat. No. 8 321 838 filed on Jan. 29 2008 which application claims the benefit of priority under 35 U.S.C. 120 as a continuation of U.S. patent application Ser. No. 10 143 890 now U.S. Pat. No. 7 350 194 filed on May 10 2002 which patent claims the benefit of priority under 35 U.S.C. 119 to U.S. Provisional Patent Application No. 60 324 722 filed Sep. 24 2001 the entire contents of each of which are hereby incorporated by reference as if fully set forth herein.

The present invention relates to debugging a computer program. In particular the present invention relates to debugging a computer program that is executed by multiple virtual machines.

Computer programs are instructions for controlling processors in computing devices. Computer programs are typically written in one or more high level languages that are easy for a human being to understand. These source language statements are then typically compiled by a special type of program called a compiler and converted to coded instructions which often correspond to the actual operations performed by a processor in a computer device. Frequently the coded instructions are not identical to the native instructions for the processor but instead are instructions for a particular virtual machine. A virtual machine is a process that interprets coded instructions and executes them. The virtual machine itself is an executable sequence of instructions in the native language of the processor. Virtual machines are sometimes called interpreters. As used herein the term machines includes virtual machines interpreting virtual machine instructions operating systems interpreting operating system instructions and processors executing native instructions.

An advantage of a virtual machine is that the same coded instructions for a particular virtual machine may be used on multiple computer devices built with different processors supporting different native instructions. The particular virtual machine is formed separately using instructions from a different native instruction set for each different processor. Then any program written in or compiled to the coded instructions for the particular virtual machine can be executed on any processor that executes the particular virtual machine. Examples of virtual machines include the Java virtual machine JVM the BASIC interpreter the VisualBasic interpreter and the interpreter for the PL SQL language of the Oracle Corporation.

When a program is written or modified it may be compiled successfully into coded instructions and yet still not perform correctly when executed by the virtual machine. To assist a programmer in determining how the program executes differently than expected debuggers have been developed for virtual machines. Debuggers are processes that provide functions that enable a programmer to determine the contents of computer memory at a time of execution for any instruction in one or more sequences of instructions.

Virtual machine debuggers typically include a debugger client process that interacts with an interface of the virtual machine. The debugger client process executes on a user s computing device that includes a display device. The debugger client process typically presents information about high level language statements and the contents of memory when the statements are executed. The debugger client process also includes controls that the user can operate to indicate which memory contents to display and to indicate the next set of one or more instructions to execute before reporting the contents of memory or to indicate a particular instruction at which execution is stopped and memory contents reported. In response to user actions the debugger client process interacts with the debugger interface in the virtual machine. For example the debugger client process sends a message to the virtual machine requesting that the virtual machine execute the next instruction and return the contents of one or more memory locations. As another example the debugger client process invokes one or more routines of the virtual machine to execute the next instruction. As used herein the term routine refers to a sequence of instructions ending in a return to a calling entity. Other terms commonly used for routines include functions procedures methods and subroutines. The main block of code that is first executed for a program that often returns control to an operating system is also a routine. The debugger client process often presents to the user the context of program execution using a stack of routines that have been called but have not yet returned control to the calling routine.

In general coded instructions from one or more modules can be linked to form an executable program. Modules can consist of source language statements coded instructions for a particular virtual machine runtime executables or some combination of these with or without associated data. Modules in a high level source language may be compiled by a run time compiler to produce corresponding modules in coded instructions.

It is becoming more common to create programs that include heterogeneous modules. For example a program may include a machine executable module a module executable by a first type of virtual machine and a module executable by a second type of virtual machine. During execution of the program a routine in the machine executable module may call a routine in the module running in a first type of virtual machine and that routine may call another routine in the module running in a second type of virtual machine.

In addition it is common for programs executing on different processors to interact with each other. For example a database application program such as an accounting program runs on one processor on one device on a network. However while running the accounting program may cause a database procedure such as an average salary computation procedure to be launched by a database server and run on a second processor on a different device on the network. Even if the database application program and the stored procedure are implemented with coded instructions for the same type of virtual machine e.g. both programs are Java programs each processor is running a separate instance of the particular virtual machine. In many situations the interacting programs will not only be running on different virtual machines but will employ coded instructions for different types of virtual machines e.g. one will be a Java program while the other is a Visual BASIC program .

While computer programs now often include multiple modules executed by different virtual machines or different instances of the same virtual machine the debuggers currently available are typically not designed to handle these situations. For example while the human user thinks about the program as a single entity the program s execution is typically displayed as a series of separate stacks one stack for each instance of each virtual machine.

A programmer who wants to trace the contents of memory while executing a set of instructions that spans two modules run on separate virtual machines usually operates separate debugger clients for the two modules and interacts separately with the two instances of the virtual machine. Memory contents could be manually copied from the user interface of one debugger client and inserted in the user interface of a separate debugger client. The manual process is tedious and subject to increased risk of human errors. The tedium and risk of error are multiplied as the number of separate interacting modules that are to be debugged increases.

Based on the foregoing there is a clear need for a debugger process that presents debug information in an intuitive manner even for programs that include multiple modules executing on multiple virtual machines. As used herein multiple virtual machines refers to multiple instances of the same virtual machine virtual machines for different languages or both.

Techniques are provided for debugging a computer program that includes multiple modules executing on multiple machines. In one aspect of the invention the techniques include receiving at a unifying component first data from a first machine. The first data indicates debugging information generated by the first machine. Second data is also received at the unifying component from a second machine. The second data indicates debugging information generated by the second machine. Based on the first data and the second data third data is formed indicating a single integrated representation of debugging information for the computer program.

According to an embodiment of this aspect of the invention the techniques include sending the third data from the unifying component to a debugger process for presentation to a user.

The unifying component allows debugging information from several machines to be integrated and then presented to a user through a single debugger client.

According to another aspect of the invention techniques for debugging a computer program that includes multiple modules executing on multiple machines includes receiving at a first unifying component first data from a first machine and second data from a different unifying component. The first data includes debugging information generated by the first machine. The different unifying component is associated with a subset of the machines. The second data includes debugging information generated by the subset of machines. Based on the first data and the second data third data is formed indicating a single integrated representation of debugging information for the computer program.

The unifying components allow debugging information from several tiers of machines to be integrated and then presented to a user through a single debugger client.

According to another aspect of the invention techniques for debugging a computer program that includes multiple modules executing on multiple machines include receiving at a unifying component a first message from a debugger process. The first message specifies a debugging operation associated with a request set of one or more instructions or objects of the computer program or both. In response to receiving the first message the unifying component determines that a first machine is associated with a module that includes at least one member of the request set. Based on the first message the unifying component generates a second message indicating the debugging operation associated with the member of the request set. The unifying component sends the second message to the first machine.

According to embodiments of this aspect of the invention the unifying component determines that a second machine is associated with another module that includes at least a different member of the request set. Based on the first message the unifying component generates a third message indicating the debugging operation associated with the different member. The unifying component sends the third message to the second machine.

The unifying component thus allows a single conventional debugger client to control the debugging operations of several machines.

A method and apparatus for debugging computer programs involving multiple machines is described. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. For example embodiments of the invention are described below in the context of multiple virtual machines however other embodiments of the invention may involve a machine executing instructions native to a processor or a machine executing operating system instructions in place of one several or all of the virtual machines. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

The system also includes a debugger client executing on a debugger client host . The debugger client includes an interface for communicating with the virtual machines . The virtual machines include interfaces respectively for communicating with a debugger client. The debugger client and the interfaces are described in more detail in a later section.

Embodiments of the present invention include a unifying process for mitigating communications among the debugger client and the virtual machines . The unifying process includes an interface and an interface . Hereinafter the interfaces are collectively referenced as interface and interfaces are collectively referenced as interface . The unifying process is described in more detail in a later section.

When the program is debugged a virtual machine that interprets coded instruction modules of the stored modules is run in a debug mode. When running in a debug mode the virtual machine interacts with the debugger client on the debugger client host . The debugger client typically includes a user interface not shown that displays information about the program that is being debugged and provides controls for a user to control the execution of the program. For example the user may specify through the controls provided by the user interface of the debugger one or more breakpoints. A breakpoint identifies a location within the program at which execution should halt. Halting a program at a breakpoint gives the user time to inspect the debug information at that particular point of execution. The user typically specifies a breakpoint by selecting an instruction in the high level language code that was used to generate the program. The execution of the program halts after executing the lower language code that corresponds to the selected higher language instruction.

As a more specific example the user is prompted to specify one or more Java statements to serve as execution breakpoints and to specify one or more Java objects or attributes whose contents are of interest. The debugger client sends messages to the virtual machine . The commands include the information to control execution of the modules such as the breakpoints and memory locations of interest. The virtual machine executes the coded instructions of one or more modules until a breakpoint is reached. The virtual machine reports that the breakpoint is reached in a message containing debugging information to the client . If the user has not already done so the user then specifies a next debugging operation to perform such as executing the next statement in the program or reporting the contents of one or more memory locations of the virtual machine . The virtual machine retrieves the contents of the specified memory locations at that stage of execution and sends a report message including more debugging information back to the debugger client . The debugging information includes the memory contents. The debugger client presents the results usually in association with the instruction in the high level language that corresponds to the breakpoint.

As used herein debugging information is information based on data provided by one or more virtual machines which is utilized by a user of client to assess the performance of a computer program. Debugging information includes for example contents of memory locations at a particular stage of execution a call stack of virtual machines or routines that have been invoked but not yet ended at the particular stage of execution lists of objects associated with one or more routines or virtual machines tracing information and time profile information among others. Tracing information describes which groups of one or more instructions are executed. The groups may be modules or routines for example. Time profile information describes execution time consumed by groups of one or more executed instructions.

The debugger client often provides the user with information about the call stack of the virtual machine which provides context for the state of the program execution at the time the breakpoint is encountered. A call stack is often presented as a series of frames representing calls to routines that have not yet returned. The frames are positioned in the stack in order of execution. A frame in the stack is often expressed by the statement in the high level language that calls the routine or the name of the routine. The stack helps a user to identify where in the execution of the program the current memory contents occur.

The debugger client and virtual machine are designed to exchange commands and responses through interface on the debugger and complementary interface on the virtual machine. Any manner known in the art for an interface may be employed. In some embodiments an interface is a specified set of procedure calls that include specification of a procedure name and specification of number and types of parameters passed to the procedure and returned from the procedure. In such embodiments the debugger client typically is executed on the same host as the virtual machine rather than on different host as depicted in . The set of procedures that can be invoked in the virtual machine make up the virtual machine interface and the set of procedures that can be invoked in the debugger client make up the debugger client interface

In some embodiments an interface is a protocol for exchanging debugging information using data packets transmitted over a network. For example for a Java virtual machine the Java Debug Wire Protocol JDWP has been defined for exchanging debugging information between processes. JDWP may be used to transmit debugging information over the Transport Control Protocol of the Internet Protocol TCP IP or over any other network protocol or through pipes or shared memory. JDWP may also be used to pass information between parts of the same process using memory based mechanisms. At the time of this writing JDWP is described in file jdwp spec.html on directory j2se 1.3 docs guide jpda at Internet domain java.sun.com. Such protocols allow the debugger client to reside on a different host from the host where the virtual machine that is executing the module being debugged resides. In this case the virtual machine interface represents procedures that process the types of information passed to the virtual machine according to the protocol and procedures that produce messages for the debugger client according to the protocol. Similarly the debugger client interface represents procedures that process the types of information passed to the debugger client according to the protocol and procedures that produce messages for the virtual machine according to the protocol.

According to embodiments of the invention a unifying process is interposed between the debugger client and the virtual machine . To the debugger client the unifying process appears to be a virtual machine by virtue of the virtual machine interface . To the virtual machine the unifying process appears to be a debugger client by virtue of the debugger client interface . The unifying process produces integrated debugging information for presentation at the debugger client no matter which virtual machines execute different modules of the program as described in more detail in a later section. Although shown as a separate process in in some embodiments the unifying process is merely a component of one or more of the other processes such as the processes that implement the debugger client the virtual machine a development editor not shown or a database server not shown .

Also shown in are a second virtual machine with a virtual machine interface and a third virtual machine with a virtual machine interface . Depending on the nature of the application being executed the second and third virtual machines may execute at overlapping times relative to the first virtual machine .

For example a Java module executing on a first Java virtual machine may invoke a procedure from a second Java module that may be executed by a second instance of the Java virtual machine on a second host. After control returns from the called procedure of the second module the first Java module may then invoke the same or a different procedure that starts a third instance of the Java virtual machine. On a host with multiple processors the two or three Java virtual machines might execute on separate processors of the same host. On some hosts multiprocessing is performed by sharing time on the same one or more processors. If the calling module waits for the response from the called module before proceeding the call is said to be synchronous. The unifying process is configured to provide debugging information with respect to a single stack of frames for all modules involved in a series of synchronous calls. In some embodiments the unifying process is also configured to provide debugging information as separate stacks threads for any part of the program invoked by asynchronous calls.

In another example different virtual machines are executed to interpret modules in different languages that produce different types of coded instructions. For example a Java procedure invoked from a database may include an SQL statement. The Java virtual machine is executing to interpret the JVM coded instructions bytecode . To interpret the embedded SQL statement an SQL virtual machine is executed. The SQL statement may include an operation that triggers a procedure call for a module written in PL SQL so a PL SQL virtual machine is executed to interpret the PL SQL statements of the PL SQL module.

According to embodiments of the invention the second and third virtual machines communicate with the unifying process as does the first virtual machine . In the three virtual machines communicate with the unifying process through the same debugger client interface of the unifying process as described in more detail below. In other embodiments the virtual machines of different languages communicate through different debugger client interfaces. Although three virtual machines are depicted exchanging debugging information with the unifying process in in other embodiments the unifying process may exchange debugging information with more or fewer virtual machines.

Although the virtual machines are shown executing on the program hosts in other embodiments one or more of the virtual machines can execute instead on any host that includes either direct or remote access to an appropriate subset of the modules to be executed by the virtual machine.

Furthermore although the unifying process is depicted in as residing on the same hosts where the virtual machines reside embodiments that use a network protocol for the interfaces allow the unifying process to reside on any host on the network.

To illustrate the behavior of the unifying process with multiple instances of the same virtual machine it is assumed that the modules for the program are distributed over several program hosts. It is further assumed that the first virtual machine is a first instance of a virtual machine such as a JVM that executes on a first program host and that the second virtual machine is a second instance of the same virtual machine such as another JVM that executes on a second program host.

Any method may be used to associate high level language statements depicted in with the coded instructions actually interpreted by the virtual machine. In some embodiments the coded instructions are determined from the source code by compiling just before the virtual machine executes the coded instructions. In other embodiments the high level language statements are compiled into coded instructions ahead of time but pointers relate coded instructions to the associated high level language statement.

The A module includes statements in the high level language that define a routine X. The A module may also include other statements represented by the ellipses that are not relevant to illustrating an embodiment of the invention.

The B module includes statements in the high level language that defines a routine Y. The B module may also include other statements represented by the ellipses that are not relevant to illustrating an embodiment of the invention.

In the illustrated embodiment the routine X starts in statement includes other statements represented by the ellipsis and then includes a statement to invoke routine Y of the B module. For example a Java statement to invoke a routine Y a Java static method in a Java class named ClassQ in the B package could be of the form 

where the empty parentheses indicate that no parameters are passed to this particular routine. Routine X continues with other statements represented by the ellipsis . Routine X ends with statement which causes the virtual machine to return control to whatever entity invoked the routine X.

In the illustrated embodiment the routine Y starts in statement includes other statements represented by the ellipsis and then includes a statement to invoke routine Z of a C module on another host. Routine Y continues with other statements represented by the ellipsis . Routine Y ends with statement which causes the virtual machine to return control to whatever routine called routine Y. For example when routine X invokes the routine Y control is returned to routine X after the virtual machine executes all the statements in routine Y. Invoking a routine in the module C on a remote host involves communication from the first virtual machine that executes the coded instructions for the A module and the B module to the second virtual machine on the remote host that executes the coded instructions for the C module. Any method known in the art to provide the information and establish the connection may be used.

The stack includes frames representing invocations of routines X and Y respectively from the modules on the first host and includes a frame representing the invocation of routine Z of module C on the second host. Ellipsis represents frames for routines executed before routine X is invoked. Frame represents routine Z having statements in the high level language that have been executed before the breakpoint. The routine Z starts in statement includes other statements represented by the ellipsis and ends at the last statement . For purposes of illustration it is assumed that the breakpoint was selected after the last statement just before exit of routine Z. Therefore frame is the last frame in the stack. In embodiments in which the breakpoint is in another routine invoked directly or indirectly by Routine Z subsequent frames represented by ellipsis follow frame .

Unified stack represents call information in a manner consistent with how users think about the program that is being debugged. Specifically users typically consider the program as a single process involving a sequence of calls not as a complex web of interactions between disparate modules executing in separate processes. Using the unified stack a user can easily determine the contents of variables in routines X Y and Z at the stage when the breakpoint statement is executed. The user can also set the contents of those variables to different values.

However using conventional virtual machines and a single debugger client without a unifying process the frame of instructions executed on the remote host would not be displayed after frames and by the debugger client communicating with the first virtual machine . The user would not be able to use debugger client for setting or reporting contents of variables in Routine Z associated with frame . Instead the user would ordinarily execute a second debugger client not shown that communicates with the second virtual machine . Frame may then be indicated in a graphical user interface of the second debugger client. The user would have to switch back and forth between the first debugger client and the second debugger client to debug across the boundary between routine Y and routine Z. Such switching is slow and tedious and increases the risk the user may make an error in trying to debug the program. In addition when the two modules are separately debugged the sequential relationship of the calls made between the modules is not made explicit by either debugger client.

According to embodiments of the invention the unifying process is interposed between the debugger client and the virtual machines. The unifying process manages debugging information related to the frames of the stacks associated with multiple virtual machines and the unifying process interleaves the information to reference a single stack that is presented to the user at a single debugger client. For example the unifying process manages debugging information for frames associated with coded instructions interpreted by the first virtual machine and manages debugging information for frame associated with coded instructions interpreted by the second virtual machine . The unifying process interleaves this information to build the unified stack of frames as shown in and sends the interleaved debugging information to the debugger client. The debugger client presents the debugging information to the user in the context of the unified stack of . Various techniques that may be used by the unifying process to construct the unified stack are described in greater detail hereafter.

To illustrate the behavior of the unifying process when different types of virtual machines are involved e.g. the program being debugged involves modules written in multiple languages it is assumed that the modules for the program are modules of coded instructions for different virtual machines based on modules in different high level languages. It is further assumed that the first virtual machine is a JVM that the second virtual machine is an SQL virtual machine and that the third virtual machine is a PL SQL virtual machine.

As has been stated for any method may be used to associate high level language statements depicted in with the coded instructions actually interpreted by the virtual machine.

In the illustrated embodiment the Java routine Q starts in statement includes other statements represented by the ellipsis and then includes a statement that involves interaction with a SQL server. A standard interface called a Java database connection JDBC well known in the art is used to interact with the SQL server. For example statement is a call to a JDBC routine to execute an SQL query for retrieving data from the database and would be of the form 

Typically many other Java statements are also involved to define variables for exchanging information with the SQL server for dealing with error conditions that may arise among other actions but these additional statements are not used to illustrate this embodiment.

The Java routine Q continues with other statements represented by the ellipsis . Routine Q ends with statement which causes the JVM to return control to whatever entity invoked the routine Q. Similarly the routine S starts in statement includes other statements represented by the ellipsis and then includes a statement involved in submitting a second SQL statement to a SQL server. For example statement is a call to a JDBC routine to prepare another SQL SELECT command to a database server to retrieve data from the database. The routine S continues with other statements represented by the ellipsis . Routine S ends with statement which causes the JVM to return control to whatever entity invoked the routine S.

The PL SQL routine R starts in statement includes other statements represented by the ellipsis and then includes a statement that invokes the Java routine S. For example statement is of the form 

The routine R continues with other statements represented by the ellipsis . Routine R ends with statement which causes the PL SQL virtual machine to return control to whatever entity invoked the routine R.

In the illustrated embodiment frame represents routine Q which starts at a first statement in the routine Q and ends at the last statement of routine Q. Frame represents routine S which starts at a first statement in the routine S and ends at the last statement of routine S. Frame represents routine R which starts at a first statement in the routine R and ends at the last statement of routine R. Other statements are represented by ellipses .

When a user wishes to debug a program made up of Java modules and PL SQL modules the user would like to see the state of execution of all modules when the breakpoint is reached. is a block diagram illustrating a stack desired by a user which includes frames from all the modules executed regardless of the language and the virtual machine executing the modules.

The stack includes Java frames from the Java module and PL SQL frame from the PL SQL module . The stack also includes frames for the SQL statements respectively executed by the SQL virtual machine of the database server.

The frame stack of is useful at a single debugger client because it shows the sequence of frames representing routines in the order executed. Ellipsis represents frames associated with routines executed before routine Q is invoked. The routine in the frame immediately preceding frame includes a statement that causes routine Q to be invoked. The stack next includes Java frame representing execution of the Java statements of routine Q up to the statement invoking the process to execute the first SQL statement. The bytecode compiled from statements in the Java frame is executed by the JVM .

The stack next includes SQL frame representing the first SQL statement which is being executed by an SQL virtual machine not the Java virtual machine . In some embodiments the SQL statement is compiled into coded instructions having one or more basic SQL operations before being executed by the SQL virtual machine. For purposes of illustration it is assumed that the execution of the SQL statement triggers the execution of the PL SQL routine R by a PL SQL virtual machine .

The stack next includes PL SQL frame representing the executed statements of PL SQL routine R up to the invocation of the Java routine S. The coded instructions compiled from statements in the routine R are executed by the PL SQL virtual machine .

The stack next includes Java frame representing the executed Java statements of routine S up to the statement invoking the process to execute the second SQL statement. The bytecode compiled from statements in the Java frame is executed by the JVM .

The stack next includes SQL frame representing the second SQL statement which is being executed by an SQL virtual machine not by the JVM For purposes of illustration it is assumed that the second SQL statement is the breakpoint so that no further frames are on the stack. Ellipsis represents subsequent frames that would appear on the stack if the breakpoint were in another routine directly or indirectly invoked as a result of executing the second SQL statement.

Using the unified stack a user can easily determine the contents of variables in routines Q R S and in the first and second SQL statements at the time the breakpoint statement is executed. The user can also set the contents of those variables to different values. The user can also cause one of the virtual machines to execute the next instruction in the program.

However using conventional virtual machines and a single debugger client without a unifying process the frames of instructions executed on the SQL and PL SQL virtual machines would not be displayed among Java frames by the debugger client communicating with the JVM . The user would not be able to use debugger client to get or set values for variables within frames . To set breakpoints and to set and report variable contents in the SQL and PL SQL routines the user would ordinarily execute a second debugger client not shown that communicates with the SQL virtual machine and a third debugger not shown that communicates with the PL SQL virtual machine. The SQL frames may then be represented in a graphical user interface of the second debugger client. The PL SQL frames may then be represented in a graphical user interface of the third debugger client. The user would switch back and forth among the first debugger client the second debugger client and the third debugger client to debug across the boundaries between routines of the three different languages. Such switching is slow and tedious and increases the risk the user may make an error in trying to debug the program. Furthermore none of the debugger clients explicitly indicate the relative sequence of the frames among the three stacks.

According to embodiments of the invention the unifying process is interposed between a single debugger client and the virtual machines of multiple languages as in embodiments with multiple instances of the same virtual machine. The unifying process manages debugging information related to the frames of the stacks associated with multiple virtual machines for multiple languages and the unifying process interleaves the information to reference a single stack that is presented to the user at a single debugger client. For example the unifying process manages debugging information for Java frames associated with bytecode interpreted by the JVM . The unifying process manages debugging information for SQL frames associated with coded instructions interpreted by the SQL virtual machine . The unifying process manages debugging information for PL SQL frame associated with coded instructions interpreted by the PL SQL virtual machine . The unifying process interleaves this information to reference the stack of frames as shown in and sends the interleaved debugging information to a single debugger client . The debugger client presents the debugging information to the user in the context of the unified stack of .

The unifying process uses an interface for a single language to exchange information with the debugger client. Thus the unifying process appears to the debugger client to be a single virtual machine that interprets the coded instructions of all languages. For example the unifying process uses JDWP for data exchanges with the debugger client process and the unifying process appears to the debugger client to be a JVM that interprets the coded instructions from Java SQL and PL SQL modules.

According to embodiments of the invention the unifying process performs the methods illustrated in and to interleave debugging information from multiple virtual machines for multiple languages. Although steps are illustrated in these figures and subsequent flowcharts in a particular order in other embodiments the steps may be executed in a different order or overlapping in time or omitted altogether.

In step the user executes the multi module program in debug mode. Each virtual machine is configured to exchange information with a debugger client when executed in the debug mode. For example a user establishes a connection to a database server to execute a multi module program stored in the database. The connection setup includes data indicating that the particular debugger client is running on the particular workstation on the network. In some embodiments the user connects to a database server using a Web browser process not shown on the user s workstation . The Web browser is well known in the art of network communications and communicates according to the standard hypertext transfer protocol HTTP . The debugger client process is identified as a process listening on a particular port or socket on the host . In some embodiments the debugger client is identified in one message to the database server from the browser and stored thereafter on the user s workstation in a persistent file called a cookie as is well known in the art. In other embodiments a database user may instead connect to the database server through any database oriented protocol known in the art such as JDBC the Open Database Connectivity ODBC the Oracle Call Interface OCI the Universal Database Call Level Interface CLI among others. In some embodiments an operating system environmental variable is set to indicate that the debugger client is waiting on the host at a particular port. In some embodiments the program code run in a virtual machine may also include statements that explicitly connect or disconnect the virtual machine from the debugger client.

In step a unifying process is launched to mitigate between the debugger client and one or more virtual machines that are instantiated to execute the multi module program. Any manner known in the art to have virtual machines communicate with the unifying process and to have the unifying process communicate with the debugger client may be employed. For example the database server or the operating system responds to a communication indicating the host address and port of the debugger client by launching the unifying process on a particular host to respond to messages on one or more particular ports. Steps to launch the unifying process include passing to the unifying process the host and port of the debugger client . After launching the unifying process the database server or operating system that instantiates a virtual machine directs each virtual machine instantiated to send debugging information to the unifying process. For example the cookie or the operating system environmental variable is reset to indicate the host and a port of the unifying process. The unifying process may alternatively be embedded as part of a database server or other program which contains one or more virtual machines communicating with the virtual machines in that program through a function call application programming interface API or through messages passed in program memory.

In step a virtual machine is instantiated to execute coded instructions of a module of the program. The virtual machine is instantiated in debug mode with the host and port of the unifying process as the recipient of debug messages generated by the virtual machine. Any method for executing a virtual machine in debug mode may be employed. To determine any breakpoints for executing in the debug mode the virtual machine connects to the unifying process to receive debugging request information in one or more messages. For example debugging request information includes the breakpoints where execution is to be suspended. Also the debugging request information may include the identification of each requested variable object variable object ID whose contents are to be provided at the breakpoint. The virtual machine receives debugging request messages which may also be called debug requests with the debugging request information such as the breakpoints. The virtual machine executes up to the breakpoint invoking routines in other modules as indicated by the coded instructions in the module being executed. If a breakpoint is reached execution is suspended. A user may then send debug requests for one or more variable objects. The contents of the requested variable objects are sent to the unifying process in debugging information from the virtual machines either automatically or upon a specific request from the unifying process.

If the virtual machine invokes a routine in a module executed by another virtual machine the other virtual machine is instantiated as shown in step . If this routine causes invocation of another routine that is executed by a third virtual machine the third virtual machine is instantiated in step . When each virtual machine is instantiated in steps and the virtual machine connects with the unifying process receives any debug requests and starts executing the invoked routine in the module the virtual machine is executing until a breakpoint is reached. Although shows three virtual machines are instantiated in other embodiments more or fewer virtual machines are instantiated.

In step a debugging message is received at the unifying process from a debugger client. The message includes one or more operations breakpoints or variable objects. The breakpoints are indicated by module identifiers and position indicators such as module names and statement line numbers. It is assumed for purposes of illustration that module is named AtoQS and that statement occurs at a line number having a value 444. For example to set a breakpoint at statement of Java module in the debug message includes data indicating set breakpoint and AtoQS and line 444. If the method is used recursively a sequence number can be added to the module identifier. In some embodiments such as embodiment using JDBWP to pass request information and debugging information routines variable objects and even frames are identified by one or more unique integers generated by the system rather than by names.

The variable objects are indicated by an object ID such as a module name a routine name and an object name or by a unique integer or set of integers. For example it is assumed for illustration that statement includes an SQL clause where T.CityName FirstCity in which CityName is a column in table T of the database and FirstCity is a variable whose value is set sometime during execution of the coded instructions associated with the modules and . It is assumed for illustration that the variable FirstCity is a user define object including a city name a province name and a country name. It is assumed further that FirstCity is defined as a private variable in the routine S of Java module . To indicate the object ID of the variable FirstCity it is specified by its module routine and name AtoQS.S.FirstCity. Thus to set a value for the variable at a breakpoint at statement the debug request message includes data indicating the operation set variable value on entry the breakpoint AtoQS line 444 the variable AtoQS.S.FirstCity and the value Rome N.Y. USA. In an alternative embodiment a first request message sets the breakpoint and a second request message specifies the variable after the client is notified that the breakpoint has been reached. To get a value for the variable at a breakpoint at statement the debug request message includes data indicating the operation get variable value on entry the breakpoint AtoQS line 444 and the variable AtoQS.S.FirstCity. 

In other examples the debug request message is a request to execute a single step or a request to list all loaded classes or a request to list the routines on the stack or a request to list the IDs of the variable objects associated with each routine on the stack.

It is assumed that the debug request message received includes data indicating a first operation get variable value on entry the breakpoint AtoQS line 444 and the variable AtoQS.S.FirstCity and a second operation get variable value on SQL exit the breakpoint AtoQS line 444 and the variable SQL.FirstCity. With these two breakpoints a user can determine whether the value of the variable FirstCity changed from the time the SQL statement was submitted from the Java routine S until the time the SQL statement was executed by the SQL virtual machine.

In step the unifying process determines the breakpoints or variable object IDs within modules executed by a current virtual machine of the multiple virtual machines. For purposes of illustration it is assumed that program execution has already been halted at a breakpoint in routine R in the PL SQL module being executed by the third virtual machine . Routine R is triggered upon execution of the first SQL statement executed by the second virtual machine . The first SQL statement is submitted by statement of the routine Q being executed by the first virtual machine . Thus the first second and third virtual machines have been instantiated at the time step is performed in this example. One of the three virtual machines is made the current virtual machine and it is determined whether any breakpoints and variable object IDs are associated with that virtual machine.

In the illustrated embodiment the first virtual machine is the JVM which executes module . Module has a breakpoint to be set at line in the example data received in step . The second virtual machine is the SQL virtual machine and has a breakpoint upon exit of the submitted SQL statement in the example. The third virtual machine is the PL SQL virtual machine which does not have a breakpoint in the data received in step in this example. For example the JVM is made the current virtual machine and it is determined that the operation get variable value on entry the breakpoint AtoQS line 444 and the variable AtoQS.S.FirstCity are to be included in a debug message for the current virtual machine.

In step the breakpoints and variable object IDs are translated from constructs of the language used by the debugger client to constructs of the language used by the current virtual machine. This step is omitted in embodiments in which the current virtual machine is modified to do such a translation as described in more detail below with respect to . This step is also omitted in embodiments in which the language used by the debugger client is the language of the current virtual machine into which the breakpoint is submitted. This step is omitted in the example because the debugger client is assumed to use the JDWP interface that employs Java constructs and the current virtual machine is the JVM that also uses Java constructs.

In step a new debug message is generated for the current virtual machine. The new debug message includes only breakpoints in the modules executed by the current virtual machine and references breakpoints and variables using the language constructs of the current virtual machine. For example a modified debug message is generated that includes only the operation get variable value on entry the breakpoint AtoQS line 444 and the variable AtoQS.S.FirstCity. In step the modified debug request message is sent to the current virtual machine. For example the modified debug request message is sent to the JVM .

In step it is determined whether there is another virtual machine that has been instantiated. If so control flows to step to make another virtual machine the current virtual machine and return control to step .

For example it is determined in step that the SQL virtual machine is also instantiated so the SQL virtual machine is made the current virtual machine and control passes to steps through to generate and send a modified debug request message for the SQL virtual machine . In this example a second modified debug request message is generated and sent to the SQL virtual machine . The second modified debug request message includes data indicating the operation get variable value on SQL exit the breakpoint second SQL statement and the variable SQL.FirstCity. In an illustrated embodiment no line numbers internal to an SQL statement are used as breakpoints so that the only breakpoints are before entry and after exit from the SQL virtual machine.

After making the SQL virtual machine the current virtual machine on the next performance of step it is determined in step that the PL SQL virtual machine is also instantiated so the PL SQL virtual machine is made the current virtual machine and control passes to steps through to generate and send a modified debug message for the PL SQL virtual machine . In this example it is determined that no breakpoints or variable objects are specified for the PL SQL virtual machine . Thus in this example no modified debug request message is generated or sent to the PL SQL virtual machine .

If it is determined in step that there is no other virtual machines instantiated processing of the debug message from the debugger client is complete as indicated by the passing of control to step to end the process.

In step a message is received from a virtual machine of the plurality of virtual machines with debugging information. The virtual machine that sends the message is a current virtual machine. The other instantiated virtual machines are waiting for the current virtual machine to finish processing and return control to one of the other virtual machines. The message may indicate the current virtual machine is completing execution of a routine that the current virtual machine is beginning execution of a routine that the current virtual machine has reached a breakpoint or that the contents of one or more variable objects are being returned. In some embodiments the data are expressed in the language constructs of a different language than is used by the debugger client . In such embodiments step includes steps to translate the constructs of the different language to the constructs of the language used by the debugger client . An example translation is described in more detail in a later section.

In step it is determined whether the data indicates the current virtual machine is returning control to a calling routine that invoked the current routine. For example the data indicates that the PL SQL virtual machine has completed execution of routine R and is returning control to routine Q that invoked routine R. If so control passes to method illustrated in and described in more detail below with reference to . If not control passes to step .

In step data indicating the next routine to be executed or the current values of variable objects in the calling routine are determined from the message received from the current virtual machine. In some embodiments the values of variable objects are indicated explicitly. In some embodiments the data indicates only the object IDs of the variable objects for which values are maintained by the current virtual machine. The object ID may subsequently be used to retrieve the values of those objects from the virtual machine. The current values of some variable objects might not yet be defined.

In some embodiments in which each virtual machine maintains a call stack for its own routines the debugging information may include the virtual machine s call stack and that call stack is determined in step .

For example in step data is obtained from a message from the JVM which indicates the next routine to be executed is submission of the second SQL statement. The values of variable objects in routine S that submits the second SQL statement are also indicated. For example the value of AtoQS.S.FirstCity is Rome N.Y. USA. 

In step it is determined whether the next routine is in a module executed by the current virtual machine. If so control passes to step to add a frame representing the next routine to a stack of frames associated with the current virtual machine. For example if the next routine were a routine X also executed by the JVM control would pass to step to add a frame for routine X to a stack for the JVM . In some embodiments in which the virtual machine maintains its own call stack step may be omitted.

If instead the next routine is executed by a different next virtual machine then control passes to step to receive the data from the next virtual machine and to add a frame for the next virtual machine to a call stack of virtual machines maintained by the unifying process. The frame for the virtual machine also specifies the unique position of the call in the calling virtual machine. Control passes from step to step to make the next virtual machine the current virtual machine. Then control passes to step to add a frame representing the next routine to the stack of frames associated with the current virtual machine. In the example the current JVM executes the current routine S through the statement that submits the second SQL statement. The second SQL statement is the next routine and is executed by the SQL virtual machine different from the JVM . Control passes to step to receive data from the SQL virtual machine indicating that execution of the second SQL statement by the SQL virtual machine is beginning and to add the SQL frame to the call stack. In step the SQL virtual machine is made the current virtual machine. Control then passes to step to add a frame for the second SQL statement to the stack for the SQL virtual machine.

In some embodiments step is omitted because the frame is automatically added to a stack for the current virtual machine by the virtual machine itself and the unifying process can request the stack from the virtual machine whenever that information is to be used.

In step the frame for the next routine is added to a single stack maintained by the unifying process for all the routines executed for the multi module program. For example SQL frame is added to single frame stack . The single frame stack includes above the SQL frame Java frame for the Java routine S that submitted the second SQL statement. The single frame stack includes above the Java frame a PL SQL frame for the PL SQL Routine R that invoked the Java routine S. The single frame stack includes above the PL SQL frame a SQL frame for the SQL statement that triggered the PL SQL routine R. The single frame stack includes above the SQL frame a Java frame for the Java Routine Q that submitted the first SQL statement. None of the stacks maintained by the individual virtual machines include all these frames.

In step the values of the requested variables in the current routine are associated with the frame. This can be performed in any manner. For example in some embodiments the frame of the single stack can be associated with a frame in a virtual machine that maintains the values of all variables for the routine. In some embodiments the unifying process stores the variable object IDs and their values in association with the frame for all variable objects in the routine. In some embodiments the unifying process stores only the values of the requested variable objects in the routine in association with the frame.

For example the value of the variable object FirstCity when the SQL statement is entered is associated with the frame. For purposes of illustration it is assumed that the value of the FirstCity variable object is Rome N.Y. USA at the entry point. In the illustrated example the value of the variable FirstCity in the SQL frame at the time of reaching the breakpoint of exiting the SQL statement execution is associated with the frame. For purposes of illustration it is assumed that the value of the FirstCity variable object is Rome Latium Italy at the breakpoint.

Also in step the next routine is made the current routine. For example the second SQL statement is made the current routine.

In step it is determined whether the message is received while the current virtual machine is at a breakpoint. If not processing of the message is complete as indicated by passing control to step to end the process. For example if the debug message is sent by the current virtual machine to indicate that the routine has started execution but there is no breakpoint upon entry of the routine control passes to step .

If it is determined in step that the debug information indicates a breakpoint has been reached control flows to step . In step the unifying process receives data indicating values of variable objects in the current routine at the breakpoint. In some embodiments the data is provided automatically by the current virtual machine for all routines in the stack of the current virtual machine. For example the SQL virtual machine provides values for all variables associated with the first and second SQL statements in the stack of the SQL virtual machine. In some embodiments some or all of the information is obtained from the current virtual machine by requesting values from the virtual machine. For example the unifying process sends a message to the virtual machine requesting values for the requested variable objects from one or more of the routines in the stack maintained by the virtual machine. In some embodiments the unifying process already stores some or all of the information as a result of step .

For example the SQL virtual machine provides a value for the FirstCity variable object upon reaching the breakpoint. In the illustrated example the value is Rome Latium Italy. 

In step the unifying process assembles data indicating values for all requested variable objects associated with routines in the single stack. For example it is assumed that the user has also requested the value of the variable string MonthAveraged determined during execution of PL SQL routine R at the time of execution of the breakpoint. In step the unifying process obtains the current value in the variable MonthAveraged associated with the stack for the PL SQL virtual machine. In some embodiments the value of MonthAveraged at the time of the break is obtained by requesting the value from the PL SQL virtual machine . For example the unifying process sends a message to the PL SQL virtual machine requesting values for the MonthAveraged string from the stack maintained by the PL SQL virtual machine . In the illustrated example the value is assumed to be February. In some embodiments the unifying process already stores some or all of the information as a result of step .

For example the unifying process finds the requested variable MonthAveraged in the single stack associated with the PL SQL frame and requests the value of the variable string MonthAveraged from the PL SQL virtual machine . The PL SQL virtual machine sends the value February in response. The unifying process then generates data indicating the value Rome Latium Italy for the variable user defined object FirstCity and the value February for the variable string MonthAveraged.

In some embodiment in which the debugging information is obtained from the virtual machines a check is made during step to determine whether the debugging information has been received from all the virtual machines with requested data. If not the unifying process ends for the processing of the message received in step passing control to step . Essentially the unifying process waits for additional messages with debugging information. If all the virtual machines with requested data have reported control passes to step .

In embodiments in which the virtual machines provide debugging information in different formats step includes converting the format. For example the format is converted to JDWP. In embodiments in which the virtual machines provide debugging information with different language constructs than used by the database client step includes using the mapping to generate debugging information in the constructs of the language used by the debugger client.

In step the data generated in step is sent to the debugger client. For example the data indicating the value Rome Latium Italy for the variable user defined object FirstCity and the value February for the variable string MonthAveraged is sent to the debugger client . Thus data from several virtual machines are integrated and sent to the only debugger client.

In step data indicating that the current routine is returning control to the calling routine is obtained from the data received from the current virtual machine in step . In the illustrated example the data indicates that the current virtual machine SQL virtual machine has completed execution of the second SQL statement and is returning control to the routine that submitted the second SQL statement.

In step the most recent last routine frame is removed from the single stack. The remaining last frame i.e. the frame immediately above the removed frame is the frame of the calling routine. Therefore it is determined in step using the single stack that the Java frame is the frame of the calling routine. Java routine S is associated with the Java frame thus Java routine S is the calling routine. In some embodiments the values of variable objects associated with the removed frame are deleted. In embodiments in which the unifying process only maintains a stack of virtual machines step is omitted.

In step the last frame is removed from the stack associated with the current virtual machine. For example an SQL frame associated with the second SQL statement is removed from a stack for the SQL virtual machine. In some embodiments step is omitted because the virtual machine maintains the stack for itself.

In step the calling routine is made the current routine. In the illustrated example the Java routine S becomes the current routine.

In step it is determined whether the calling routine is in a module executed by the current virtual machine. If so processing of the message from the virtual machine is complete as represented by step indicating that processing is done.

If it is determined that the current routine is not in a module executed by the current virtual machine then control passes to step . For example it is determined that the Java routine S is not in a module executed by the current SQL virtual machine. In step data is received from the virtual machine that executes the current routine. The data indicates the virtual machine is continuing to execute the current routine at the point of return from the called routine. In the illustrated example the data indicates that the JVM is continuing to execute the routine S at the point of return after submitting the second SQL statement. In step in response to receiving data in step the unifying process makes the virtual machine sending the data in step the current virtual machine. This is done by removing the most recent last frame from the stack of virtual machine frames. In the illustrated example the unifying process drops the SQL frame from the stack and makes the JVM the current virtual machine. Processing is then completed as represented by passing control to step .

Using the steps of the unifying process maintains a single stack for all virtual machines and in some embodiments all routines executed by all virtual machines for the multi module program. The unifying process integrates the debugging information such as breakpoints variable object IDs variable object values time profile information and tracing information for all the virtual machines. Meanwhile the debugger communicates simply with the unifying process.

In some embodiments the unifying process exchanges information with each virtual machine using an interface tailored for the language of the virtual machine. For example the unifying process uses a database management system debugging interface DBMS debug for exchanging information with the PL SQL virtual machine while also using the JDWP to exchange information with the JVM . In such embodiments steps and of the unifying process methods include steps to translate debugging information between a format used to exchange debugging information with the debugger client and a different format for a virtual machine of a different language. For example the unifying process translates debugging information between JDWP and DBMS debug for passing debugging information between the debugger client and the SQL virtual machine or the PL SQL virtual machine . In the illustrated embodiment described next the translation to a common specified format is performed within one or more virtual machines instead of in the unifying process.

According to the illustrated embodiment a particular specified interface is used for exchanging data with the debugger client. The same specified interface is used for exchanging data between the unifying process and virtual machines for two or more languages. One or more virtual machines are modified to exchange debugging information using the specified interface. In the illustrated embodiment the SQL and PL SQL virtual machines are modified to exchange debugging information with the unifying process using JDWP. In this embodiment all three virtual machines exchange information with the unifying process using the same interface as depicted in .

This embodiment using the JDWP for the specified exchange format has several advantages. The JDWP allows the unifying process and the debugger client to be anywhere on the network rather than having to be on the same host. The JDWP already works or is readily implemented in JVMs. The JDWP interface is already published and several vendors already supply JDWP compliant debugger clients. Also the unifying process is simpler to design implement and maintain because it need not include a translator between JDWP and every other debugging interface for virtual machines.

As used herein a language construct indicates an element of the language or an element of the representation of the language at run time. A program unit is an example of a language construct. In different languages the program unit may be called a module class or package among other terms. A routine defined within a program unit is another example of a language construct. In different languages the routine may be called a function procedure method or subroutine among other terms. A variable is another example of a language construct. Each language usually supports several variable types or scopes such as static variable object fields object attributes local variables or global variables among others. A type definition is another example of a language construct. Each language usually supports several types such as class structure array variable array table record integer floating point or character among others. A position within other language constructs is itself a language construct. In different languages the position might be specified as a statement number a line number or a program counter.

For example the modified PL SQL virtual machine includes a PL SQL mapping process for use with an interface based on the JDWP. The mapping process translates PL SQL constructs to Java constructs for sending information out through the JDWP interface and translates Java constructs to PL SQL constructs for receiving debugging information through the JDWP interface

An advantage of the illustrated embodiment is that the modified virtual machine can be used directly with any debugger client using the specified interface as well as with the unifying process using the specified interface. For example a modified PL SQL virtual machine that maps PL SQL to Java constructs for the JDWP can be used directly with a JDWP compliant debugger client . In an embodiment in which only modules in PL SQL are used with a single instance of the modified PL SQL virtual machine the unifying process can be omitted. The modified PL SQL virtual machine can exchange information directly with a JDWP compliant debugger client using the JDWP interface

In step a mapping is generated and stored. The mapping maps language constructs of an interface language used at the interface between a virtual machine and a debugger client to and from the language constructs of a different language. For example JDWP provides an interface that uses Java classes having methods and attributes all named within a consistent namespace as language constructs. To use JDWP as an interface between a PL SQL virtual machine and a debugger client the language constructs of PL SQL are mapped to language constructs of Java and the language constructs of Java are mapped to the language constructs of PL SQL. An example mapping between PL SQL and Java is provided in more detail in the following section. In the illustrated embodiment the mapping is stored as computer code that converts between constructs of one language and the other. In other embodiments other mapping techniques can be employed such as generating and storing a table in which each row contains the construct of one language in one set of one or more columns and the corresponding construct of the other language in a second set of one or more columns.

In step an interface compliant debugging request is received for a first virtual machine. The first virtual machine executes coded instructions based on a module written in a different language than the interface language. For example the first virtual machine is the PL SQL virtual machine in embodiments in which the interface is JDWP for use with the Java language. For example a debugging request for the values of the variables in a routine associated with a frame of the PL SQL virtual machine is received.

In step the mapping stored in step is used to generate a modified request using the constructs of the different language executed by the first virtual machine. For purposes of illustration it is assumed that the module is named Averages and belongs to the database of SchemaB. The routine is referenced within the PL SQL virtual machine as Averages.R. The frame associated with the routine is requested using a JDWP compliant request specifying a frame associated with a routine named APDBMS.package body.SchemaB.Averages.R so that names unique in the PL SQL package remain unique when combined with routines in modules executed by other virtual machines as described in more detail in the following section. Thus in step in the illustrated example the request for variable objects in the frame associated with the routine APDBMS.package body.SchemaB.Averages.R is mapped to a request for variable objects in the frame associated with the routine Averages.R. In some embodiments the mapping is done at a unifying process in step and the modified request is then sent to the first virtual machine as part of step . In some embodiments as depicted in the mapping is done within the virtual machine itself.

In step the first virtual machine for executing coded instructions based on a module written in the different language generates debugging information for that module. For example the PL SQL virtual machine generates a value February for the variable string MonthAveraged defined in the PL SQL module in response to a request from a debugger client or a unifying process. The variable MonthAveraged has the value February in association with the frame in the PL SQL stack for the routine R of the module Averages found in database belonging to SchemaB.

In step interface compliant debugging information is generated from the debugging information produced in step and the mapping. For example the frame associated with the routine named Averages.R is mapped to a frame associated with a routine named APDBMS.package body.SchemaB.Averages.R. The variable string MonthAveraged is mapped to the Java class VARCHAR2 defined in the following section. Thus string MonthAveraged is mapped to VARCHAR2 MonthAveraged. The value of the string is stored in the attribute  value of the VARCHAR2 class as defined in the following section. Thus MonthAveraged. value February. If the string MonthAveraged is defined to be less than 10 characters in the PL SQL code then this information is mapped to the attribute  maxLength of the VARCHAR2 class. Thus MonthAveraged. maxlength 10. In the illustrated embodiment the interface compliant debugging information takes the following form. However in JDWP the named objects and routines would be replaced by unique ID numbers which are difficult for a human to track.

In step the interface compliant debugging information is sent to the unifying process. Step is omitted in embodiments in which the mapping is performed within the unifying process such as in step and described above. Step and the following steps are omitted in embodiments in which all modules of the program are executed by the same instance of a virtual machine. In such embodiments the debugging information is inherently integrated and is sent directly to the debugger process in step .

In step a second virtual machine for executing coded instructions based on a module written in the interface language generates debugging information for that module. For example the JVM generates a value Rome N.Y. USA for the variable user defined object FirstCity defined in the routine S of the Java module named AtoQS in response to a request from a debugger client or a unifying process. It is assumed for purposes of illustration that the user defined object FirstCity is an instance of a user defined class CITY. The debugging information is already in a form that can be transferred through JDWP in JDWP the named objects and routines would be replaced by unique ID numbers 

The debugging information is sent to the unifying process in step because in the illustrated embodiment there are at least two virtual machines executing the code of the multi module program.

In step the unifying process integrates the debugging information as described above with reference to and so generates integrated interface compliant debugging information.

In step the integrated interface compliant debugging information is sent to the debugger client often from the unifying process. If only one instance of a virtual machine executes all the modules of the multi module program then the debugging information may be sent directly from the virtual machine to the debugger client according to some embodiments.

In step the PL SQL constructs are mapped to Java constructs. In one embodiment the following mapping is stored. The mapping is then used in step to translate PL SQL constructs into Java constructs.

The following mapping is used in step to translate PL SQL program units into Java program units. It is assumed that the PL SQL program unit is stored in a database under control of a particular database management system designated herein as APDBMS in which each database belongs to a schema and comprises multiple database objects.

A Java package name is constructed for each program unit according to the template APDBMS. program unit type . schema . program unit name . A program unit type is selected from a list including package package body procedure function trigger type for user defined objects and type body well known to programmers of PL SQL. In addition the list includes block for sets of instructions generated at runtime and not stored persistently with a name.

A program unit name is the name given to a program unit in PL SQL. A program unit name is generated for a block. A program unit name for a first program unit defined inside a second program unit will concatenate the name of the of the first program unit to the name of the second program unit separated by a special symbol such as . 

The following mapping is stored in step and used in step to translate PL SQL and SQL data types into Java data types and back. Data types may be primitive or composite.

Java classes are defined for each of the primitive types and reside in the APDBMS namespace. The classes are declared final so that a debugger client need not expend resources querying for the class type at runtime. The attribute names in the classes have a leading underscore   . Runtime values for the attributes of the classes are always represented by an object of the java.lang.String class. The object contains a printable representation or approximation of the actual value of the PL SQL or SQL variable or parameter. In the event that the variable or parameter is NULL in the SQL sense the value will appear to be null in the Java sense. PL SQL allows programmers to add constraints to variable declarations. Constraints are treated as runtime attributes of the Java classes defined for the primitive types.

For example the primitive types are presented through JDWP as if they had been declared in Java by a package APDBMS.Builtin declaration followed by the following code fragments.

PL SQL integer binary integer natural naturaln positive positiven and signtype types are treated as members of an PLS INTEGER class defined using 

PL SQL number integer int smallint decimal numeric and dec types are treated as members of a NUMBER class defined using 

A PL SQL time type is treated as a member of one of the following TIMESTAMP or time INTERVAL classes defined using 

PL SQL string values for string types are converted to UTF 8 a standard character set well known in the art when transported through JDWP. If a string value includes characters that cannot be represented in UTF 8 then the string value will not be accurate.

PL SQL cursor types are treated as members of a CURSOR class and refcursor types are treated as members of a REFCURSOR class which are not shown in the illustrated embodiment.

Members of object type REF are not directly useable in PL SQL. They are dereferenced explicitly via SQL or UTL REF. Thus only the type info domain and an surrogate locator string are provided. The REF class contains no attributes in the illustrated embodiment but attributes may be added in other embodiments. A SQL ref type is treated as a member of a REF class defined using 

An exception type is not used internally in PL SQL. An exception class is provided so that a user may set breakpoints on exceptions and for exception reporting when an exception event occurs or when a ThreadReferenc.Stop is applied. The EXCEPTION class is defined using 

A user exception class is provided to match any user defined exceptions. The EXCEPTION USER class is defined using 

A DBMS exception class is provided to match any DBMS errors. The EXCEPTION DBMS class is defined using 

Java classes appear through JDWP for each PL SQL composite type whether declared in PL SQL or formed with an SQL create type statement. The  type attribute of the class holds a value that provides information about the category of the type. The category is selected from a list that includes record object varray nested array and indexed table constructs well known to PL SQL programmers. Attribute names for record and object types are based on the type declarations in the PL SQL code with a leading underscore to reduce the likelihood of name collisions

Varrays and nested tables are seen through JDWP as a class having a Java array. Varrays include an attribute named  limit indicating a declared maximum size but nested tables do not. The  type attribute is set either to varray or nested table . In the illustrated embodiment the implied Java class includes a method named newElement which can be invoked with ObjectReference.InvokeMethod to add rows to the collection. The method is a function that returns a value of the number of rows in the array after adding the row. No provision is made for deleting elements. For example a varray declaration in a PL SQL procedure ProcP of schema SchemaB given by

Indexed tables are sparse arrays that are seen through JDWP as a nested class defining each element plus a wrapper class having a Java array of the elements. Each element includes a key and a value. PL SQL does not allow indexed tables to be atomically null so no null information is used in the wrapper class. The value in an element may be null but the key may not. In the illustrated embodiment the implied Java class includes two methods named newElement and deleteElement which can be invoked with ObjectReference.InvokeMethod. The method newElement adds an element at the specified key unless an element with that key already exists. The method deleteElement deletes an element at the specified key unless the element with that key does not exist. For example an indexed table declaration in a PL SQL procedure ProcP of schema SchemaB given by

Associative arrays are handled similarly. One difference is that the  key field is as declared by the user s code. Another difference is that the value of the  type field is associative array. 

An SQL statement appears through JDWP as the execution of a method APDBMS.SQL.execution. The internal steps and variables of this method are not further broken down into frames and are not available for setting breakpoints or values for variables. Only breakpoints on method entry and method exit are accepted. This method appears to have two local variables  statement and  binds . The  statement variable is of type java.lang.String and includes the text of the SQL statement being executed. However if the debugger client does not have sufficient privilege to see the statement the variable contains another value such as the text not available. The  binds variable is an array of elements. Each element appears to be an instance of a Java class that has two attributes  name and  value. The  name attribute is of type java.lang.String. The  value attribute is of the type object. The variables are read only attempts to set values for these variables are ignored.

As depicted in first second and third virtual machines respectively reside on the database server host for running the modules stored in the database. A unifying process executes on the database server host to unify the debugging information from the first second and third virtual machines . In some embodiments the first virtual machine is an instance of a Java virtual machine for running Java modules stored in the database the second virtual machine is an instance of an SQL virtual machine for executing SQL statements stored in the database or generated by one of the other modules and the third virtual machine is an instance of a PL SQL virtual machine for executing PL SQL modules stored in the database. The unifying process includes debugger client interface and virtual machine interface . The first second and third virtual machines include virtual machine interfaces respectively.

Also depicted in is a fourth virtual machines residing on the application host for running the modules for the application. A second unifying process executes on the applications host to unify the debugging information from the first unifying process and the fourth virtual machine . In some embodiments the fourth virtual machine is another instance of a JVM for running Java modules. The fourth virtual machine includes virtual machine interface . The second unifying process includes debugger client interface and virtual machine interface

The unifying processes serve to generate a coordinated picture of debugging information that is presented to the user by the debugger client . The first unifying process coordinates the debugging information for virtual machines and the second unifying process coordinates the debugging information for the first unifying process and the fourth virtual machine .

According to one embodiment when a routine being executed by the fourth virtual machine calls a stored procedure on the database server the network address of the second unifying process is conveyed to the first unifying process . Then the debugging information sent from the first unifying process is forwarded to the second unifying process instead of to the debugger client . For example the information is passed during step described above and in step the unifying process connects to the second unifying process instead of to the debugger client .

Although shown residing on the application host the use of a network protocol for the interfaces and allows the second unifying process to reside anywhere on the network. Also the use of a network protocol for the interfaces and allows the first unifying process to reside anywhere on the network.

Furthermore although only two unifying processes are shown in each occupying a different level in a hierarchy in other embodiments multiple unifying processes may be deployed at two or more levels of a hierarchy.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . A computer readable storage medium includes volatile and non volatile storage media. Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

