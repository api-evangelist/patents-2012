---

title: Data infrastructure for providing interconnectivity between platforms, devices, and operating systems
abstract: The present invention teaches methods for using a point-and-click interface to allow developers to create visual relationships between APIs and GUI components. Further, the present invention uses interactive machine learning to learn from developer actions. The present invention will assist developers by providing recommendations on how their application should compile to a target platform. Developers may then configure their app and its connection to APIs (device and remote) directly from the present invention's point-and-click interface. The invention also teaches methods for visual recognition of data structures to allow sections of data to be targeted by a system that matches targeted data to a GUI component. The visual recognition system allows any type of data to move between systems and have required protocols applied at run time instead of during development in the way traditional software works.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09614901&OS=09614901&RS=09614901
owner: Nimblestack Inc.
number: 09614901
owner_city: New York
owner_country: US
publication_date: 20120801
---
The present application claims priority to U.S. Provisional Application No. 61 513 770 filed Aug. 1 2011 which is hereby incorporated by reference herein.

The present invention relates to an automated process of adding GUI Graphic User Interface components to existing APIs Application Programming Interface and future APIs datasets documents web sites and media.

Mobile and desktop software are created with a set of local APIs which perform a series of tasks complex computation delivery of device capabilities algorithms artificial intelligence and graphic acceleration. Local APIs connect software with hardware. Local software then accesses web based APIs to connect web services to other web based APIs. Through this method data can be accessed by external service providers. Once created web based APIs may be scaled in their range of functions and uses by making them available to developers. Developers in turn use web based APIs to develop a range of functions for websites and mobile software applications.

User access to web based APIs allows groups or individuals to have a meaningful interaction with data and because of this they have become a popular way of distributing services. Web based companies like Salesforce and Amazon have paved the way for consumer oriented APIs and companies like Facebook Skype and Foursquare have introduced social communication and location oriented APIs into the mainstream. This trend has been made popular by rapidly advancing smartphone innovations and these innovations have given web based APIs a portable point of entry. This has been an important development because it has given individuals ready access to the vast range of data and functions APIs can offer.

API popularity among developers has created a change in the tech industry whereby online services have evolved from strictly information and commerce into services which address a range of social and physical data collection. The most secure and efficient way of delivering new services across all connected devices has been through the invention and adaptation of web based APIs.

The current library of API are increasing exponentially. This increasingly vast API universe and the ability to mix and match functionality has given birth to what is commonly known as a Mashup. Mashups are a way for developers to cherry pick useful functions from web based API services. This is because API functions are features of a total software package. For example Twilio offers telephone services over the web but these APIs are not meaningful until they are combined with location based services and customer relationship software. Twilio is a very popular API service for developers but it only represents a fraction of the kind of APIs that are currently available and might become available in the future.

Web based APIs also point to a trend in software creation away from the standard software development model. This trend became more apparent when companies like Kinvey Parse and StackMob moved the database layer of software design into a web based API service.

In the near future it is conceivable that all software development will rely less on local APIs and more on web based APIs. When this happens all software will be constructed using a combination of functionality delivered via web based APIs. Eventually developers will no longer need to build bespoke software. Instead engineers will program new software functionality into a cloud computer and sell this functionality through an API. With this ecosystem in place multiple APIs can be combined to create new combinations of useful software.

Evidence of this interconnected software development paradigm can be found on Apple s iCloud service. Currently this service only supports file contents and device settings between multiple iOS devices but it is reasonable to infer that Apple has every intention of supporting its own system so that it does a great deal more than it does at present. However there is no logical reason why this service approach should be restricted to Apple.

Cross platform compilation is the term given to the compiling of software from a single code base that can then be deployed to multiple platforms or operating systems. To achieve successful cross platform compilation it is critical that the machine code produced meets the requirements of the targeted system. This can be a challenging task because of the differences between the existing platform software hardware and CPU bits. These problems are further complicated when producing games because the cross platform compiler must also account for graphics processing.

The set of devices running a specific platform iOS Android etc. has multiple operating system versions different hardware and different screen sizes. This raises a problem for which two common solutions have emerged. The first solution is to embed a web browser in a native wrapper which allows developers to program applications using HTML javascript and CSS. The second solution is to use a cross compilation IDE that allow developers to compile apps to multiple platforms and devices. The former is more scalable and easier to use while the latter delivers to fewer platforms but produces higher performance applications.

The problem of cross platform display differences usability implementations has pushed developers to target a single platform. Many companies have tried to build universal tools for developers that allow them to build once and deploy to all platforms. The complexity of an ever growing number of operating systems the operating system versions and OEM modified versions fragment the market to the point where cross compilation becomes a futile task. Many cross compilers have gone out of business while others continue to struggle to deliver applications to 2 or 3 different operating systems. The best of breed in this class Mono and PhoneGap have managed this task more thoroughly than any of their predecessors and competitors. Still they only fully support 4 platforms. As the number of platforms they support grows so does their code base making their software difficult to scale. Handling incoming data executing on it and making it meaningful without needing custom code is nearly impossible.

The present invention seeks to solve this cross platform compilation trade off by using interactive machine learning to learn from developer actions. The present invention will further assist developers by providing recommendations on how their application should compile to a target platform.

To address the problems and limitations noted above a method for using a point and click UI to allow developers to create visual relationships between APIs and GUI components is provided. Developers may then configure their app and its connection to APIs device and remote directly from the present invention s point and click UI.

According to a preferred embodiment the learning machine of the present invention will preferably use a customized Bayesian method to target developer configurations for standardization and to evaluate application logs. These two streams of evidence will preferably allow the learning machine to estimate accurately its own confidence level that a targeted configuration should be released.

The present invention is a universal platform to connect APIs and combine them into meaningful software. Without programming it can accelerate these trends in software development. The present invention does this by providing a Taught Data Translator TDT to developers. According to the present invention the TDT is a point and click interface that allows developers to place data in designated containers for display. According to a further aspect the present invention uses a skeleton component architecture which allows developers to fill with meaningful data by building visual relationships between the components and the incoming data. Generality is maintained by teaching the TDT what the data means instead of assuming the data follows a standardized format. The presentation invention preferably uses learning algorithms instead of code customizations to scale the TDT across all data types.

According to a further aspect the present invention preferably will use TDT along with a Taught Platform Compiler TPC to compile native applications. The TPC will allow developers to teach applications how to connect to device APIs for a targeted platform. Developers will register device APIs and configure the connections directly from the present invention. Thereafter those device APIs may then become available for use in the developer s application. Further in accordance with the present invention the TPC will preferably learn from developer configurations and adapt to deliver the ideal implementations for every platform.

The present invention is preferably configured as a lightweight wireframe wrapper that connects native usability and performance to any API. Applications built with the present invention will preferably scale and remain functional across all devices. Even in less capable WAP browsers the applications using the present invention can function as basic websites.

According to a further aspect of the present invention algorithms are provided to automate the following processes for developers remote communications data handling REST API creation GUI creation and cross platform deployment.

Preferably the present invention is a code less environment so no code is downloaded or executed at run time. The skeleton architecture of the present invention preferably allows it to be configured Just In Time using a Natural Machine Language NML document NML documents are simple text files XML that can be securely downloaded to any device. There is nothing executable in a NML document so it brings no harm to the device it is stored on. With the present invention the application update lifecycle for any mobile app is use point and click UI to update app configuration push update to users and then the updated app goes live. With a point and click editor software created using the present invention can easily be updated for new services as they are added.

The object of the present invention is to overcome the shortcomings disclosed in the prior art. The accompanying drawings which are incorporated in and constitute part of the specification illustrate various embodiments of the present invention and together with the description serve to explain the principles of the present invention.

According to the present invention interactive machine learning algorithms are provided which are designed to learn from developer actions. Based on specific data the algorithms of the present invention will provide recommendations on how their application should compile to a target platform. According to a preferred embodiment the present invention preferably consists of three parts a Point and Click UI a Device API wrapper and a learning machine.

The point and click UI may allow developers to create visual relationships between APIs and GUI components. Preferably developers may configure their app and its connection to APIs device and remote directly from the point and click UI.

The device API wrapper is preferably configured as a custom lightweight performance optimized wrapper which connects directly to device and remote APIs. Preferably the wrapper scales easily because it uses Natural Machine Language NML to adapt to APIs as they evolve.

As further shown in a client device may include any internet connected device such as a smart phone television refrigerator etc. . As shown memory in the device is anticipated to be used and databases created by the application are stored in memory . The exemplary architecture as shown further includes native application running on the client device a socket switcher that manages socket connections between the native application proxy protocol servers and an NML parser coded in the native language of the client device that matches NML tags to their related GUI components for display. The NML is preferably delivered through a socket stored on the device and transported between the native application and a web server . As further shown in the exemplary architecture further includes a virtual computing environment that scales the size of its infrastructure automatically to the needs of the system running on it a web server running on a virtual machine a software layer API that allows for remote communications to remote client devices a system that generates NML from developer input that is then sent to a remote client device and parsed in a native application a database that stores user information for the web server a memory cache to store NML files used for communication between remote applications and a web server historical documents saved by the NML generator a remote messenger that accepts requests from the NML generator and manages authentication and connection to all remote data sources servers that convert NML to data of a specific protocol for delivery to remote client devices an NML parser extracts the data to convert and the remote data source information from the incoming NML sent from the remote messenger an embedded remote messenger the same as except embedded in an application used for all remote communication and sockets for the proxy server and a remote data source .

With reference now to an exemplary method in which the system pulls the NML from the local database converts it to XML and assigns GUI values based on NML targets will now be discussed. As shown the exemplary process begins when the system pulls the NML from a local database . The system thereafter parses the NML to extract remote data source information . Preferably all relevant remote data source API information is extracted from the document and the API data extracted are references to full API data sets in the database. Those full data sets are then pulled from a database of NML files and the system configures itself to connect successfully to the API . The API data is then preferably taken from the files and automatically verified when the system attempts to retrieve full data sets from the database without interruption and the system handles the responses as they come in. Preferably a socket from the client application is then opened to prepare a persistent connection to the remote data source . Once the socket makes a persistent connection with the remote data source and the incoming data is received parsed . Thereafter the system connects synchronously to the remote source and then collects all data returned from the remote data source. That data is then stored in a database . Preferably the data may be stored on a database on a local server . The system will then evaluate if the data is returned from the remote data source as an XML protocol . If the data is not XML it is converted to XML . Data targeted by the NML is assigned to the GUI component based on the structure outlined in the NML document . The GUI is displayed by the system .

With reference now to a flowchart diagram describing a persistent socket will now be discussed. As shown in a persistent socket connection with a local server is opened and the system evaluates whether or not the socket is sending or receiving data . Then a request for data is sent to the server and the Socket sends a stream of data to the server . As further shown the server then attempts to find NML already associated with the requested sent data . In the Persistent Memory that stores cached NML and data documents for rapid retrieval the system then evaluates whether or not there is already a document in memory . If there is nothing in memory for this data set the system will create the NML for the data and chunks of data are generated to stream back to the requesting application . Accessing the Persistent Memory store of cached chunks the system will evaluate if there is already a document in memory and then pull all the chunks from memory . The data chunks may then be streamed back to the server in rapid fire succession .

With reference now to a flowchart diagram describing how an application goes from a simple NML document and is displayed as an application GUI and will now be discussed. As shown in the application NML that resides on the device is parsed. The necessary GUI components are configured based on the NML description . This includes preparing the GUI components for data injection and display. It also involves extracting the remote data connection information. Preferably the GUI components are connected to the remote data source using the developer credentials . Thereafter all data is collected from the remote source and prepared for transformation and NML targeting . The data is then sent to a database on a local server . In the Persistent Memory storage of current NML documents the system may evaluate whether there is a document already in memory and whether the document is XML . If not the document is preferably converted to XML . Data targeted by the NML is then assigned to the GUI component based on the structure outlined in the NML document and the GUI is displayed .

With reference now to a flowchart diagram displaying the conversion from a data document to a linear matrix grid of points will now be discussed. As shown in a database of previous versions of data used in the application is formed from data gathered from the historical documents for the application . The documents are visually compared to find differences in the most current and the differences are mapped into a linear matrix . Since every document represents a layer in a physical space the data can be treated as physical objects. The multi dimensional linear matrix of data changes is then stored in a database .

With reference now to a flowchart diagram outlining the invention used to discover differences in historical data documents in relation to a data source and its most recent document will now be discussed. As shown in a database of previous versions of data used in the application and the historical documents for the application are gathered . A linear matrix grid for the documents is then generated and the visual differences in data history are parsed by viewing all documents in history overlaid by each other . The system can then use visual recognition to target points of difference. The changes if any are verified to be new by validating the differences against the most current document and stored in an NML database . All differences in the documents are then mapped to a multi dimensional grid known as a Matrix . Points in the Matrix preferably represent the differences in the documents. One document represents a dimensional layer in the Matrix. Accordingly if 5 documents are being compared a 5D Matrix is created to track all differences in those 5 documents. After the Matrix is saved Visual Pattern Recognition technology may be used to recognize the differences in the Matrix . Data is then updated where needed as found by the Matrix and the developer is notified of any changes .

With reference now to an exemplary process for processing NML data will now be discussed. As shown in NML is gathered from NML database and the NML is passed onto the Taught Data Translator . The system thereafter will preferably evaluate whether or not the NML connects to a remote data source . If it does connect to the remote data source then all data is collected from the Persistent Memory storage . Data targeted by the NML is then assigned to the GUI component based on the structure outlined in the NML document . If the system can make a recommendation based off data stored in the Persistent Memory storages then a recommendation is made to the developer based on a custom mathematical algorithm . Learning machines learn what developers build and suggest the best components to the developer depending on popularity lack of errors overall use system wide and a number of other variables and constants. The recommendation is verified with the Developer . If the developer accepts the recommendation the recommendation is added to queue for rank evaluation so the system learning machines can parse it and readjust its rank and the system continues to build the GUI .

With reference now to a part of the development process where learning machines make recommendations to developers about the best GUI to use for their application will now be discussed. As shown in the NML is parsed to extract device API and remote data connection information from the NML database . The Device API Manager is then connected to validate the device API information and the device APIs as defined by the NML are connected . The data from device API is then returned to Device API Manager . The data targeted by the NML is assigned to the GUI component based on the structure outlined in the NML document . The system evaluated may then make a recommendation based on data from the Persistent Memory storage . If it can than a recommendation is made to the developer based on a custom algorithm . Learning machines learn what developers build and suggest the best components to the developer depending on popularity lack of errors overall use system wide and a number of other variables and constants. The recommendation is verified with the Developer . If the developer accepts the recommendation than the Recommendation is added to queue for rank evaluation and the system continues to build the GUI .

With reference now to a Pixel Data Transformer to collect and parse the pixel data to generate NML tags for every pixel in a screen shot to create a matrix which can be stored or streamed will now be discussed. As shown in media from the device is sent to a web server to generate screen shots of the media . If it is a video it will generate screen shots for every frame. Pixel data is preferably collected from every screen shot . The pixel data is then parsed and generates NML tags for every pixel of the screen shot from the NMP database . Pixels are preferably treated by the system as a physical space on the screen. The system preferably targets the physical space the pixel takes up as opposed to simply reading its pixel value. According to a preferred embodiment a grid may be drawn over the screen which is the system s frame of reference. If the medium is video than a multi dimensional matrix may be created to store all the pixel data. In this matrix a screen shot is one dimension and a pixel is a grid point in that dimension of the matrix. If the media does not need to be streamed back to the requesting application than the generated NML is stored for later use . If the media needs to be streamed back to the requesting application than the NML is streamed back to the application .

With reference now to a flowchart diagram outlining the flow of data from an application through the methods outlined in will now be discussed. As shown in a socket connection is required by the application based on the API information in the NML database is initiated as an exemplary first step. Thereafter the application NML is parsed from the NML database . All socket information is then extracted from the NML and all protocol information is then extracted . Thereafter a protocol request is preferably sent to the web server and the web server then returns information regarding whether the proxy server and the application can connect in order to use the requested protocol . Once the application is connected to proxy server a persistent socket is opened in the connection with the proxy server and data is streamed through the connection.

With reference now to a flowchart diagram outlining a preferred method as outlined in will now be discussed. As shown in a persistent socket is initially opened and the incoming data stream of NML is parsed . The data streaming from the NML is then verified against a database and the targeted information is extracted . The targeted data is converted into a proxy server specific protocol and a connection is made with a remote data socket . Data is then streamed through the remote data socket and a response stream is received back from the remote data socket . The response data is then converted to XML . The XML is then converted to NML based on NML data configuration and the NML is split into individual tags as packets which are then compressed . The compressed packets are then preferably streamed back to the application one at a time in rapid file succession .

With reference now to API data visualized based on its hierarchy will now be discussed. As shown in a representation of a GUI list is populated with either an XML tag name or a tag s attribute . A value taken from the ID tag is assigned to each tag or tag attribute. As further shown in a transition from a list to another list or from a list to a list item s value is indicated by the arrow. If the list item leads to a value and not another list then the item will be displayed as a selectable object such as a button or check box. Multiple category tags may be combined into a list of their own . Each category tag then leads to a list of its attributes and its value. An example of a list of attributes and only one value is shown here. The value item will display as a selectable object such as a button or check box. Another example of a value of an attribute or XML tag . Other examples and variations may be used as well.

With reference now to three popular data formats having similar hierarchies will now be discussed. As shown in three popular data formats may include RDF a format for open data based on XML a generic object a type of Object is similar to a PHP Object or even a JSON Object and a generic XML format .

With reference now to a list depicting how any data can be visualized based on its hierarchy will now be discussed. As shown data for the list is preferably taken from the designated tags . Accordingly as shown data in the example list may be taken as shown from tag one tag two tag and further from three tag .

With reference now to a flowchart for application creation using the present invention will now be discussed. As shown in the developer would create a List in where each list item would lead to a display page. This process creates an API mapping file. First the developer chooses the component type in this case a List . Thereafter the developer then maps each of the List s properties to a value . This shows a list of available data values. This step is repeated until all properties are mapped to a value. A list of values is then taken from a data source . A choice of display components is used to display the data for each list item . This step is only necessary when creating a list such as a list of properties for the display component . Each property will thereafter need to be mapped to a value. A list of values is then taken from a data source .

With reference now to an Automatic Discovery of Remote Services and APIs ADRS API will now be discussed. An Automatic Discovery of Remote Services and APIs ADRS API is an API definition search engine. As shown in a workflow diagram shows how ADRS API handles a request to search a domain. As shown an application preferably requests an API connection . Thereafter a check is preferred to determine if the request contains a URL for the API . Preferably if the request API is described in the database and a check is made for an API definition file thereafter a web page is loaded from the URL and the page is crawled to extract all URLs related to the API or that have the same domain name . Thereafter the system checks the API method and method parameter references on the page and extracts API definitions from the page . Thereafter the descriptions are saved in the database and the definitions are saved to an API definition file . Thereafter the system preferably checks if the request API is described in the database and checks for an API definition file . Finally the configuration is sent to the requesting Application .

While the above descriptions regarding the present invention contain much specificity these should not be construed as limitations on the scope but rather as examples.

