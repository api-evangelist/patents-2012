---

title: Virtual surface rendering
abstract: Virtual surface techniques are described. These techniques support the use of initialization and batching of updates, use of updates and lookaside lists, use of gutters, blending and BLT operations, use of surface optimization techniques such as push down as well as enumeration and clumping, mesh usage, and use of occlusion management techniques.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09235925&OS=09235925&RS=09235925
owner: Microsoft Technology Licensing, LLC
number: 09235925
owner_city: Redmond
owner_country: US
publication_date: 20120531
---
The variety of computing device configurations continues to increase. From traditional desktop personal computers to mobile phones game consoles set top boxes tablet computers and so on the functionality available from each of these configurations may vary greatly.

Consequently traditional display techniques that were developed for one configuration may not be as well suited for another configuration. For example display techniques that were previously utilized for devices having significant memory resources may be ill suited for devices having fewer resources.

Virtual surface techniques are described. These techniques include support of initialization and batching of updates use of updates and lookaside lists use of gutters blending and BLT operations surface optimization techniques such as push down as well as enumeration and clumping mesh usage and occlusion management techniques.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Virtual surfaces may be used to allocate and manage surfaces for rendering of visuals. The virtual surfaces for instance may be used to overcome limitations of hardware such as to manage rendering of a webpage that is larger than memory that may be allocated by the hardware for rendering of the visuals such as to manage a large webpage immersive application and so on.

Virtual surface composition and update techniques are described herein. In one or more implementations techniques are described to manage surfaces for rendering. This includes techniques to support initialization and batching of updates as further described in relation to use of updates and lookaside lists as described in relation to use of gutters as described in relation to blending and BLT operations as described in relation to surface optimization techniques such as push down as described in relation to as well as enumeration and clumping as described in relation to mesh usage as described in relation to and occlusion management techniques as described in relation to .

In the following discussion an example environment is first described that is operable to perform virtual surface techniques described herein. Examples procedures are then described which are operable in the example environment as well as in other environments. Likewise the example environment is not limited to performance of the example procedures.

The computing device also includes an operating system that is illustrated as being executed on the processing system and is storable in memory . The computing device further includes applications that are illustrated as being stored in the memory and are also executable on the processing system . The operating system is representative of functionality of the computing device that may abstract underlying hardware and software resources for use by the applications . For example the operating system may abstract functionality of how data is displayed on the display device without the applications having to know how this display is achieved. A variety of other examples are also contemplated such as to abstract the processing system and memory resources of the computing device network resources and so on.

The computing device is also illustrated as including a composition system . Although illustrated as part of the operating system the composition system may be implemented in a variety of ways such as a stand alone module as a separate application as part of hardware of the computing device itself e.g. a SOC or ASIC and so on. The composition system may employ a variety of techniques to render visuals such as to expose functionality via one or more application programming interfaces APIs for use by the applications to render visuals.

For example one such technique may be based on an object called a swap chain which may leverage an array of buffers representing a bitmap. One of the buffers for instance may be used to present data on the display device at any one time and therefore may be called the onscreen buffer or front buffer. The other buffers are made available to an application for rasterization off screen and therefore may be referred to as an off screen buffer or back buffer. 

An application may make a change to what is displayed on the display device in a variety of ways. In a first such technique the application can redraw one of the back buffers and flip the contents such as by making one of the off screen buffers the onscreen buffer using a pointer and vice versa.

In a second such technique buffers of different sizes may also be leveraged. For example the composition system may leverage a first buffer as an onscreen buffer. The composition system may also leverage a second buffer that is smaller than the first buffer as an off screen buffer. Therefore when an update is to be made to the content the update may be rasterized to the second buffer. The update may then be copied to the onscreen buffer e.g. using a blt. In this way resources of the computing device may be conserved.

The composition system may also be configured to support virtual surface techniques. These techniques may be used to assist developers of the applications to reduce resources of the computing device that are used to render visuals. This may include use of virtual surfaces thereby enabling applications to break a surface of visual data into tiles and then render the tiles ahead of time. Other implementations are also contemplated in which tiles are not used to portion the surface e.g. the application specifies a size as further described below.

A virtual surface may be configured as a collection of one or more logical surfaces . The logical surface is representative of an individual surface as seen by the application and may be associated with one or more visuals. The logical surface for instance may be configured as tiles having a fixed size and a plurality of which may be arranged in a fixed grid although it should be readily apparent that a variety of other instances are also contemplated in which tiles are not utilized in a fixed size. For example a size of the tiles may be specified by an application that wishes to render a visual and therefore the size of the tile in this instance may be set by the application itself which are also referred to as chunks in the following discussion.

The virtual surface may be used to represent an area that is larger than an area represented by a texture. For example the application may specify a size of a virtual texture at creation time. The size establishes the boundaries for the virtual surface . The surface can be associated with one or multiple visuals. In one or more implementations when a virtual surface is first initialized it is not backed by actual allocations. In other words the virtual surface may not hold bits upon initialization but may do so at a later point in time e.g. upon allocation.

In the following discussion a visual may refer to a basic composition element. For example a visual may contain a bitmap and associated compositional metadata for processing by the composition system . A visual s bitmap can be associated with a swap chain e.g. for dynamic content such as video or an atlas surface e.g. for semi dynamic content . The two presentation models may be supported in a single visual tree that is supported by the composition system .

For semi dynamic content an atlas may serve as the updating model for the visual s bitmap and may refer to an aggregate layer which may include a plurality of layers to be rendered although a single layer is also contemplated. The visual and its property manipulations e.g. offset transform effect and so on as well as the methods to update the visual s atlas based bitmaps BeginDraw SuspendDraw ResumeDraw EndDraw are exposed via application programming interfaces whereas the atlas layer size tiles size packing compaction management of bitmap updates may be hidden from the application .

A swap chain refers to a series of buffers that may flip to the screen one after another such as by changing pointers. Accordingly a flip mode is a mode by which a swap chain technique is used to make an off screen buffer an onscreen buffer e.g. through the use of swapping points between the off screen and onscreen buffers. However a blt mode refers to a technique in which a runtime of the composition system issues a blt e.g. bit block image transfer from an off screen buffer to an onscreen buffer which may be used to update the onscreen buffer.

As previously described when a virtual surface is first initialized in one or more implementations it is not backed by actual allocations. In other words it does not hold any bits. The composition system may perform allocation of tiles i.e. composition surface objects once the application starts updating the surface. The application can update the virtual surface via a variety of operations such as begin draw suspend draw resume draw and end draw API calls to respective operations. The mapping may be determined by an internal algorithm of the composition system and is not made visible to the application in one or more implementations.

Additionally the composition system may expose functionality via APIs to enable applications to resize and trim a virtual surface . For example a resize operation may be used to change the boundaries of the virtual surface . This means that new updates and or allocations are to fall within the boundaries set by the new size. The application may also use this method to inform the composition system that a region of the virtual surface is no longer being utilized e.g. not valid and thus is available for reclamation. If the resize results in shrinking the area the application is no longer be able to make updates to the regions outside of the new boundaries through management by the composition system .

Additionally the resize operation may be initiated by the composition system in response to receipt of indication of the operation in one or more implementations. For example the composition system may implement resize updates upon receipt of the indication without waiting for the application to call commit. For example an application may call Resize 0 0 Resize INT MAX INT MAX and Commit In this example the application has caused the content to be discarded on the first resize so the second resize does not have an effect even though it was called before Commit In this case the display device does not display content as none is available for display.

A trim operation may be used to describe a region of a virtual atlas to the composition system that is requested by the application . Thus the trim operation may be performed without resizing boundaries of the virtual surface . However it does tell the composition engine which logical surfaces are to be allocated at present an example of which is described in relation to the following figure.

As a page that is represented by the virtual surface is scrolled the application may now cause the last six tiles to be rendered as shown in the second stage . Accordingly the application may call trim to indicate that the region defined by the last six tiles is currently being used and thus the rest of the content is not currently being utilized. The composition system may then choose to recycle the logical surfaces that originally represented the first 6 tiles.

The composition system may also expose APIs of to create and delete logical i.e. physical and virtual surfaces as well as to make updates to the individual surfaces. The composition system may enforce the region to be updated by the application to avoid extraneous visuals when drawing outside of an updatable area.

User interfaces such as touch and image capture based manipulations allow users to scroll pan and zoom rapidly across a multitude of displays of user interfaces on slates phones large scale TV projections and so on. In most cases pre rendering of the entire content and keeping it up to date as it animates and changes can be prohibitively expensive and indeed may not even be supported by hardware of the device. Instead parts of the content coming into the viewport may be rendered and cached intelligently e.g. rendered ahead speculatively before user manipulation brings it into the viewport and discarded from cache when the viewport moves away to reduce used resources as described above.

In order to provide desired responsiveness to the user composition and rendering may be performed separately by the composition system . This is illustrated through incorporation of a composition engine controller and renderer by the composition system . In one or more implementations these components of the composition system may be executed asynchronously. In this way pre rendered content can be panned zoomed by a controller that is responsive to user inputs and composition engine while the renderer continues to render.

As previously described the composition system may employ one or more virtual surfaces . Use of a virtual surface allows caching and composition of already rendered content. Renderer updates and trims areas on the virtual surface may be performed based on a speculative rendering policy while the controller and composition engine are used to transform the virtual surface . This transformation may be performed based on user input to generate updates to a user interface based on areas of the virtual surface that have rendered content and are in the viewport. The composition engine may be configured to compose multiple virtual surfaces and or visuals at a time.

In one or more implementations the composition system may be configured to employ the logical surfaces as fixed or mixed size tiles that are used as front buffers for composition. When the renderer wants to update a part of the virtual surface the renderer may perform the rendering into a separate update surface or render directly to the tile surfaces. If using a separate update surface the contents are copied from the update surface to the front buffer tiles when finished drawing. Tiles may then be released when the renderer trims away the valid content from the tiles.

This implementation however may result in structural tearing as content that has changed is composed on the screen with out of date content. Additionally seams between tiles or chunks of regions that are updated on the virtual surface may be generated due to gutters and sampling e.g. bilinear or T junctions as well as cause excessive CPU and GPU usage to deal with gutters multiple overlapping updates and complex valid regions. Further excessive memory usage may be encountered due to dynamic content changes or content as manipulated by the user. For fixed mixed size surface per tile approaches memory waste may be encountered for larger sized tiles due to unused portions of the tiles CPU GPU waste may be encountered due to rendering processing updates for smaller tiles and rendering them at composition time and CPU GPU copy costs may be encountered from update buffers to front buffers if separate update buffers are used. Therefore a balancing may be performed between a variety of considerations in implementation of the composition system .

These considerations may include the following set of tenets for the user experience quality and performance when manipulating rich and or dynamic content that does not fit into the viewport. A first such tenet is referred to as visual responsiveness. This means that the virtual surface may be configured to feel like a real surface at the fingertips of the user and user manipulation. This may be supported through configuration of the composition system to respond to and track manipulations without perceived lag. Separation of renderer from the controller and composition engine may be used to support this tenet in a robust manner.

A second such tenet involves visual coherence. In this example as the surface is manipulated and dynamic content e.g. animations in it is updated the content on the display device does not show artifacts that interfere with the user s immersion or confidence. For example the content may be displayed without seams visible tearing or corruption parts of the user interface do not lag behind other parts to which they are to be attached and so forth.

A third one of the tenets involves visual completeness. If a user interface is visually complete a user rarely sees a filler placeholder pattern e.g. a checkerboard covering parts of the display device and if so this display is limited to relatively short durations. Additionally surface content updates do not visibly lag however this may not be guaranteed e.g. for open ended rich content on low powered devices across zoom levels. For example the more optimal and efficient it is for the renderer to update the virtual surface and the composition engine to compose it the more bandwidth the renderer has to further render ahead speculatively to achieve additional visual completeness.

A fourth tenet involves live surfaces. For this tenet animations videos and other dynamic content continue to play and execute during manipulations without stutter. This may be realized if the renderer achieves visual completeness and has bandwidth to implement the live surfaces. This may be supported by efficient updating and composing of the virtual surfaces .

The composition system may be configured to balance these tenets. In this way a comprehensive solution may be implemented that supports visual correctness and coherence as well as responsiveness for managing and composing virtual surface updates such that the renderer has sufficient bandwidth to ensure visual completeness and live surfaces.

The application may then specify visuals to be rendered to the virtual surface . Accordingly the composition engine may compose these visuals for rendering by the renderer to the virtual surface such as a car as illustrated. This may be performed through the use of tiles or chunks in which a size of the allocation is specified by the application.

At the second stage the renderer may receive instructions to update an area of the virtual surface such as a rectangular area of the surface. The interface between the renderer and the composition engine is such that the renderer may implement a plurality of updates e.g. which may include trim instructions changes to visuals creations or removal of visuals and so on across a multitude of virtual surfaces as well as transform updates on visuals that may have these surfaces as content. Examples of the updates include a visual configured as a cursor and a visual configured as a user selectable button.

In an implementation a commit operation may be called such that the plurality of updates may be rendered by the renderer e.g. updated as a batch. In this way the composition system may protect against rendering of incomplete updates. This allows the renderer to have coherent and consistent visuals displayed by the display device per the visual coherence tenet.

Additionally the controller that processes user input may update transforms e.g. for panning or zooming on the visuals directly on the composition engine based on user manipulations without going through the renderer . This aspect provides visual responsiveness even if the renderer is occupied for a relatively long period of time e.g. to process animations or other state changes for dynamic content and or rasterizing complex content on thin devices having limited processing resources.

Implementation of the virtual surface may involve providing the renderer with a surface and offsets into which the renderer can render. This surface may then be flipped in by the composition engine when the composition engine has picked up and is processing the entire batch of updates that have been committed to the renderer . This may be used to eliminate a copy operation that would otherwise be performed if a separate update surface was used for rendering of the update by the renderer .

The flipping also allows the composition engine ensure that each of the updates generated by the renderer in a single batch e.g. via the commit operation make it to the display device as a whole. Thus processing of partial updates may be avoided by the composition system .

Responsive to this request the composition system may allocate an area that is larger than the requested area which is shown as a second rectangle that includes the requested first rectangle . Therefore if updates of slightly different sizes are received subsequently this allows reuse of previously allocated surfaces.

The composition system for instance may maintain a lookaside list of surfaces that were previously allocated by the composition system . This may be used by the composition system to hoard memory for reuse of the surfaces and chunks of the surfaces .

These surfaces for instance may be maintained in memory of the computing device for surfaces that are no longer in use. Therefore upon receipt of a request by the composition system to provide a surface for an update the composition system may first examine the lookaside list to determine if any previously allocated surfaces are available in memory of the computing device that correspond to the request. If so the composition system may leverage these surfaces thereby improving overall efficiency of the system by not allocating a new surface. Additionally through allocating a larger size to the surfaces e.g. having more pixels than requested as previously described a likelihood that these surfaces are relevant to a subsequent update may be increased.

For example if updates of slightly differing sizes are received over a period of time this allows more reuse of previously allocated surfaces e.g. if the next update is for an area that is a couple pixels wider or taller. Thus instead of allocating a new surface the composition system may leverage the lookaside list of previously made available surfaces to locate a relevant surface. It should be noted that trims and other updates of parts of a surface may also be available.

This may be tracked through regions based on confirmed batches. If the update fits into an available part of an existing surface that also has other valid content that surface may be reused. This also reduces costs on the composition side by avoiding rendering from multiple different surfaces as each such transition incurs setup costs. A size of the lookaside list e.g. a number of surfaces maintained in the list and in memory of the computing device may be set based on historic peak use or a variety of other factors.

During this rendering another surface may be allocated at the second stage for performing an update. In this example the other surface is included within a same area of the display as the surface being rendered by the renderer . Thus the surface may be allocated and filled e.g. drawn to while the surface is being rendered. This surface may then be passed to the renderer for rendering e.g. responsive to a commit command as previously described.

At the third stage another update may be received for updating a user interface. In this example the composition system determines that the update involves a previously allocated surface through use of the lookaside list of e.g. surface from the first stage . Accordingly the composition system may use the surface that was already allocated to include an update . In this way the surface may be used without reallocating a new surface thereby saving resources of the computing device . A variety of other examples are also contemplated.

However neighboring pixels of an update positioned on an edge of the update may have values based on erroneous information. For example if neighboring pixels outside the update contain trash e.g. from other updates a rasterizer may sample from these pixels and thereby produce pixels with bad values which may look like seams when displayed by the display device .

One way to deal with this is to copy the row or column of pixels at the edges that may be in another tile clump surface over to neighboring pixels in the newly allocated surface of the update . However these additional copies can prove prohibitively expensive for processing resources of the computing device e.g. both for CPU and GPU resources of the computing device .

Accordingly in one or more implementations edges of an update are aligned with surface edges. A clamping operation is then utilized which causes a rasterizer to use a value of the pixel at surface edge when sampling the neighboring pixels which would fall outside the surface. This may be used to produce a reasonable trade off between cost and visual correctness even though a result may not be completely visually correct the result may appear reasonably correct to a user. In one or more implementations the gutter itself is not updated.

In some instances the update edge may not be able to be aligned with a surface edge. This may be due to allocation of a surface that is larger than an update. In such instances the row column of pixels at the edge of the update on the same surface may be copied to the neighboring pixels for a similar effect to the clamping behavior.

Similarly when trimmed and updated the gutters are not updated with the potentially new pixels that may be drawn in one or more implementations because they contain previously valid pixels that were displayed together with the currently valid pixels. This supports a tradeoff between correctness and performance that yields minimal visual artifacts in the general case that are disturbing to a user when viewed.

For example a technique is described to divide regions that are to be rendered from a surface into two parts blended and BLT d. This technique may be used to address instances in which updates are small and the resulting valid region on the virtual surface are relatively complex e.g. result in complicated meshes having numerous small source surfaces.

If the surface is premultiplied or transparent and not opaque or set to ignore alpha values then the surface is blended . This may be used to blend larger rectangular shapes with cleared and or fully transparent pixels where there is no content provided by the renderer. In some cases this becomes more optimal than processing and rasterizing with a complex mesh that outlines each of the paths edges of a complex shape.

This approach may also be used for gutters when the valid region is complex for an opaque surface. For example internal parts may be BLT d but pixels around the edges are blended such that neighboring pixels are cleared. Therefore accurate values may be achieved when the rasterizer samples from these pixels. In one or more implementations this technique is used for edges of the virtual surface and is not used for internal edges between tile clumps and surfaces making up the virtual surface.

Bits may be copied and parts cleared in order to ensure clump surfaces are allocated that are aligned to a tile size and content from previous surfaces that owned that tile is moved into the new surface. In one or more implementations this is not performed for parts that are to be updated by the renderer e.g. an update rectangle in the middle as shown in . If the surface is opaque after the update the pixels on the edges may be made opaque by blending i.e. to arrive at full opacity in the alpha channel of those pixels.

Each of the tasks of copying clearing and making opaque may be performed using regions that are made up of non overlapping rectangular stripes. Regions may be intersected form a union or subtracted. Further the non overlapping rectangular stripes that compose the region be enumerated. This allows efficient merging of various rectangles and regions into a single region and extracting the optimal set of resulting rectangles. For instance Win32 HRGN is a GDI construct that may be employed to leverage these facilities. These operations are used to identify merged and optimized sets of rectangles on which an operation is to be performed e.g. clearing or copying instead of determining what to do per each tile individually. This may be used to achieve significant efficiency in both CPU and GPU for performing these tasks and also allows a reduction in tile alignment size to relatively small values such as 32 32 or 16 16 thus reducing waste as previously described.

Trim requests from the renderer may be dealt with differently based on complexity of a valid region. In a typical case the valid region of a tile clump surface may be updated according to the trim request. However if the valid region is complex and the BLT blend technique is being utilized additional operations may be performed. For example parts of the valid region may be blended to be turned opaque because these parts are now located at an edge of the region. Another way to deal with this is to create new clumps for the tiles from which valid parts are removed. The tiles however may continue to have some valid parts remaining. For these tiles remaining valid parts may be copied from existing surface turned opaque and trimmed away parts may be cleared. These new clumps may be committed when the renderer commits the entire batch of updates e.g. due to a commit operation. This operation may be optimized using regions of rectangular stripes although other examples are also contemplated.

When committing a set of updates by the renderer trims and visual transforms e.g. resulting set of tile clumps surfaces and their valid regions may be communicated to the composition engine . The updates may be communicated with respective tokens that may be used by the composition engine to ensure any outstanding CPU GPU work for rasterization on these surfaces is complete. At this time additional techniques may be utilized to further improve efficiency examples of which are described in the following sections.

By tracking valid regions of the surfaces by the composition system allocations may be combined to improve resource utilization. For example rendering from multiple surfaces may be more resource intensive than rendering from a single surface.

In the illustrated example valid portions of the surface allocation are pushed down into the surface allocation . This is illustrated using a dashed box to indicate that valid regions from the surface allocation are now included in surface allocation . After the push down the surface allocation that included the update may be released thereby freeing portions of the memory of the computing device . Thus this technique may be used to combine surfaces without creating a new surface allocation by leveraging an allocation of one of the surfaces that was combined.

For example in some instances the composition system may be confronted with overlapping large updates in a current or previous batch of updates. This may cause allocation of a plurality of surfaces that include relatively small valid regions. Consequently the composition system may have allocated large surfaces but the relatively small valid regions may prevent these surfaces from being released.

However by pushing down valid regions from a first surface e.g. a newer smaller surface to a second surface e.g. an older larger surface valid regions from the first surface may be removed. This permits release of the first surface thereby freeing memory and reducing an amount of surface allocations that are managed by the composition system without involving additional surface allocations. In this way the renderer may be tasked with rendering fewer surfaces thereby improving efficiency of the composition system . Other techniques are also contemplated in which a new surface allocation is made an example of which is described in the following section.

The composition system for instance may be configured to address surface allocations and composition by reducing a number of surfaces that are setup as sources and rendered from for composing a display on the display device . This may be performed by enumerating an optimized set of rectangles in an overall virtual surface valid region. A clump may then be created for each such rectangle. If this results in a large number of smaller rectangles the blend BLT technique discussed above may be used. In this way larger rectangles may be achieved with areas of pixels that have been cleared that are to be appropriately composed by the composition engine .

When the composition engine receives an update batch for instance the engine may first determine the dirtied parts of virtual surfaces and visuals that make up a display tree that are to be updated. This may be performed to include explicitly calculating and communicating dirty regions from updates and trimming to the compositor e.g. even though the underlying surfaces or clumps may change e.g. push down or re clumping valid regions of same content may have carried over so no new dirty regions may have been generated. These rectangles describing the valid regions may be explicitly communicated per update trim operation. In one or more implementations the dirty region may be reduced to result in a fewer number of larger rectangles to avoid incurring a large overhead in setting up and executing a number of smaller render operations. One technique for doing this is to allow a maximum number of dirty rectangles. As new dirty rectangles are encountered these rectangle may be added to the list or merged e.g. form a union with the rectangle that results in the smallest area increase overall.

The composition engine has a number of options to compose the clumps surfaces of a virtual surface . For example since the composition engine is aware of valid regions of each clump the composition engine may start by skipping those clumps that do not overlap with a dirty region that is to be updated. If the visual contained in the virtual surface is pixel aligned a translation transform without utilizing the gutter techniques described above. This allows use of a simple BLT Blend for each rectangle in the clumps.

Instead of performing these operations one at a time the composition engine may create a triangle mesh out of the set of rectangles and cause the surface to be rendered using that mesh. For example a set of rectangles that have valid regions may be examined by the composition system . A triangle mesh may then be generated for the set of rectangles by splitting each rectangle into two triangles. However T junctions may be formed from the rectangles. T junctions may cause the triangle mesh to be rasterized with seams e.g. due to floating point or rounding error. Accordingly the composition system may instead process the set of rectangles to form a triangle mesh of non overlapping rectangles that does not include T junctions.

The generated mesh may be cached across composition frames and reused if the rectangles of the clump do not change. If there is a non pixel aligned transform but the transform solely includes translation the composition engine can still generate meshes for and render each clump on its own. However if there is a more complex transform the composition engine may process the set of rectangles to avoid T junctions to ensure correct rasterization without seams.

In order to do this each clump may register a respective set of rectangles with a mesh generator object managed by the composition system . As each coordinate is examined mesh generator functionality of the composition system may add one or more additional vertices on edges that have already been registered. Each registering edge may also have existing vertices in that range added to itself. The result is a set of rectangles for each clump that have additional vertices. These rectangles may then be broken down into a set of non overlapping triangles using these vertices. Thus in the case of a non simple transform the clumps may be rendered using these generated T junction free meshes as shown in triangle mesh .

For occlusion these regions may be accumulated across the entire virtual surface and used for occlusion detection by the composition engine . In one or more implementations the composition engine may enumerate through the registered occlusion rectangles to identify the parts that are occluded by opaque visuals closer to the user in a z order for display by the display device .

However breaking down rectangles to complex shapes through the occlusion pass may be expensive. In order to ensure that non overlapping rectangular stripes that make up a region fully occlude a rectangle that would be occluded by the entire region the composition system may utilize rectangular containment and intersection techniques.

An example of such a technique is shown in the example implementation of which is shown through first and second stages . At the first stage first and second rectangles are to be composed by the composition engine . However the composition engine may determine that a portion of the first rectangle is occluded by the second rectangle .

Accordingly the composition engine may be configured to reduce the checked rectangle if the occluding rectangle obscures an entire edge such that the result is still a single rectangle that has been reduced. An example of this is shown in the second stage in which the first rectangle is reduced such that it does not include the portion that is occluded by the second rectangle . Thus the edge of the second rectangle may be used to define a new edge for the first rectangle thereby conserving resources of the computing device . A variety of other examples are also contemplated.

The following discussion describes techniques that may be implemented utilizing the previously described systems and devices. Aspects of each of the procedures may be implemented in hardware firmware or software or a combination thereof. The procedures are shown as a set of blocks that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks. In portions of the following discussion reference will be made to the environment of and the systems and example implementations of .

Responsive to receipt of the request the surface is allocated by the composition system to have a size that is greater than the size requested to render the one or more visuals block . As previously described the composition system may be configured to hoard memory to promote reuse of allocated surfaces that are no longer valid. By making the surfaces larger than requested by the application the composition system may increase a likelihood that the surface will be of use again later.

Valid regions are tracked within the surfaces that are to be displayed by the display device block . The surfaces for instances may initially be configured to update a portion of a display. Over time however other surfaces may updates parts of that display further that were already updated. Accordingly parts of the surface may remain valid for display while other parts are not valid. The composition system may be configured to track this validity which may be used to support a variety of different functionality such as occlusion management surface resizing surface compaction and so on as further described elsewhere in the discussion.

A lookaside list is examined by the composition system to determine if a surface is available as allocated in memory of the computing device that corresponds to the received request and that does not include visuals that are valid for display by a display device of the computing device block . The lookaside list for instance may reference surfaces that are allocated in memory but no longer have valid portions e.g. due to later received updates.

Responsive to the examination that the determined surface is available the determined surface is made available for rendering of the one or more visuals block . The determined surface for instance may have been allocated a greater size than requested as previously described and therefore be relevant to a subsequent update. A variety of other examples are also contemplated.

The portion is removed from the surface block . This may be performed in a variety of ways such as by using an edge of the other surface to define an edge of the surface that is to be reduced thereby defining at least one new edge of the surface.

The surface having the removed portion is rendered along with the other surface block . In this way rendering of the portion that is removed from the surface may be avoided thereby conserving resources of the computing device .

A determination is then made by the composition system that a first valid region of a first surface is includable within an allocation of a second surface block . The first surface for instance may be configured as an update. Subsequent updates may then be performed that make portions of the update invalid other than the first valid region.

The first valid region is then pushed down for inclusion as part of the second surface block . This may including copying bits of the valid region to the second surface. After the copying the first surface may then be released thereby conserving resources in maintaining separate surfaces as well as improving efficiency of rendering operations through use of a smaller number of surfaces. Thus in this example a new surface is not allocated thereby saving resources of the computing device in making and maintaining the allocation. Other examples are also contemplated an example of which is described as follows.

An allocation is then calculated for a new surface that is usable to include valid regions from the plurality of surfaces block . The new surface for instance may be configured as a rectangle having bounds for inclusion of a plurality of valid regions. The new surface may then be allocated for inclusion of the valid regions from the plurality of surfaces block and the valid regions may then be copied to the new surface thereby enabling the composition system to free the originating surfaces. A variety of other examples are also contemplated of surface compaction by the composition system .

The example computing device as illustrated includes a processing system one or more computer readable media and one or more I O interface that are communicatively coupled one to another. Although not shown the computing device may further include a system bus or other data and command transfer system that couples the various components one to another. A system bus can include any one or combination of different bus structures such as a memory bus or memory controller a peripheral bus a universal serial bus and or a processor or local bus that utilizes any of a variety of bus architectures. A variety of other examples are also contemplated such as control and data lines.

The processing system is representative of functionality to perform one or more operations using hardware. Accordingly the processing system is illustrated as including hardware element that may be configured as processors functional blocks and so forth. This may include implementation in hardware as an application specific integrated circuit or other logic device formed using one or more semiconductors. The hardware elements are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example processors may be comprised of semiconductor s and or transistors e.g. electronic integrated circuits ICs . In such a context processor executable instructions may be electronically executable instructions.

The computer readable storage media is illustrated as including memory storage . The memory storage represents memory storage capacity associated with one or more computer readable media. The memory storage component may include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . The memory storage component may include fixed media e.g. RAM ROM a fixed hard drive and so on as well as removable media e.g. Flash memory a removable hard drive an optical disc and so forth . The computer readable media may be configured in a variety of other ways as further described below.

Input output interface s are representative of functionality to allow a user to enter commands and information to computing device and also allow information to be presented to the user and or other components or devices using various input output devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner touch functionality e.g. capacitive or other sensors that are configured to detect physical touch a camera e.g. which may employ visible or non visible wavelengths such as infrared frequencies to recognize movement as gestures that do not involve touch and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card tactile response device and so forth. Thus the computing device may be configured in a variety of ways as further described below to support user interaction.

Various techniques may be described herein in the general context of software hardware elements or program modules. Generally such modules include routines programs objects elements components data structures and so forth that perform particular tasks or implement particular abstract data types. The terms module functionality and component as used herein generally represent software firmware hardware or a combination thereof. The features of the techniques described herein are platform independent meaning that the techniques may be implemented on a variety of commercial computing platforms having a variety of processors.

An implementation of the described modules and techniques may be stored on or transmitted across some form of computer readable media. The computer readable media may include a variety of media that may be accessed by the computing device . By way of example and not limitation computer readable media may include computer readable storage media and computer readable signal media. 

 Computer readable storage media may refer to media and or devices that enable persistent and or non transitory storage of information in contrast to mere signal transmission carrier waves or signals per se. Thus computer readable storage media refers to non signal bearing media. The computer readable storage media includes hardware such as volatile and non volatile removable and non removable media and or storage devices implemented in a method or technology suitable for storage of information such as computer readable instructions data structures program modules logic elements circuits or other data. Examples of computer readable storage media may include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage hard disks magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or other storage device tangible media or article of manufacture suitable to store the desired information and which may be accessed by a computer.

 Computer readable signal media may refer to a signal bearing medium that is configured to transmit instructions to the hardware of the computing device such as via a network. Signal media typically may embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier waves data signals or other transport mechanism. Signal media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

As previously described hardware elements and computer readable media are representative of modules programmable device logic and or fixed device logic implemented in a hardware form that may be employed in some embodiments to implement at least some aspects of the techniques described herein such as to perform one or more instructions. Hardware may include components of an integrated circuit or on chip system an application specific integrated circuit ASIC a field programmable gate array FPGA a complex programmable logic device CPLD and other implementations in silicon or other hardware. In this context hardware may operate as a processing device that performs program tasks defined by instructions and or logic embodied by the hardware as well as a hardware utilized to store instructions for execution e.g. the computer readable storage media described previously.

Combinations of the foregoing may also be employed to implement various techniques described herein. Accordingly software hardware or executable modules may be implemented as one or more instructions and or logic embodied on some form of computer readable storage media and or by one or more hardware elements . The computing device may be configured to implement particular instructions and or functions corresponding to the software and or hardware modules. Accordingly implementation of a module that is executable by the computing device as software may be achieved at least partially in hardware e.g. through use of computer readable storage media and or hardware elements of the processing system . The instructions and or functions may be executable operable by one or more articles of manufacture for example one or more computing devices and or processing systems to implement techniques modules and examples described herein.

As further illustrated in the example system enables ubiquitous environments for a seamless user experience when running applications on a personal computer PC a television device and or a mobile device. Services and applications run substantially similar in all three environments for a common user experience when transitioning from one device to the next while utilizing an application playing a video game watching a video and so on.

In the example system multiple devices are interconnected through a central computing device. The central computing device may be local to the multiple devices or may be located remotely from the multiple devices. In one embodiment the central computing device may be a cloud of one or more server computers that are connected to the multiple devices through a network the Internet or other data communication link.

In one embodiment this interconnection architecture enables functionality to be delivered across multiple devices to provide a common and seamless experience to a user of the multiple devices. Each of the multiple devices may have different physical requirements and capabilities and the central computing device uses a platform to enable the delivery of an experience to the device that is both tailored to the device and yet common to all devices. In one embodiment a class of target devices is created and experiences are tailored to the generic class of devices. A class of devices may be defined by physical features types of usage or other common characteristics of the devices.

In various implementations the computing device may assume a variety of different configurations such as for computer mobile and television uses. Each of these configurations includes devices that may have generally different constructs and capabilities and thus the computing device may be configured according to one or more of the different device classes. For instance the computing device may be implemented as the computer class of a device that includes a personal computer desktop computer a multi screen computer laptop computer netbook and so on.

The computing device may also be implemented as the mobile class of device that includes mobile devices such as a mobile phone portable music player portable gaming device a tablet computer a multi screen computer and so on. The computing device may also be implemented as the television class of device that includes devices having or connected to generally larger screens in casual viewing environments. These devices include televisions set top boxes gaming consoles and so on.

The techniques described herein may be supported by these various configurations of the computing device and are not limited to the specific examples of the techniques described herein. This functionality may also be implemented all or in part through use of a distributed system such as over a cloud via a platform as described below.

The cloud includes and or is representative of a platform for resources . The platform abstracts underlying functionality of hardware e.g. servers and software resources of the cloud . The resources may include applications and or data that can be utilized while computer processing is executed on servers that are remote from the computing device . Resources can also include services provided over the Internet and or through a subscriber network such as a cellular or Wi Fi network.

The platform may abstract resources and functions to connect the computing device with other computing devices. The platform may also serve to abstract scaling of resources to provide a corresponding level of scale to encountered demand for the resources that are implemented via the platform . Accordingly in an interconnected device embodiment implementation of functionality described herein may be distributed throughout the system . For example the functionality may be implemented in part on the computing device as well as via the platform that abstracts the functionality of the cloud .

Although the invention has been described in language specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as example forms of implementing the claimed invention.

