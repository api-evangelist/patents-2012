---

title: Method and node for transmitting data over a communication network using negative acknowledgment
abstract: A method of transmitting data over a communication network using negative acknowledgment is presented. In the method, a stream of data packets is transmitted from a first node of the network to a second node of the network. All but at least two of the stream of data packets is successfully received at the second node, wherein the data packets that are not successfully received are not located sequentially within the stream of data packets. A status packet is transmitted from the second node to the first node, wherein the status packet includes an indication of each of the data packets that were not successfully received. In response to receiving the status packet at the first node, the data packets that were not successfully received at the second node are retransmitted from the first node to the second node in response to receiving the status packet.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09007915&OS=09007915&RS=09007915
owner: Sling Media PVT Ltd.
number: 09007915
owner_city: Bangalore
owner_country: IN
publication_date: 20120427
---
This Application claims priority to U.S. Non Provisional application Ser. No. 12 404 920 filed Mar. 16 2009.

The Internet has become an important and often critical communication network for transporting data of many kinds including textual audio and visual data between distinct nodes of the network. The transfer of this data within the Internet is facilitated by a stack of architectural layers with each layer providing a corresponding type of functionality required of the network to transport the data. Each of these layers at least roughly corresponds to one or more of the seven layers of the Open Systems Interconnection OSI Reference Model which identifies seven different layers i.e. the physical layer the data link layer the network layer the transport layer the session layer the presentation layer and the application layer in ascending order only one of which represents the actual physical network connection. The remaining layers describe the various types of data and associated control information being generated and transferred within the network.

While different portions of the Internet often utilize diverse physical and data link layers much of the Internet employs some version of the Internet Protocol IP for the network layer. Above the IP layer however several different options exist for the transport layer. Two of the more popular options are the Transmission Control Protocol TCP and the User Datagram Protocol UDP . Generally TCP provides for logical connections to be established between two end nodes of the network for subsequent data transfer therebetween. Also TCP provides a data packet acknowledgement timeout and retransmission mechanism as well as a packet sequencing facility to protect against data loss. Conversely UDP does not provide an acknowledgement timeout or retransmission mechanism does not explicitly facilitate data packet sequencing and does not establish a logical connection between two communicating network nodes. Accordingly due to its lower overhead UDP is often utilized in situations in which data loss is less important than any additional delay that may be incurred by using TCP for data packet transmission. Oppositely TCP is typically employed in scenarios in which data reliability and integrity are important considerations.

Many network connected computer systems provide a software sockets application programming interface API to allow software applications executing on the system to employ UDP TCP and other types of transport layers to communicate with other nodes on the network. One such API is the Berkeley Software Distribution BSD Sockets API which provides a number of functions that may be called by applications to create and terminate connections over a network with another node exchange data over such connections and perform related activities using TCP UDP or another transport layer implementation.

While the use of TCP UDP the BSD sockets API and other typical implementations of the various architectural layers of the Internet is widely accepted utilization of these standard communication tools by two communication network nodes may not adequately address some specific data characteristics network environments and other concerns.

The enclosed drawings and the following description depict specific embodiments of the invention to teach those skilled in the art how to make and use the best mode of the invention. For the purpose of teaching inventive principles some conventional aspects have been simplified or omitted. Those skilled in the art will appreciate variations of these embodiments that fall within the scope of the invention. Those skilled in the art will also appreciate that the features described below can be combined in various ways to form multiple embodiments of the invention. As a result the invention is not limited to the specific embodiments described below but only by the claims and their equivalents.

While the embodiments of depict the data packets being transferred solely from the first node to the second node data transmissions between the nodes may occur from the second node to the first node as well resulting in bidirectional or duplex communication between the nodes .

Use of the method allows the second node to report to the first node the identity of non sequential packets that were not received successfully from the first node in a single status packet . Further the method allows the second node to negatively acknowledge multiple unsuccessful data packets whether or not sequentially positioned or forming a contiguous group of the stream of data packets being transferred from the first node . Thus fewer status packets are required to be transferred from the second node to the first node while the first node receives information regarding the success of the data packet transmissions in a timelier manner than with a standard acknowledgement scheme.

The software hierarchy includes an application a sockets module a reliability module a connectivity module and a transport network layer protocol stack such as a TCP IP stack including support for a connectionless transport layer protocol such as UDP. The application may be any application level software requiring access to a communication network. In one specific implementation the application may be an audio video stream source and or display application thus necessitating access to the communication network for the transmission and or reception of audio video data. For example an audio video destination such as a computer system a personal digital assistant PDA or a mobile communication device may attempt to establish a communication connection with a video source node such as a Slingbox by Sling Media Inc. coupled to a satellite or cable set top box so that the destination node may stream video from the set top box via the source node over the network. In this case the source node may be viewed as a server node while the destination node may be regarded as a client node with both the server node and the client node each separately implementing the software hierarchy of .

The sockets module provides an application programming interface API through which the application of the client or server device may access the network including the establishment of connections and transfer of data over such connections. Such an interface is often facilitated by way of a set of function calls provided by the sockets module . Generally a socket is an endpoint of a communication path through the network defined by a node address such as an IP address and a port number. The sockets module allows the application to create one or more such sockets request a connection to another node using the socket transmit and or receive data via the socket free the socket and other applicable tasks. One example of the sockets module is discussed in U.S. Patent Publication No. 20100232438 A1 entitled Method and Node for Employing Network Connections over a Connectionless Transport Layer Protocol filed Mar. 16 2009 which is hereby incorporated by reference herein in its entirety.

The sockets module accesses the reliability module to facilitate various protection mechanisms for the user data being transferred over an established connection between network nodes. In one implementation such mechanisms may include but are not limited to sequencing of the user data packets to facilitate their proper ordering at the receiving node acknowledgment or non acknowledgment and retransmission of lost user data packets and other functionality not provided by a connectionless transport layer protocol such as UDP. Further the reliability module may implement such protections as a replacement for the standard TCP layer. Software involving data transmissions which employ negative acknowledgment of unsuccessful data packets as mentioned in the above embodiments and discussed in greater detail below provide an example of the reliability module of .

As shown in the sockets module may further interface with a connection module which may facilitate the creation of tunnels or other mechanisms for maintaining a viable communication path between two network nodes.

The sockets module also communicates with the standardized transport network protocol stack such as a TCP IP stack which incorporates a connectionless transport layer protocol such as UDP. The sockets module employs the UDP portion of the TCP IP stack thus circumventing TCP. Also sequencing and retransmission capabilities supplied by the reliability module may also be implemented in lieu of the corresponding functionality normally provided in TCP. Thus the functionality provided by the sockets module the reliability module and the connectivity module may be tailored to address various aspects of specific communication environments more efficiently than that provided by TCP.

As shown in the application communicates with the sockets module by way of function calls without having to engage in the specific details of the other modules provided in the software hierarchy . In turn the sockets module handles the required communications with the other modules primarily in response to the function calls . In one implementation a general control path between the sockets module and the reliability module as well as between the sockets module and each of the connectivity module and the protocol stack allows the sockets module to control each resulting protocol layer involved in network communications with another node.

The communication interface is configured to transmit and receive data packets with the other node of the network . In one example the communication interface is an interface configured to communicate over an IP network implemented over a wired or wireless link physical layer. Examples of such layers include Ethernet Wi Fi e.g. IEEE 802.11a b g n digital subscriber line DSL cable modem and others. Also network layers other than IP may be employed in other arrangements. The communication interface may be implemented as a network interface card NIC circuitry located on a computer system motherboard or via other circuit means.

The control circuitry is configured to generate and transmit data packets and status packets via the communication interface to one or more other nodes as well as to receive and process data packets and status packets from those nodes by way of the interface . The structure and use of those packets are discussed in greater detail below. The control circuitry may include one or more processors such as a microprocessor microcontroller or digital signal processor DSP configured to execute instructions directing the processor to perform the functions and facilitate the communication discussed in greater detail below. The control circuitry may also include memory or data storage adapted to contain such instructions. In another implementation the control circuitry may be strictly hardware based logic or may include a combination of hardware firmware and or software elements.

Also possibly included in each of the nodes are one or more memory buffers configured to store data packets such as the original data packets and the retransmitted data packets . In the case of the sending node the memory buffers may store data packets that are either awaiting to be transferred to the second node or have been already transferred and are awaiting subsequent acknowledgment from the second node . In the case of the receiving node the memory buffers may include data packets that have been received from the first node . In one particular implementation each of the buffers may include a single data packet thus allowing a buffer to be freed for storing another data packet when the data packet currently stored in the buffer is no longer needed.

The version indicates the version of the protocol employed in the current header so that the remainder of the header may be properly interpreted thus allowing future changes to the format while allowing backward compatible to older format versions.

The padding bit indicates whether the payload data of the original packet is padded at the trailing end with data that does not constitute payload data. Such padding is often used to ensure that all of the original packets are of the same length regardless of the length of the payload data in any particular packet . In another example the padding may be utilized to ensure that the length of each data packet is a multiple of some value such as four. In one embodiment when the padding bit is set the last byte word octet or other subdivision of the padding data includes an indication of the amount of the packet data is padding and may thus be ignored at the receiving node .

The extension bit when set indicates whether the header includes a header extension appended to the end of the normal header. In one embodiment the header bit is cleared for all original data packets and retransmitted data packets thus indicating that no header extension is included in the data packets .

The reserved field is a portion of the header reserved for use in future versions of the header protocol. In one embodiment the reserved field may include all zeros.

The payload type may indicate that the payload data of the original data packet is of or is associated with a particular type of data. In one example the payload type indicates whether the current packet is a data packet such as an original data packet or a retransmitted data packet or a status packet of . In this case the payload type indicates whether or not payload or user data is included in the packet as status packets may not ordinarily carry substantive payload data.

The sequence number is a number distinguishing the current data packet from other data packets sent by the same node . In one example the sequence number of the first packet is zero and is incremented by one for each subsequent packet transmitted by the node . As is described below the second node receiving data packets may employ the sequence number to indicate which of the stream of data packets have been successfully received and which must be retransmitted by the first node .

The timestamp indicates a time at which the current packet was transmitted by the first node . In one example the timestamp indicates a time with a precision on the order of milliseconds as generated by a system clock. Further the timestamp may represent a monotonic linearly increasing time value. In some embodiments as described in greater detail below the timestamp may be employed to determine jitter i.e. the variable amount of delay the data packets may incur as they traverse the network . In the case of a status packet a similar timestamp shown in may help determine roundtrip time from the standpoint of the second node i.e. the time from the transmission of a status packet from the second node to the receipt of an associated retransmitted data packet at the second node . Calculation of this roundtrip time is discussed more fully below.

The session identifier may indicate the source transmitting node of the current packet . In one example the session identifier is randomly chosen so that different source nodes are likely to generate different session identifiers . In another example the session identifier may further distinguish between different sessions or different streams of data packets being transferred to one or more other nodes over the network . In one example data packets of an older session received at the second node may be ignored in favor of data packets associated with a current session from the first node . In yet another implementation the source node may apply different session identifiers to original data packets and retransmitted data packets so that the second node may more easily distinguish between the two.

The sender buffer filled percentage and the sender buffer count together indicate the current status of memory buffers of the source node of the current data packet . More specifically the sender buffer count may indicate the total number of buffers employed in the source node to hold the data packets . The sender buffer filled percentage may indicate the current percentage of the buffers holding data packets awaiting to be transmitted to and or be acknowledged by the second node . Thus the combination of the sender buffer filled percentage and the sender buffer count may indicate the number of buffers awaiting transmission and acknowledgment before being freed for a subsequent data packet . In one implementation only the sender buffer filled percentage may be employed to make that determination. In another example a sender buffer filled number may be employed in lieu of the sender buffer filled percentage to reflect similar information regarding the source buffers . The second node as recipient of this information may use the information to determine how often data packets should be positively and or negatively acknowledged to allow the first node to free its buffers to allow newer data packets to be loaded into the buffers .

A sender buffer filled percentage field and a sender buffer count such as the sender buffer filled percentage field and the sender buffer count of the original data packet header are not employed in the specific retransmitted data packet header of although such fields providing the same information may be incorporated into other implementations.

Two additional fields provided in the retransmitted data packet header are an echo timestamp and an original sequence number . The echo timestamp is a copy of a timestamp provided in a status packet shown in and described more fully below. More specifically a retransmitted data packet carrying payload data of a data packet negatively acknowledged in a status packet carries an echo timestamp from the header of that status packet . The echo timestamp is used in one embodiment to determine a roundtrip time from the moment a status packet is transmitted to the first node until a retransmitted data packet negatively acknowledged in the status packet is received at the second node . Calculation of the roundtrip time is discussed in greater detail below in conjunction with .

The original sequence number is a copy of the sequence number of the original data packet whose payload data is carried in the current retransmitted data packet . The original sequence number thus facilitates identification of the retransmitted data packet with its corresponding original data packet at the second receiving node .

The status packet header provides a number of fields similar to corresponding fields of the original data packet header . More specifically the status packet header of includes a version field a padding bit an extension bit a reserved field a payload type a sequence number a timestamp and a session identifier each of which provide similar information as the corresponding fields of the original data packet header .

Also provided in the status packet header are a receiver buffer filled percentage and a receiver buffer count reflecting information analogous to the sender buffer related information fields of the original data packet header . However the receiver buffer filled percentage and the receiver buffer count apply to memory buffers of a node receiving data packets such as the second node of . In one embodiment the first node may employ this information to alter the transmission rate of the data packets to the second node as is described in greater detail below.

The status packet header of also provides an extended header as exhibited by fields . The existence of this extended header may be noted in the extension bit of the header . Further an extension length may indicate how many bytes are included in the extended header. In another implementation the extension bit may not be set unless additional header information is added beyond the fields depicted in . In addition a bitmask may indicate which of the following fields in the extended header are present and or valid.

The status packet header may include a highest correct sequence number which would indicate the highest sequence number of a contiguous block of data packets transmitted by the first node that have been successfully received by the second node . In other words for a particular sequence number noted in the highest correct sequence number all packets having a sequence number less than or equal to that sequence number have been or are being positively acknowledged in the current status packet .

Also possibly included in the status packet header are a starting sequence number and an ending sequence number which reflect a range of sequence numbers for data packets for which the current status packet is acknowledging as being successfully received at the second node with the exception of any lost packets specified in a list following the starting sequence number and the ending sequence number in the header .

In the list of lost packets being negatively acknowledged in the status packet header may include a number of entries with each entry including a lost packet identifier and a lost packet bitmap . Each lost packet identifier includes the sequence number of an original data packet or a retransmitted data packet as shown in the sequence number field of the original data packet or in the original sequence number of a retransmitted data packet header . In one embodiment each lost packet being negatively acknowledged may be identified in such a manner. In another embodiment closely located groups of lost data packets may be identified by indicating a first of the lost packets in a lost packet identifier and then indicating the relative position of one or more other lost packets in the corresponding lost packet bitmap .

In one example in order for a status packet to negatively acknowledge the loss of data packets having sequence numbers N N 2 N 4 and N 8 through N 11 the status packet header may identify the sequence number N in a lost packet identifier . Further the remaining sequence numbers may be identified by way of a binary value of 01010001 11100000 in the associated lost packet bitmap in which each set bit position of the bitmap indicated by a 1 in the binary value identifies an offset of the remaining lost packets from the first lost packet noted in the associated lost packet identifier .

As a result by the use of the various fields of the extended portion of a single status packet header any number of data packets may be positively or negatively acknowledged thus reducing the amount of traffic of status packets from the second node to the first node compared to typical acknowledgment schemes. Further the use of the lost packet bitmaps facilitates negative acknowledgment of numerous packets located closely together thus being particularly suited for communication environments in which burst data packet errors are expected.

In operation the first node of the network of may transmit a stream of original data packets to the second node . In response the second node may transmit status packets to the first node from time to time positively and or negatively acknowledging one or more of the original data packets . In response to those packets that were negatively acknowledged the first node may attempt to retransmit those data packets as retransmitted data packets to the second node .

The first node may transfer original data packets to the second node under a variety of circumstances. For example the first node may initiate such a transmission when an application such as the application of supplies new data for that transmission. At other times the first node may limit transmission bursts to once every predetermined period of time such as once every few milliseconds. In another example the first node may transmit original data packets and or retransmitted data packets whenever a status packet is received from the second node .

The first node may also control the rate of transmission of the data packets to the second node by maximizing data flow while minimizing the chance of an overflow condition at the second node . In one implementation the first node may control the transmission rate based on an estimated bandwidth of a connection between the first node and the second node . This estimated bandwidth may be based upon information received by the first node in the status packets from the second node . For example the first node may calculate a packet loss percentage based upon the relative number of data packets being positively and or negatively acknowledged by the second node . Thus the estimated bandwidth may first be set to some default value and then altered as information from the returning status packets is received and processed. This information may be calculated periodically based on a static time period or based upon a roundtrip time measured from the perspective of the first node .

In one example if the calculated packet loss percentage is less than a specific value such as 5 the first node may increase the estimated bandwidth such as by a percentage of the current actual transmission rate of the data packets . An example of such a percentage may be 5 . Otherwise the new estimated bandwidth value may be decreased such as to a mean value of the current estimated bandwidth and the current actual transmission rate. In a further implementation if the first node has increased the estimated bandwidth some number of consecutive times the first node may aggressively increase the estimated bandwidth further by a higher percentage such as 10 of the current actual transmission rate. In another embodiment minimum and maximum estimated bandwidth values may also be employed.

The first node may also control the flow or rate of the transmissions based on the receiver buffer filled percentage and the receiver buffer count values of the header of the status packets being received from the second node . Generally the first node will stop or reduce the transmissions if the header fields indicate that the memory buffers of the second node are approaching a full state. In one embodiment the first node may be configured to transmit the data packets at a more aggressive rate than what may be indicated by the state of the memory buffers in the second node . Use of this embodiment may be particularly appropriate in cases in which a roundtrip time as calculated at the first node exceeds some level such as 200 milliseconds. With longer roundtrip times the first node may presume that the memory buffers in the second node are emptier than indicated via the receiver buffer filled percentage since many of the data packets being transmitted would have already been consumed by the application in the second node with the corresponding status packets acknowledging receipt of those data packets remaining in return flight from the second node to the first node for a substantial period of time.

To determine the roundtrip time from the perspective of the first node in one implementation the first node may track the timestamps noted in the original data packets being transmitted from the first node and then subtract therefrom the time of arrival of the status packets positively acknowledging receipt of those original data packets . The first node may then average or otherwise process the resulting values to determine the roundtrip time from the standpoint of the first node which may then be employed to determine if the aggressive data packet transmission rates are to be utilized.

Generally the second node may transmit a status packet to positively acknowledge successfully received data packets in response to any of a number of conditions. In one example the second node may transmit such a status packet when the first node indicates that some predetermined minimum percentage e.g. 10 of its memory buffers store data packets that have been transmitted and are awaiting acknowledgment. Such information may be determined in part from the sender buffer count located in the header of the original data packets received at the second node . The second node may then estimate the percentage by comparing the sender buffer count to the highest sequence number of the original data packets successfully received at the second node minus the highest sequence number of the original data packets that the second node has positively acknowledged in a status packet . The second node may also transmit status packets acknowledging received data packets once per some predetermined period of time such as once every 100 milliseconds.

In another embodiment the second node may periodically transmit a status packet as a request for more data packets which may be used when all previous data packets have been positively acknowledged by the second node and the flow of subsequent data packets from the first node has stopped. Such a circumstance may occur if the first node has transmitted all available data packets resulting in empty memory buffers in the first node . The second node may periodically transmit such a status packet until the second node receives more data packets . Use of the status packets in this manner serves as protection against the possibility that the first node has actually transmitted subsequent data packets which are not received at the second node . Use of the status packets in this fashion also aids in determining whether the connection between the first node and the second node is still operational. In one example these status packets indicate the sequence number of last received data packet as the highest correct sequence number in the status packet header .

As indicated above any of the status packets that positively acknowledge received data packets may also include the identities of lost data packets being negatively acknowledged. In another example the second node may specifically transmit a status packet negatively acknowledging a lost original data packet if the timestamp in the header of a subsequent data packet i.e. a successful data packet with a higher sequence number than that of the lost data packet is less than the time at which the subsequent data packet is received at the second node minus a measured jitter of the rate of transmissions of the data packets from the first node . In one implementation the second node may calculate the jitter using the system clock of the second node and the timestamp of the original data packets . For example each of multiple timestamps may be subtracted from the value of the system clock associated with the arrival of the original data packet possessing the associated timestamp . The resulting values may then be averaged and or otherwise processed to determine the jitter.

In one embodiment the second node may transmit one or more additional status packets for the same lost data packet based on a roundtrip time measured from the standpoint of the second node . In one embodiment retransmission of a negative acknowledgment of a specific data packet as part of a status packet may occur if a retransmitted lost packet has not been received and the amount of time since the previous status packet negatively acknowledging the lost packet exceeds some predetermined time period such as the roundtrip time determined from the perspective of the second node .

In one implementation the data packets to be written to the memory buffers are each assigned to one of the buffers by way of an index number based on a hash of the sequence number of the data packet header . For example the index number i.e. 0 1 . . . N 1 of the buffer for storing a particular data particular data packet may be the sequence number of the data packet modulo the number of buffers i.e. N . In this case the number of memory buffers may be a power of two to simplify the hashing function as well as to efficiently handle wraparound of the sequence number from a maximum value to zero.

To facilitate deletion of data packets from the memory buffers once acknowledged memory buffers are configured to form a doubly linked list so that the buffers may be traversed in either ascending or descending sequence number order deleting all acknowledged data packets quickly thus allowing the first node to populate the freed buffers with newer data packets in advance of transmission.

At least some embodiments as described herein for transmitting data between two networks nodes using negative acknowledgment may provide a number of advantages. Overall using negatively acknowledgement of multiple and potentially non sequential lost data packets reduces the amount of status packet traffic from the receiving node to the sending node. Further including acknowledgment of successfully received data packets in the same status packets facilitates the freeing of acknowledged data packets in buffers of the sending node thus allowing earlier storing of newer data packets in the buffers prior to transmission as well as reduced packet overhead. In addition transmission of data and status packets may be based on measured data transmission characteristics passed between the sending and receiving nodes instead of on predetermined timer values thus making the overall communication system adaptable to current transmission conditions in the network. As a result implementation of the various aspects of the invention as discussed above may provide significant communication performance gains over more standard protocols such as TCP in varied communication environments such as wired LAN Wi Fi and WAN. Further advantages may be ascertained from the discussion of the embodiments presented above.

While several embodiments of the invention have been discussed herein other implementations encompassed by the scope of the invention are possible. For example while various embodiments have been described primarily within the context of one network node transmitting audio video stream data to another network node any other form of data that may be transmitted and received by nodes of a communication network such as an IP network may be transferred according the concepts presented herein. In addition aspects of one embodiment disclosed herein may be combined with those of alternative embodiments to create further implementations of the present invention. Thus while the present invention has been described in the context of specific embodiments such descriptions are provided for illustration and not limitation. Accordingly the proper scope of the present invention is delimited only by the following claims and their equivalents.

