---

title: Large-page optimization in virtual memory paging systems
abstract: A computer system that is programmed with virtual memory accesses to physical memory employs multi-bit counters associated with its page table entries. When a page walker visits a page table entry, the multi-bit counter associated with that page table entry is incremented by one. The computer operating system uses the counts in the multi-bit counters of different page table entries to determine where large pages can be deployed effectively. In a virtualized computer system having a nested paging system, multi-bit counters associated with both its primary page table entries and its nested page table entries are used. These multi-bit counters are incremented during nested page walks. Subsequently, the guest operating systems and the virtual machine monitors use the counts in the appropriate multi-bit counters to determine where large pages can be deployed effectively.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619399&OS=09619399&RS=09619399
owner: VMware, Inc.
number: 09619399
owner_city: Palo Alto
owner_country: US
publication_date: 20120621
---
This application is a Continuation of U.S. patent application Ser. No. 12 014 544 filed Jan. 15 2008.

Modern computers employ virtual memory to decouple processes from the physical memory addresses backing the address space of the processes. Using virtual memory enables processes to have a large contiguous address space and allows the computer to run more processes than can fit simultaneously in their entirety in the available physical memory i.e. to over commit memory . To do this virtual memory space is divided into pages of a fixed size typically 4 kB 2 MB or 1 GB and each page of the virtual memory space either maps onto a page within the physical memory of the same page size or it maps to nothing.

Translation of a virtual memory address to a physical memory address is done by traversing page tables in RAM that contain mapping information. To speed up translation a TLB translation lookaside buffer is typically used. The TLB provides faster translation of virtual addresses to physical addresses than does accessing page tables in RAM because the TLB can provide the beginning to end mapping in a single step and because the TLB can be implemented in a small and therefore fast to access data structure closer to or in the CPU itself. However the TLB is limited in size and often a virtual memory page cannot be found in the TLB. Whenever this happens a TLB miss occurs and the mapping has to be performed by a traversal of the page tables commonly known as a page walk a much slower process than look ups in the TLB.

Use of large pages reduces the number of TLB misses and generally improves performance of virtual memory systems. However the use of large pages also generally reduces the ability of an operating system to efficiently utilize the physical memory. Since large pages pose this inherent tradeoff between fast memory access and efficient utilization of physical memory large pages are not typically used universally. Therefore it is important to optimize their use and deploy them in places where they will deliver the biggest performance improvement.

One or more embodiments of the invention provide support for improving virtual memory system performance using large pages. In one embodiment virtual memory system performance is improved using large pages in a normal non virtualized computer system. In another embodiment virtual memory system performance is improved using large pages in a virtualized computer system that employs nested page tables. Other names are used for various designs and implementations of essentially the same concept including extended page tables and rapid virtualization indexing. For brevity and without loss of generality the terms nested paging and nested page tables are used herein to refer to all such designs and implementations.

Hardware support according to one or more embodiments of the invention includes a multi bit counter associated with a page table entry and a hardware page walker that increments the multi bit counter by one when it visits that page table entry. The computer operating system uses the counts in the multi bit counters of different page table entries to determine where large pages can be deployed effectively.

A computer system according to another embodiment of the invention has hardware resources including a host processor and a host memory and is programmed with a virtual machine VM having a virtualized processor and a virtualized physical memory that are operatively coupled to the hardware resources under the control of a virtualization software. The computer system further includes a nested paging system that provides a first address translation from the VM s virtual memory address to the VM s physical memory address using primary page tables and a second address translation from the VM s physical memory address to the host physical memory address using nested page tables. In this embodiment multi bit counters may be set up for page table entries of a primary page table and for page table entries of a nested page table. When a nested page walker visits a page table entry the multi bit counter in that page table entry is incremented by one.

The operating system is typically the master control program of the computer system . Among other things the operating system manages the resources of the computer system such as the secondary memory and forms a software platform on top of which the application programs run. The application programs request services of or through the operating system via application programming interfaces.

The operating system is responsible for setting up and managing a separate virtual memory for each of the separate processes that are running in the computer system . Each of the virtual memory address spaces and the physical memory address spaces are divided into blocks of contiguous memory addresses known as pages and page tables provide a mapping of the virtual memory pages to the physical memory pages. In one embodiment page sizes include 4 kB default page size and 2 MB large page size and page sizes may vary between pages. Each address may be decomposed into a page number which is the lowest of the addresses in a contiguous block of memory represented by the page and an offset within that page.

The CPU receives user input from one or more of the peripherals executes programming instructions stored in the RAM and the secondary memory operates on data stored in the RAM and the secondary memory and transmits output to one or more of the peripherals . The peripherals include input devices such as keyboard mouse or any other device for providing input data to the computer system and output devices such as monitor printer or any other device for receiving output data from the computer system . The CPU may use the RAM and the secondary memory in any combination for memory operations.

The computer system may be provided with any amount of RAM and any amount of secondary memory . The RAM stores data and software such as the operating system and currently running application programs . The secondary memory stores data and software such as additional application programs in the form of read only memory ROM floppy disks hard disks tape CD ROM etc. Typically the RAM stores the data and the software that is currently active whereas the secondary memory stores the data and the software that has been used less recently. The RAM is also referred to herein as physical memory. 

The CPU includes a memory management unit MMU . The MMU is responsible for handling memory accesses requested by the CPU . The MMU has various memory management functions such as memory protection cache control and virtual memory management. The MMU is responsible for translating virtual memory addresses into physical memory addresses. The MMU accomplishes this by using a set of one or more page tables that are provided by the operating system for each of the processes. Each set of page tables provides a map of a particular virtual memory to the physical memory. Typically the page tables are included in the RAM . Each set of page tables is organized as a hierarchical tree having one or more levels. At the highest level in the hierarchical tree is a single page table known as the root of the tree. Each of the page tables includes a set of page table entries each of which has a pointer to a page in physical memory that contains data data page or to a page table that is at the next lower level in the page table hierarchy. Consequently each level in the hierarchical tree includes more page tables than the higher level s .

The MMU includes a translation lookaside buffer TLB and a page walker . The TLB is a hardware component that stores mappings of the virtual memory pages to physical memory pages in order to improve the speed of virtual memory accesses. Further each mapping in the TLB includes additional information to facilitate virtual memory accesses such as the size of the particular physical memory page. The TLB may be implemented using any technically feasible structure such as an associative array or hash table. The page walker is a hardware component that is configured to run a sequence of steps known as a page walk that use the page tables to determine a mapping of a virtual memory address to a physical memory address. The page walker is further configured to insert this mapping as an entry in the TLB .

It should be understood that the computer system illustrates selected elements of a general purpose computer system and is not intended to illustrate a specific architecture. For example no particular bus structure is shown because different known bus structures can be used to interconnect the hardware components in a number of ways as desired. Further as shown in the MMU is integrated into the CPU but the MMU can be provided as a discrete component. Similarly the CPU and the RAM can be integrated into a single component. Moreover the number and arrangement of the elements of the computer system can be varied from what is shown and described in ways known in the art.

As shown a virtual memory also known as address space corresponding to a particular process is represented by a column of virtual page numbers VPNs and a virtual memory corresponding to a different process is represented by a separate column of VPNs. A physical memory corresponding to the RAM is represented by a column of physical page numbers PPNs . Different virtual memories are typically set up for each of the different processes that are launched in the computer system consequently there may be any number of virtual memories such as the virtual memory and the virtual memory . However there is only one physical memory . Each row of a TLB includes a VPN and the corresponding PPN.

Solid arrows in illustrate the mapping of various pages of the virtual memory to various pages of the physical memory . Multiple VPNs within the same virtual memory i.e. address space or process may map to the same PPN a functionality known as intra process sharing. For example VPN and VPN of the virtual memory both map to PPN of the physical memory . A dotted arrow in illustrates an exemplary mapping of one page of the virtual memory to one page of the physical memory . Multiple VPNs from different virtual memories i.e. address spaces or processes may map to the same PPN a functionality known as inter process sharing. For example VPN of the virtual memory and VPN of the virtual memory both map to PPN of the physical memory .

The PPN indicates the next page in the page table hierarchy. If a particular PTE is at the lowest level of the page table hierarchy then the PPN points to a data page. If a particular PTE is not at the lowest level of the page table hierarchy then the PPN points to a lower level page table .

The stop bit is set to one to indicate that the corresponding PTE is the lowest level of the page table hierarchy. Since the size of the data pages may vary within the physical memory the stop bit may be set to one in PTEs at various levels in the page table hierarchy. In this fashion the page walk may be short circuited so that one or more levels in the page table hierarchy are not traversed when mapping a large data page that is not in the TLB . At level one in the page tree hierarchy the lowest level that the page table hierarchy supports the stop bit is ignored. In alternative embodiments the stop bit does not exist in PTEs that are at level one in the page table hierarchy. An alternative name for the stop bit accordingly is the L bit where L stands for large page.

In one or more embodiments of the invention two or more unused bits of a conventional PTE are allocated as bits for the counter . The counter monitors the activity of the corresponding PTE. For each of the PTEs the page walker is configured to increment the corresponding counter every time the PTE is accessed. In this fashion the counter records the number of times that its associated PTE is accessed during the page walks. In some embodiments the bits of the counter may subsume the A bit.

In alternative embodiments the counter is not included in PTEs of page tables at every level of the page table hierarchy. Further in some embodiments during periods when information from the counter is not used the operating system saturates the counter thereby bypassing the counter incrementing step. In other embodiments the page walker is configured to generate an interrupt whenever the counter in a PTE saturates. The interrupt may spawn a variety of activity such as a targeted drain of the saturated counter e.g. recording that the saturation occurred and subsequently resetting the saturated counter or a streamlined search for pages to map larger. In other embodiments the counters are not included in any of the PTEs . Instead the counters are included in a completely different data structure that the page walker maintains in parallel to the page tables . The page walker increments the counters in the parallel data structure during page walks.

As shown the virtual address is subdivided into five fields level four index bits level three index bits level two index bits level one index bits and offset bits . Depending on the size of the virtual address the virtual address may include additional bits that are not used during the mapping of virtual memory addresses to physical memory addresses. Each of the index bits and the offset bits may include any number of bits as appropriate for the computer system . In alternative embodiments the bits in the virtual address may be subdivided into more or fewer fields. Typically the subdivision of the virtual address reflects the number of levels supported by the page walker the size of the smallest available physical pages the size of the virtual memory address space and the size of the physical memory address space.

In this embodiment the page walker uses the page table root to determine that the level four page table is the page table . The page walker then uses the level four index bits to index into the page table thereby obtaining a level four PTE. The page walker uses the PPN stored in this level four PTE to determine that the level three page table is the page table . The page walker uses the level three index bits to index into the page table thereby obtaining a level three PTE. The page walker uses the PPN stored in this level three PTE to determine that the level two page table is the page table . The page walker uses the level two index bits to index into the page table thereby obtaining a level two PTE. The page walker uses the PPN stored in this level two PTE to determine that the level one page table is the page table . The page walker uses the level one index bits to index into the page table thereby obtaining a level one PTE. The page walker uses the PPN stored in this level one PTE to access the data page . Subsequently the page walker uses the offset bits to index into the data page thereby accessing the data corresponding to the virtual address . In addition the page walker enters the pair consisting of the virtual page number corresponding to the index bits and the physical page number corresponding to the data page into the TLB .

If the stop bit is set to one in a PTE that is accessed at a higher level in the page table hierarchy then the page walker uses the PPN in the corresponding PTE to access a large data page. The page walker then indexes into the large data page using a composition of the remaining index bits of the virtual address and the offset bits thereby accessing the data corresponding to the virtual address . In addition the page walker enters the large page mapping into the TLB .

As shown the method begins at step where the page walker receives a virtual address. At step the page walker sets the current physical page number to the page table root . At step the page walker uses a portion of the virtual address to index into the page table that is identified by the current physical page number thereby accessing a current page table entry. At step the page walker evaluates access properties e.g. whether the access is for read write or execution purposes in conjunction with additional bits in the current page table entry e.g. the write permission W bit and the page present bit P to determine if the requested access is permissible. If the page walker determines that the requested access is not permissible then the page walker proceeds to step . At step the page walker delivers a page fault and the method terminates. If at step the page walker determines that the requested access is permissible then the page walker proceeds to step . At step if the counter in the current page table entry is not saturated then the page walker increments the counter by one. If the counter is saturated then step is skipped. At step the page walker sets the current physical page number to the physical page number in the current page table entry.

At step if the stop bit in the current page table entry is not set to one then the method returns to step . The method continues in this fashion looping through steps and until the page walker traverses through the page tables to the lowest level in the page table hierarchy i.e. encounters a page table entry with a stop bit set to one or reaches level one in the page table hierarchy. If at step the current page table entry is at the lowest level in the page table hierarchy then the method proceeds to step . At step the page walker inserts the pair consisting of the virtual page number corresponding to the virtual address and the current physical page number into the TLB . As part of step the page walker may clear an appropriate number of low order bits in the virtual page number and the current physical page number before inserting the pair into the TLB . For example if the page walker stopped traversing the page tables at level one then the page walker does not clear any bits. However if the page walker stopped traversing the page tables at a higher level in the page table hierarchy then the page walker clears one or more bits as determined by the large page s size. At step the page walker uses a portion of the virtual address to index into the data page that is identified by the current physical page number and accesses the data at the physical address corresponding to the virtual address.

Using the counters in the PTEs in this fashion the page walker tracks the activity throughout the page tables during the page walks that are initiated after TLB misses. Further the existence of this activity tracking data enables the operating system to define a policy for deploying large pages using any technically feasible method.

In one embodiment the operating system first clears all of the counters to zero. Then the operating system allows the counters to accumulate as various application programs run on the computer system . After a specified length of time a profiling program searches through the page tables starting from the page table root . At the page table root the profiling program identifies one or more PTEs that include counters set to a high count thus indicating a high number of accesses during the page walks. The profiling program then follows the corresponding PPN in the identified high activity PTEs to the next lower hierarchical level. The profiling program continues to identify high activity PTEs and traverses to the child PTEs until the profiling program has identified a set of high activity PTEs at level two in the page table hierarchy. If any of the level two PTEs has a counter value that exceeds a threshold value then the operating system may select one or more of the level two PTEs to be mapped to a large page. For each of the selected level two PTEs the operating system allocates a 2 MB large page in the following manner. First the operating system copies the data from the collection of small pages accessed through the selected level two PTE to the newly allocated 2 MB large page. If any of the small pages had been swapped out or not allocated until now the operating system may swap in or pre zero missing pieces. The operating system then sets the stop bit in the selected level two PTE to one thereby indicating that the selected level two PTE is now the lowest level in the page table hierarchy when mapping this 2 MB range of virtual addresses. Finally the operating system sets the PPN in the selected level two PTE to point to the newly allocated 2 MB large page. A wide variety of other techniques may be used to define and execute a policy for large page table mapping.

In another embodiment the page walker is configured to generate an interrupt whenever one of the counters saturates. In such an embodiment an interrupt triggers the operating system to either perform a targeted drain of the saturated counter or guides the profiling program to search for high activity PTEs starting from the PTE that generated the interrupt. In other embodiments the page walker may be configured to only increment the counters during selected page walks thereby sampling a subset of the page walks. For example the profiling program might specify a numerical parameter that indicates which fraction of the page walks to sample e.g. one out of one hundred . Subsequently the page walker might be configured to pseudo randomly select page walks during which to increment the counters such that overall the counters are incremented during one percent of the page walks.

The virtual machine monitor is a software interface layer on top of which one or more virtual machines run. The virtual machine monitor may run on top of the host operating system or directly on the hardware components . Together the virtual machine monitor and the virtual machine create a virtualized computer system that gives the appearance of being distinct from the computer system . The virtual machine includes a guest operating system and one or more guest application programs . The guest operating system is the master control program of the virtualized computer system and among other things the guest operating system forms a software platform on top of which the guest application programs run. Whenever any of the guest application programs starts a new guest process is created. Further each of the guest application programs may be started multiple times resulting in multiple guest processes.

Many of the hardware components of the computer system are interchangeable with the hardware components of the computer system . Further the basic functionality of each of the hardware components is similar to the functionality of the corresponding hardware component .

The guest operating system is responsible for setting up and managing a separate virtual memory for each of the separate guest processes that are running in the virtual machine . The VMM is responsible for setting up and managing a separate physical memory that emulates the virtual RAM in the virtualized computer system represented by each separate virtual machine . The memory directly corresponding to the RAM is referred to herein as machine memory. For each process the guest operating system defines a set of primary page tables that map virtual addresses to physical addresses of the virtual RAM. Similarly for each virtual machine the VMM defines a set of nested page tables that map physical addresses of the virtual RAM also referred to herein as virtualized physical memory addresses to machine addresses also referred to herein as host physical memory addresses . As shown typically both the primary page tables and the nested page tables are stored in the RAM . However if a particular page table is inactive then the page table may be stored in secondary memory .

Each set of primary page tables is organized as a hierarchical tree having one or more levels. The highest level in the hierarchical tree for a given process is a single primary page table known as the root of the tree. Each of the primary page tables includes a set of page table entries each of which has a pointer to a data page or a primary page table at the next lower level in the hierarchy. Consequently each level in the hierarchical tree includes more primary page tables than the higher level s .

Similarly each set of nested page tables is organized as a hierarchical tree having one or more levels. The highest level in the hierarchical tree for a given virtual machine is a single nested page table known as the root of the tree. Each of the nested page tables includes a set of page table entries each of which points to a data page or a nested page table at the next lower level in the hierarchy. Consequently each level in the hierarchical tree includes more nested page tables than the higher level s .

MMU is responsible for handling memory accesses requested by the CPU and carries out the virtual memory translation function. To accomplish this function the MMU includes a translation lookaside buffer TLB and a nested page walker . The TLB is a hardware component that stores mappings of virtual memory pages to machine memory pages in order to improve the speed of virtual memory accesses. Each mapping in the TLB includes additional information to facilitate virtual memory accesses such as the size of the particular machine memory page. The TLB may be implemented using any technically feasible structure such as an associative array or hash table. The nested page walker is a hardware component that is configured to run a sequence of steps known as a nested page walk that use the primary page tables and the nested page tables to determine a mapping of the virtual memory to the machine memory. The nested page walker is further configured to insert this mapping as an entry in the TLB .

It should be understood that the computer system illustrates selected elements of a general purpose computer system and is not intended to illustrate a specific architecture. Further as shown in the MMU is integrated into the CPU but the MMU can be provided as a discrete component. Similarly the CPU and the RAM can be integrated into a single component. Moreover the number and arrangement of the elements of the computer system can be varied from what is shown and described in ways known in the art.

As shown a virtual memory also known as address space corresponding to a particular guest process is represented by a column of virtual page numbers VPNs and a virtual memory corresponding to a different guest process is represented by a separate column of VPNs. A physical memory corresponding to a particular virtual machine is represented by a column of physical page numbers PPNs . Lastly a machine memory corresponding to the RAM is represented by a column of machine page numbers MPNs . Different virtual memories are typically set up for each of the different guest processes that are launched in the virtual machine and consequently there may be any number of virtual memories such as the virtual memory and the virtual memory associated with each virtual machine . Similarly different physical memories are typically set up for each of the different virtual machines that are running in the computer system . Although there may be any number of virtual machines and therefore physical memories depicts the physical memory for only one such virtual machine.

Solid arrows in illustrate the mapping of various pages of the virtual memory to various pages of the physical memory and the mapping of various pages of the physical memory to the machine memory . Multiple VPNs within the same virtual memory i.e. address space or process may map to the same PPN a functionality known as intra process sharing. For example VPN and VPN of the virtual memory both map to PPN of the physical memory . Similarly multiple PPNs within the same physical memory may map to the same MPN a functionality known as intra VM sharing. For example PPN and PPN of the physical memory both map to MPN of the machine memory .

Each composite mapping from a specified VPN to a MPN includes a mapping from the specified VPN to an intermediate PPN and a subsequent mapping from the intermediate PPN to the corresponding MPN. Each row in an exemplary TLB includes a VPN and the corresponding MPN that is a composition of two of the illustrated mappings. The TLB does not include any physical page numbers.

A dotted arrow in illustrates an exemplary mapping of one page of the virtual memory to one page of the physical memory . Multiple VPNs from different virtual memories i.e. address spaces or processes may map to the same PPN a functionality known as inter process sharing. For example VPN of the virtual memory and VPN of the virtual memory both map to PPN of the physical memory . Similarly although not shown in multiple PPNs from different physical memories i.e. virtual machines may map to the same MPN a functionality known as inter VM sharing.

The stop bit is set to one to indicate that the corresponding PTE is the lowest level of the primary page table hierarchy. Since the size of the data pages may vary within the physical memory the stop bit may be set to one in PTEs at various levels in the primary page table hierarchy. In this fashion the nested page walk may be short circuited so that one or more levels in the hierarchy of the primary page tables are not traversed when addressing a data page that is mapped large within the physical memory . At level one in the primary page table hierarchy the lowest level that the primary page table hierarchy supports the stop bit is ignored. In alternative embodiments the stop bit may not exist in PTEs that are at level one in the primary page table hierarchy.

Since the physical memory is an abstraction of the machine memory the PPNs do not directly specify pages in the RAM . To access information corresponding to a particular PPN the PPN is converted to a corresponding machine page number. As discussed above mappings of the physical pages to the machine pages are performed by a page walk using the nested page tables . Thus to traverse from a particular PTE to a lower level primary page table the PPN of the PTE needs to be converted to a corresponding MPN by performing a page walk using the nested page tables .

Each counter includes two or more bits that are used to monitor the activity of its corresponding PTE. For each of the PTE the nested page walker is configured to increment the corresponding counter each time the PTE is accessed. In this fashion the counter records the number of times that its associated PTE is accessed during nested page walks.

In alternative embodiments the counter is not included in the PTEs of primary page tables at every level of the primary page table hierarchy. Further in some embodiments the guest operating system saturates the counter in one or more of the PTEs thereby bypassing the counter incrementing step. In other embodiments the nested page walker may be configured to generate an interrupt whenever the counter in a PTE saturates. In some embodiments the counters are not included in any of the PTEs . Instead the counters are included in a completely different data structure that the nested page walker maintains in parallel to the primary page tables . The nested page walker increments the counters in the parallel data structure during nested page walks. In other embodiments the nested page walker may be configured to sample the usage of the primary page tables during nested page walks by only incrementing the counters within the PTEs of the primary page tables during selected nested page walks.

As shown in detail for the nested page table each nested page table includes one or more page table entries PTEs e.g. PTE PTE . . . PTE N collectively referred to as PTEs . Further each of the PTEs e.g. PTE includes a machine page number MPN a stop bit and a counter . The MPN indicates the next page in the nested page table hierarchy. If a particular PTE is at the lowest level of the nested page table hierarchy then the MPN points to a data page. If a particular PTE is not at the lowest level of the nested page table hierarchy then the MPN points to a lower level nested page table .

The stop bit is set to one to indicate that the corresponding PTE is the lowest level of the nested page table hierarchy and consequently the MPN corresponds to a data page. Since the size of the data pages may vary within the machine memory the stop bit may be set to one in PTEs at various levels in the nested page table hierarchy. In this fashion the nested page walk and the page walk may be short circuited so that one or more levels in the nested page table hierarchy of the nested page tables are not traversed when addressing a data page that is mapped large within the machine memory . At level one in the nested page table hierarchy the lowest level that the nested page table hierarchy supports the stop bit is ignored. In alternative embodiments the stop bit may not exist in PTEs that are at level one in the nested page table hierarchy.

Each counter includes two or more bits that are used to monitor the activity of the corresponding PTE. For each of the PTEs the nested page walker is configured to increment the corresponding counter each time the PTE is accessed. In this fashion the counter records the number of times that its associated PTE is accessed during the nested page walks.

In alternative embodiments the counter is not included in the PTEs of nested page tables at every level of the nested page table hierarchy. Further in some embodiments the host operating system saturates the counter in one or more of the PTEs thereby bypassing the counter incrementing step. In other embodiments the nested page walker is configured to generate an interrupt whenever the counter in a PTE saturates. In some embodiments the counters are not included in any of the PTEs . Instead the counters are included in a completely different data structure that the nested page walker maintains in parallel to the nested page tables . The nested page walker increments the counters in the parallel data structure during nested page walks. In other embodiments the nested page walker may be configured to sample the usage of the nested page tables during nested page walks by only incrementing the counters within the PTEs of the nested page tables during selected nested page walks.

The guest page table root and the primary page tables are in a guest domain that is controlled by the guest operating system . Whenever the guest operating system performs a context switch the guest operating system programs the guest page table root to point to the appropriate set of primary page tables . Similarly the host page table root and the nested page tables are in a VMM domain that is controlled by the VMM . Whenever the VMM runs a different VM the VMM programs the host page table root to point to the appropriate set of nested page tables . In this fashion the guest operating system and the VMM cooperatively set up the nested page walker to perform nested page walks.

As shown the method begins at step where the nested page walker receives a virtual address. At step the nested page walker converts the physical page number that is specified by the guest page table root to a machine page number by performing a page walk using the nested page tables . The nested page walker then sets a current machine page number to this machine page number. Note that a series of method steps that may be used to accomplish the conversion at step is described below in method of . At step the nested page walker uses a portion of the virtual address to index into the primary page table that is identified by the current machine page number thereby accessing a current page table entry. At step the nested page walker evaluates access properties e.g. whether the access is for read write or execution purposes in conjunction with additional bits in the current page table entry e.g. the write permission bit and the page present bit to determine if the requested access is permissible. If the nested page walker determines that the requested access is not permissible then the nested page walker proceeds to step . At step the nested page walker delivers a page fault to the guest OS and the method terminates.

If at step the nested page walker determines that the requested access is permissible then the nested page walker proceeds to step . At step if the counter in the current page table entry is not saturated then the nested page walker increments the counter by one. If the counter is saturated then step is skipped. At step the nested page walker converts the physical page number in the current page table entry to a machine page number by performing a page walk using the nested page tables . The nested page walker then sets the current machine page number to this machine page number. Again a series of method steps that may be used to accomplish the conversion at step is described below in method of .

At step if the current page table entry is not at level one in the primary page table hierarchy and the stop bit in the current page table entry is not set to one then the method returns to step . The method continues in this fashion looping through steps and until the nested page walker traverses through the primary page tables to the lowest level in the primary page table hierarchy. If at step the current page table entry is at level one in the primary page table hierarchy or the stop bit in the current page table entry is set to one then the method proceeds to step . At step the nested page walker inserts the virtual page number corresponding to the virtual address received at step and the current machine page number into the TLB . As part of step the nested page walker uses the minimum of the page sizes discovered during both the VPN to PPN translation and the PPN to MPN translation to determine the page size and the alignment for the virtual page number and the machine page number pair that the nested page walker inserts into the TLB . At step the nested page walker uses a portion of the virtual address to index into the data page that is identified by the current machine page number and accesses the data at the machine address corresponding to the virtual address received at step .

As shown the method begins at step where the nested page walker receives a physical address. At step the nested page walker sets the current machine page number to the host page table root . At step the nested page walker uses a portion of the physical address to index into the nested page table that is identified by the current machine page number thereby accessing a current page table entry. At step the nested page walker evaluates access properties e.g. whether the access is for read write or execution purposes in conjunction with additional bits in the current page table entry e.g. the write permission bit and the page present bit to determine if the requested access is permissible. If the nested page walker determines that the requested access is not permissible then the nested page walker proceeds to step . At step the nested page walker delivers a nested page fault to the VMM and the method terminates. If at step the nested page walker determines that the requested access is permissible then the nested page walker proceeds to step . At step if the counter in the current page table entry is not saturated then the nested page walker increments the counter by one. If the counter is saturated then step is skipped. At step the nested page walker sets the current machine page number to the machine page number in the current page table entry.

At step if the current page table entry is not at level one in the nested page table hierarchy and the stop bit in the current page table entry is not set to one then the method returns to step . The method continues in this fashion looping through steps and until the nested page walker traverses through the nested page tables to the lowest level in the nested page table hierarchy. If at step the current page table entry is at level one in the nested page table hierarchy or the stop bit in the current page table entry is set to one then the method proceeds to step . At step the nested page walker returns the current machine page number and the associated page size corresponding to the physical address received at step . The access to the PTE or data at the translated address is then performed by a step in a higher level nested page walker routine such as step or step of the method .

Using the counters in the PTEs as described in the method and the counters in the PTEs as described in the method the nested page walker tracks the activity throughout both the primary page tables and the nested page tables during the nested page walks that are initiated after TLB misses.

In one embodiment the guest operating system uses the information in the counters to define a policy for deploying large data pages in the physical memory using any technically feasible method. Similarly the VMM uses the information in the counters to define a policy for deploying large data pages in the machine memory using any technically feasible method.

Further the VMM may read information in the PTEs in addition to the information in the counters to define a hybrid policy for deploying large data pages. For example each entry in the TLB includes both a VPN and an MPN. A particular entry in the TLB defines a large page mapping only when both the VPN and the MPN are mapped large. One hybrid policy that the VMM may implement is to deploy large pages in machine memory wherever there is a corresponding large page in physical memory and to deploy additional large pages in machine memory based on the values in the counter .

In alternative embodiments the nested page walker may be configured to increment only the counters within the PTEs of the primary page tables or to increment only the counters within the PTEs of the nested page tables .

In the embodiments of the invention described above the page walker and the nested page walker are implemented as a hardware page walker within the MMU and MMU respectively. This hardware page walker includes an incrementing unit that reads a current count from a multi bit counter of a page table entry increments the current count and writes the incremented counter back to the multi bit counter. The hardware page walker also includes an increment enable bit. When this bit is set e.g. set to 1 the hardware page walker increments the multi bit counter of a page table entry when it visits the page table entry. When this bit is not set e.g. set to 0 the hardware page walker does not increment the multi bit counter of a page table entry when it visits the page table entry. The incrementing unit of the hardware page walker may be implemented within the MMU in any manner known to those skilled in the art including as a customized piece of integrated circuitry or using general purpose architectural registers load store units special purpose register processing units and or fixed point units that already exist in the MMU.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims.

