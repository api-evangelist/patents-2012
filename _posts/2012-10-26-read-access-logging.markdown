---

title: Read access logging
abstract: Read access logging is performed by tracing data accesses in all domains. The logged data is traced on metadata level with some additions identifying the exposed data records. All data relevant for read access logging is stored at first in a temporary log, which is later processed, structured, and archived.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08788533&OS=08788533&RS=08788533
owner: SAP AG
number: 08788533
owner_city: Walldorf
owner_country: DE
publication_date: 20121026
---
There are requirements for data protection and privacy in many countries. Read Access Logging RAL is a mechanism usually required when authorizations are not sufficient to address the need for data protection and privacy or when highly sensitive information is accessed.

Configuring logging consistently across many applications is costly and time consuming. Therefore a technology providing a standard solution is desirable. At present logging is addressed only in specific applications. The more applications support logging with local solutions the worse total cost of ownership would be.

Logs are personal information on their own in case personal information is viewed this can be data of two or even more persons and require purpose authorizations deletion etc. like any other data. Some regulations even require encryption.

Logging shall be done where data is disclosed to a user or a third party. This implies that the data that is replicated between different systems of the same controller does not need to be logged. Even a report that is run and produces some output does not need to be logged but when that output is then printed or viewed logging shall take place. This may cause necessity for producing metadata when running the report for later use during printing or viewing at least when highly sensitive information is processed. A challenge can be replication to systems or frontends that do not have adequate logging mechanisms in place or where these mechanisms can be easily bypassed. In that case logging likely has to take place at the time the replication takes place.

Capturing data about access is not sufficient there must be tools to evaluate logs and to delete or archive logs. Logging shall be possible for all user interfaces UIs all downloads and all interfaces or at least those that can be used for external communication. Some regulations require attempts for access to be logged as well.

Various embodiments of systems and methods for read access logging are described herein. In one embodiment the method includes enabling the read access logging for at least one user and at least one data set and receiving an access request from the at least one user via a domain. The method also includes determining a requirement for read access logging for the domain and the at least one user and saving log data for exposed data from the at least one data set to the at least one user in a fast read log file. The method further includes processing the fast read log file into a structured read access log file and auditing the structured read access log file.

In other embodiments the system includes a processor and memory in communication with the processor. The system also includes an enabling module within the memory to enable the read access logging for at least one user and at least one data set and a receiving module within the memory to receive an access request from the at least one user via a domain. The system further includes a determining module within the memory to determine a requirement for read access logging for the domain and the at least one user and a saving module within the memory to save the log data for exposed data from the at least one data set to the at least one user in a fast read log file. The system also includes a processing module within the memory to process the fast read log file into a structured read access log file and an auditing module within the memory to allow auditing the structured read access log file.

These and other benefits and features of embodiments will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for read access logging are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

A read log becomes necessary when users need to be authorized for accessing sensitive information. Requirements imposed by data protection laws enforce that a read log has to provide information about which data is exposed to an interface accessible for users of a system as well as which data is sent out of the system to a third party for example within web service based communication scenarios . In both cases it is not sufficient to simply track data accesses on database level. Tracking data accesses on database level would result in logging data which is merely used for system internal processing. Instead only the data which is actually exposed and might be read by a user shall be traced.

In addition all data transferred to external destinations through the Agent based communication is logged. Such kind of communication includes all third party communication no matter the exact form of communication. Application to application A2A messages are not logged if they are within the same data center as for example Messages between the Application server and Application server within the Data center . Logging is configurable on BO and attributes level. Deletion of the read logs is also configurable.

An auditing user interface for analyzing the log data may be provided. An auditing user interface may be based on the original user interfaces or may be different.

Then at block an access request is received from the user via a domain. The domain may be a standard user interface an inbound or outbound agent for communication some application specific user interface etc. In one embodiment the domain is an application user interface. In some embodiments Business Objects BOs represent the semantic reuse entity for all different kind of domains. All data relevant for read access logging is stored in the persistency of these BOs. According to a programming model and related guidelines this data is only accessible for and accessed by BO external consumers via well defined interfaces of these BOs. This is applicable for domains that access BO data and present this data out of a data center to consumers like analytical reports office integration application user interfaces and output management. In this case the read access logging is based on the BOs as a primary source entity and an attribute as well as BO node instance mapping information in the different domains. In some embodiments the mapping information is persisted in where used lists.

Then at block a requirement for read access logging is determined for the domain and the user. In one embodiment the determination is based on business configuration user settings and tenant specific where used list of relevant business object node attributes. In one embodiment as presented in a Domain specific runtime calls a Read access logging plugin to check if read access logging is required for the given domain model and user . The Read access logging plugin evaluates this information based on its Business configuration User settings and a tenant specific Where used list of relevant BO node attributes the list optimized for runtime evaluations.

Turning back to then at block log data is saved in a fast read log file for exposed data to the user from the data set. The log data is dumped in the fast read log file without any preprocessing except for some data compression thus ensuring low processing time. Referring again to in one embodiment the Domain specific runtime calls the Read access logging plugin for each response exposing BO data from the BO to a consumer such as the user . The domain passes the name of the domain model along with a list of accessed BO node attributes and corresponding identifications of instances. To avoid issues related to data privacy and in order to reduce data load on storage level the log may be based on metadata information for example the user interface application and relevant fields along with the identification of the accessed core BO node instances. Concrete attribute values of the accessed BO node instances shall not be persisted in the log. Saving log data in a fast read log file such as Fast read log file ensures low processing time. There is no preprocessing provided for the fast read log file to avoid low performance issues for the domain.

Turning again to at block the fast read log file is processed into a structured read access log file. The structured read access log file aggregates the information from the fast read log file and stores the data for further processing activities. In one embodiment the processing step includes aggregation of redundant data and deletion of unrequired data for logging. In some embodiments the processing step also includes deleting the fast read log file after a structured read access log file is created. In one embodiment as presented in a Read access logging background processor is looking for unprocessed read log files such as Fast read log file . The Read access logging background processor works asynchronous in the background thus not affecting any user processing time. Load includes configuration data and other specific data for read access logging. The Read access logging background processor analyses data from the Load and mappings and aggregates information from unprocessed read log files such as Fast read log file to a Structured read access log via a BO Read access log . Mappings provide information such as which field in a user interface corresponds to a specific BO field. Mappings are provided to the Read access logging background processor through mapping services such as Generic mapping service Domain specific mapping and Application specific mapping . The mappings are persisted in BOs such as Generic BO mapping Domain specific BO mapping and Application specific BO mapping . In one embodiment if a mapping is not existent which means not provided by the corresponding domain and any available mapping services than this napping may be additionally provided by means of an Extensible Markup Language XML file a table or another standard solution for persisting mappings. Aggregation of the data gathered in unprocessed read log files such as Fast read log file is needed because the log is expected to contain the same accessed data only once and only for those BO node attributes which are actually relevant for read access logging. After being processed the Fast read log file may be deleted.

Turning back to at block the structured read access log file is audited. Auditing includes activities such as filtering searching grouping analyzing etc. In one embodiment auditing includes searching within the structured read access log file. In one embodiment a set of generic auditing user interfaces are supplied providing searching capabilities on the logged data. In some embodiments some capabilities for reconstructing the original attribute values of the business object node instances are provided. For update and delete enabled business objects for which a history of changes is not available a change log BO shall be used to enable a reconstruction of the data for a given point in time. If there is no change log available at all the read access logging may provide at least the information which fields were accessed. If the BO node instance exists and there is no data change in between the point in time when the log is written and the point in time at which the auditor requests to see the logged information the data content may be reconstructed by fetching the current BO data.

In some embodiments an application developer may need to classify business objects business object nodes and business object node attributes as read log relevant. Not all nodes and attributes of a node may be of interest or may technically be enabled. A developer may additionally structure the BO nodes into different Info Groups . If the data is structured into info groups a customer has to select for which info group the Read Access Logging shall be activated. This additional structure level is needed to keep the number of tracing steps and read log records and with that also the system load as small as possible. On node attribute level the developer can also decide to exclude some of them from read access logging.

The system further includes a receiving module within the memory to receive an access request from the at least one user via a domain. The domain may be a standard user interface an inbound or outbound agent for communication some application specific user interface etc. In one embodiment the domain is an application user interface. In some embodiments Business Objects BOs represent the semantic reuse entity for all different kind of domains. All data relevant for read access logging is stored in the persistency of these BOs. According to a programming model and related guidelines this data is only accessible for and accessed by BO external consumers via well defined interfaces of these BOs. This is applicable for domains that access BO data and present this data out of a data center to consumers like analytical reports office integration application user interfaces and output management. In this case the read access logging is based on the BOs as a primary source entity and an attribute as well as BO node instance mapping information in the different domains. In some embodiments the mapping information is persisted in where used lists.

The system also includes a determining module within the memory to determine a requirement for read access logging for the domain and the at least one user. In one embodiment the determining module is also intended to determine the requirement for read access logging for the domain and the at least one user based on business configuration user settings and tenant specific where used list of relevant business object node attributes.

A saving module within the memory is intended to save log data for exposed data from the at least one data set to the at least one user in a fast read log file. In one embodiment the saving module is operable to save a domain model a list of accessed business object node attributes and corresponding identifications of instances.

The system further includes a processing module within the memory to process the fast read log file into a structured read access log file. In one embodiment the processing module is operable to aggregate redundant data and delete unrequired data for logging. In another embodiment the processing module is further operable to delete the fast read log file.

An auditing module within the memory is intended to audit the structured read access log file. In one embodiment the auditing module is operable to search within the structured read access log file.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e. g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e. g. OLAP object oriented databases and the like. Further data sources include tabular data e. g. spreadsheets delimited text files data tagged with a markup language e. g. XML data transactional data unstructured data e. g. text files screen scrapings hierarchical data e. g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e. g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the present disclosure are described herein for illustrative purposes various equivalent modifications are possible within the scope of the present disclosure as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

