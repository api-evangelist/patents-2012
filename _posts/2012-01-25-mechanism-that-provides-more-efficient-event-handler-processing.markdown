---

title: Mechanism that provides more efficient event handler processing
abstract: Disclosed is an apparatus, method, service product, and program product which each provide an enhanced, registration-based event handler mechanism. Listener programs are located and compiled before notification is needed. When notification is ultimately required, the pre-located listeners can be called directly without incurring the performance expense associated with first locating and then calling each listener.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08327386&OS=08327386&RS=08327386
owner: International Business Machines Corporation
number: 08327386
owner_city: Armonk
owner_country: US
publication_date: 20120125
---
This is a continuation application of U.S. patent application Ser. No. 12 407 139 filed Mar. 19 2009 entitled Mechanism that Provides More Efficient Event Handler Processing now issued as U.S. Pat. No. 8 112 765 which is a continuation of U.S. patent application Ser. No. 11 035 553 filed Jan. 14 2005 entitled Mechanism that Provides More Efficient Event Handler Processing now issued as U.S. Pat. No. 7 519 974 B2 both of which are herein incorporated by reference. This application claims priority under 35 U.S.C. 120 of U.S. patent application Ser. No. 11 035 553 filed Jan. 14 2005 now issued as U.S. Pat. No. 7 519 974 and U.S. patent application Ser. No. 12 407 139 filed Mar. 19 2009 now issued as U.S. Pat. No. 8 112 765.

The present invention relates to event handler programs and more particularly to the efficiency of the interaction between a base event handler program and individual sub programs responsible for handling different events.

Computer systems are widely used to store and manipulate data. Data is stored in computer system memory and manipulated by computer system programs executing on the computer system s processor. As is well known a processor is often thought of as the brains of the computer system because it is the component within the computer system that executes the computer system s programs allowing the computer system to do real work. Nevertheless it is really the make up of computer system s programs that determines the variety and extent of the work which can be performed. Therefore while the capabilities of the computer system s processor are important the ultimate throughput of a computer system is largely determined by the performance of its programs. For this reason computer system designers are continually looking for ways to improve program performance.

One area of focus pertains to programs known in the art as event handlers. Generally speaking an event handler is a program that receives events from the computer system s operating system or other facility and takes one or more actions based on the particular type of event. A very simple example is that of a printer running out of paper. Many printers will send an event to the computer system when its paper supply has been exhausted. The computer system s operating system receives this event and forwards it to an event handler. The event handler can then handle the event in a manner consistent with its programming. For example the event handler may post a message to the user or system administrator and or the event handler may cause the computer system to sound an alarm or beep. Some event handlers particularly older designs are monolithic in that they are specifically written to take one or more actions based upon a particular received event. The problem with this approach is the lack of flexibility. I.e. the event handler must be rewritten whenever a new event requires handling or whenever a new action is required.

In recognition of this flexibility issue more modern event handlers have what are referred to as registration interfaces which permit sub programs to register for notification of the receipt of an event. By sub programs we refer to smaller scope programs that typically have a subservient role relative to a larger program. Examples would include procedures i.e. as used in procedural languages and methods i.e. as used in object oriented languages . In object oriented parlance these sub programs are often referred to as listeners or collaborators. We make common use of the term listener in this patent. Registering is the general act of providing sufficient information to the event handler to permit the event handler to contact the listeners at a later time. Taking the printer example a listener might register with the event handler such that the event handler will notify it when an out of paper event is received. The listener would then be responsible for taking the appropriate action e.g. a message beep or alarm .

The flexibility gained from this approach however is not without cost. shows an example design of a prior art event handler. As shown Event Handler includes a Registration Interface . Listeners shown on as Listeners then utilize Registration Interface to instruct Event Handler to notify them when particular events i.e. one of events are received. Thus looking at Dynamic Event Tables and the reader can see that different events have different listeners requiring notification. For example receipt of a Type 1 event requires notification of listeners B E A and C whereas receipt of a Type 3 event requires notification of Listener A. Registration for a given listener includes recording its location in each event table for each event for which it requires notification. Notification is then accomplished by locating the particular listener through the location information stored in the event table and then calling the particular listener. The event tables are said to be dynamic because listeners can be added or removed via Registration Interface .

With this as background the flexibility cost alluded to above is attributable to the overhead associated with first locating and then calling each listener. Referring again to receipt of a Type 1 event Event Handler must first find and call i.e. invoke Listener B then Listener E then Listener A then Listener C. Locating listeners before invoking them is quite costly from a performance perspective. Of course full appreciation of this problem s magnitude becomes more clear when we point out that there may be tens or hundreds of listeners registered for notification of any one event. Therefore while modern event handlers are more flexible in that event handling capability can be added through registration the promise of this approach is limited by the performance penalty associated with locating the multiple listeners before calling them.

Without a mechanism to provide efficient registration based event handling the industry will continue to be faced with the choice between older inflexible event handler designs and newer inefficient ones.

The present invention involves an apparatus method and program product which provides an enhanced registration based event handler mechanism. The method used in the preferred embodiments of the present invention involves locating and compiling each set of sub programs before notification is needed. Then when notification is ultimately required based upon receipt of a given event the sub program can be called directly without bearing the expense associated with first locating and each sub program. Also provided by the present invention is a mechanism for creating the above described enhanced registration based event handler.

The preferred embodiments of the present invention can both be implemented through use of a virtual machine. By virtual machine we mean the well known concept of providing an abstract i.e. virtual machine interface that is architecturally above a real i.e. processor hardware interface. As is well understood this approach permits programs to be written to work against the abstract interface provided by the virtual machine instead of against the actual interface provided by the processor hardware. The benefit to this approach is of course the ability to use the same programs on different hardware platforms that include the same virtual machine interface. The first preferred embodiment of the present invention utilizes the Java Virtual Machine referred to hereafter as JVM architecture from Sun Microsystems . The second preferred embodiment of the present invention utilizes the Common Language Runtime CLR of the .NET framework both from Microsoft Corporation .

Turning now to the remaining drawings shows some of the operational components used in the computing environment of the preferred embodiment of the present invention. Computer system is an enhanced IBM iSeries computer system although other computer systems could be used. Depicted components include Main Memory Processor Mass Storage Network Interface and User Interface . Processor is a Power PC processor used in iSeries computer systems which is used in the preferred embodiments in the conventional way. Main Memory is also used in the preferred embodiments in the conventional manner. Mass Storage is used in to represent one or more secondary storage devices such as magnetic or optical media. Network interface is used to communicate with other computer systems while User Interface is used to accept commands and relay information to the one or more users of Computer System .

Shown within Main Memory is Operating System . Operating System is that known in the industry as IBM i5 OS. Shown utilizing Operating System are Applications Event Handler and Virtual Machine . Applications are programs that make use of the facilities provided by Event Handler and Virtual Machine . Event Handler which is explained in more detail in subsequent paragraphs is responsible for receiving and handling events generated by Applications or by some other facility. It should be noted however that while Event Handler is shown and described herein as a separate entity it could well be incorporated into Operating System one or more of Applications Virtual Machine or into some other facility. Virtual Machine provides an abstraction layer and runtime environment for Applications and potentially any of the other facilities and programs associated with Computer System . As stated above the first preferred embodiment of the present invention utilizes the JVM virtual machine while the second preferred embodiment utilizes the CLR virtual machine.

It should be noted that while the inventors have set forth a specific hardware platform within this specification the present invention and the preferred embodiments should be considered fully applicable to other platforms. It should be further understood that while the embodiments of the present invention are being described herein in the context of a complete system the program mechanisms described e.g. Event Handler and Virtual Machine are capable of being distributed in program product form. Of course a program product can be distributed using different types of signal bearing media including but not limited to recordable type media such as floppy disks CD ROMs and memory sticks and transmission type media such as digital and analog communications links.

It should also be understood that embodiments of the present invention may be delivered as part of a service engagement with a client company nonprofit organization government entity internal organizational structure or the like. Aspects of these embodiments may include configuring a computer system to perform and deploying software systems and web services that implement some or all of the methods described herein. Aspects of these embodiments may also include analyzing the client company creating recommendations responsive to the analysis generating software to implement portions of the recommendations integrating the software into existing processes and infrastructure metering use of the methods and systems described herein allocating expenses to users and billing users for their use of these methods and systems.

At this point the reader should note that Event Handler can be utilized on other platforms i.e. having the same virtual machine type Java or CLR in the preferred embodiments which do not include the enhancements of the present invention. Said another way the applicability of Event Handler to other platforms is not diminished because of the enhancements of the preferred embodiments. Continuing with this point the intermediate representation of Event Handler is compiled into native instructions by Native Compiler referring to and it is Native Compiler that provides contains the enhancements of the preferred embodiments. Thus the intermediate representation of Event Handler not having undergone native compilation is still fully usable on other virtual machines of the same type. Once compiled Event Handler can be executed on Processor . Interpreter can also be used to convert a program s intermediate representation in a native one. While it would be possible to incorporate the benefits and advantages of the present invention into Interpreter the focus here is on Native Compiler .

Referring now to shown is an expanded view of the virtual machine architectures used in the preferred embodiments of the present invention. It should be noted that we have characterized the basic virtual machine functions in generic terms so as to be applicable to both a Java implementation and a CLR implementation. Semantic differences and functional divisions aside the majority of the functions and steps shown in the exploded view of Virtual Machine are present in the standard versions of the Java and CLR virtual machines. As stated earlier the enhancements of the present invention are made in the native compilers shown as Native Compiler of the preferred embodiments. However other functions are also presented here for completeness.

The Base Class Library Support is a standard set of Application Programming Interfaces APIs that allow for an application to have access to commonly used data structures and methods. This support is common across all implementations of the JVM and CLR.

Thread Support is used to provide Applications with the ability to perform tasks in parallel by executing on multiple threads. This area of the Virtual Machine provides method calls and access to specific thread related method and data structures to control application execution.

Type Checker ensures that data being assigned to different pointers or being manipulated in methods for example mathematical methods or text processing is of the same data type to ensure program correctness.

Communication Support is the interface to the communication subsystem of Computer System . This allows for applications running on Virtual Machine to access other computer systems or to broadcast messages across a network.

Security Engine allows for applications to be implemented in a secure manner on the Virtual Machine . This engine controls access to specific areas of code and ensure tamper free execution. This area also interfaces with the security engine of Operating System to provide features such as password verification and resource access verification.

Exception Handler allows for Virtual Machine to catch user program errors and allow them to exit gracefully without destroying the system runtime as well as gather information from the error to allow the programmer to debug and fix the error.

Code Manager is the mechanism in Virtual Machine that manages access to the byte code or MSIL to ensure it is passed to the JIT effectively and compiled to native code when needed. It also controls loading of classes via the Classloader .

The Garbage Collector manages object clean up inside of the memory space of Virtual Machine . This mechanism removes unused objects from the memory space compacts objects that still have references to them and returns a range of available memory to the Virtual Machine for future object allocation.

Interpreter is the mechanism that executes the Java byte code or MSIL directly without compiling it to native code via the JIT. This allows for infrequently used code to be executed without being compiled to native code if not necessary.

Class Loader is the mechanism that allows for byte codes to be loaded into memory from their repository on the system disks. This allows for dynamic loading of the byte code MSIL into memory when it is needed by Applications and not before.

Still referring to an exploded view of Native Compiler will now be presented. It should be noted that within the preferred embodiments i.e. Java and CLR Native Complier is referred to as the Just In Time compiler or JIT compiler for short. The blocks shown in the exploded view of Native Compiler represent the compilation steps. While a new step shown as Call Back Optimizer step has been added other steps are shown here for completeness.

The Flow Analysis step involves statistically analyzing the code executing in Virtual Machine initially all code executed is interpreted and then marking the most frequently executed methods and files in the byte code MSIL for compilation to native code. Optimization is done here as well as the flow of the program is inspected and dead code is removed loops are unrolled etc.

The Method Inlinig step involves finding the most frequently accessed methods between classes and attempting to insert the to be called method directly into the caller method thus optimizing performance by eliminating the calling of the method and associated overhead of Operating System .

Exception Check Elimination involves analyzing programs that are to be executed on Virtual Machine to determine whether one or more exception handlers can be removed and if they can doing so.

Common Subexpression Elimination involves removing redundant or repeated subexpressions in methods to optimize the method so that it does not perform repeated or unnecessary execution. It also optimizes out expressions that can be executed once for the length of the runtime then cached for future execution of the wrapping method

Logging Versioning involves marking loaded byte codes based on the number of passes the Flow Analysis engine has passed over it to keep track of the possibility of further improvement if necessary.

Stack Analysis involves introspection on Virtual Machine s stack to make sure memory usage is as optimal as possible and the stack is operating as efficiently as possible.

After the stack structure has been created in block Call Back Optimizer traverses the stack using reflection on each object to gain access to its method calls i.e. direct call statements . The method calls are then statically linked into the newly generated code segment block . This step thus inserts direct calls to each listener into Event Handler . The processing of blocks and is then repeated for each event structure block . After all of the event structures have been processed Native Compiler proceeds to native code generation. Returning briefly to Native Code Generation follows the Call Back Optimizer steps. It is in this phase that the executable version of Event Handler is created. Once made into executable form Event Handler can be scheduled for execution.

When Event Handler does run on processor i.e. in this optimized form its performance will be markedly improved because each listener can be called directly without the overhead of first determining its location. Production level testing has shown a 14 improvement in overall performance.

The embodiments and examples set forth herein were presented in order to best explain the present invention and its practical application and to thereby enable those skilled in the art to make and use the invention. However those skilled in the art will recognize that the foregoing description and examples have been presented for the purposes of illustration and example only. Thus the description as set forth is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching without departing from the spirit and scope of the following claims.

